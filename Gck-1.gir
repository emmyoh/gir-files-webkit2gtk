<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="gck-1"/>
  <c:include name="gck/gck.h"/>
  <namespace name="Gck" version="1" shared-library="libgck-1.so.0" c:identifier-prefixes="Gck" c:symbol-prefixes="gck">
    <callback name="Allocator" c:type="GckAllocator">
      <doc xml:space="preserve">An allocator used to allocate data for the attributes in this
[struct@Attributes] set.

This is a function that acts like g_realloc. Specifically it frees when length is
set to zero, it allocates when data is set to %NULL, and it reallocates when both
are valid.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">The allocated memory, or %NULL when freeing.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Memory to allocate or deallocate.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">New length of memory.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Attribute" c:type="GckAttribute" glib:type-name="GckAttribute" glib:get-type="gck_attribute_get_type" c:symbol-prefix="attribute">
      <doc xml:space="preserve">This structure represents a PKCS#11 `CK_ATTRIBUTE`. These attributes contain
information about a PKCS#11 object. Use [method@Object.get] or
[method@Object.set] to set and attributes on an object.

Although you are free to allocate a `GckAttribute` in your own code, no
functions in this library will operate on such an attribute.</doc>
      <field name="type" writable="1">
        <doc xml:space="preserve">The attribute type, such as `CKA_LABEL`.</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="value" writable="1">
        <doc xml:space="preserve">The value of the attribute. May be %NULL.</doc>
        <array length="2" zero-terminated="0" c:type="guchar*">
          <type name="guint8" c:type="guchar"/>
        </array>
      </field>
      <field name="length" writable="1">
        <doc xml:space="preserve">The length of the attribute. May be [const@INVALID] if the
attribute is invalid.</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <constructor name="new" c:identifier="gck_attribute_new">
        <doc xml:space="preserve">Create a new PKCS#11 attribute. The value will be copied
into the new attribute.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new attribute; when done with the attribute
         use gck_attribute_free() to free it</doc>
          <type name="Attribute" c:type="GckAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the raw value of the attribute</doc>
            <type name="guint8" c:type="const guchar*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of the attribute</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_boolean" c:identifier="gck_attribute_new_boolean">
        <doc xml:space="preserve">Initialize a PKCS#11 attribute to boolean. This will result
in a CK_BBOOL attribute from the PKCS#11 specs.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new attribute; when done with the attribute u
         gck_attribute_free() to free it</doc>
          <type name="Attribute" c:type="GckAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the boolean value of the attribute</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_date" c:identifier="gck_attribute_new_date">
        <doc xml:space="preserve">Initialize a PKCS#11 attribute to a date. This will result
in a CK_DATE attribute from the PKCS#11 specs.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new attribute; when done with the attribute u
         gck_attribute_free() to free it</doc>
          <type name="Attribute" c:type="GckAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the date value of the attribute</doc>
            <type name="GLib.Date" c:type="const GDate*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_empty" c:identifier="gck_attribute_new_empty">
        <doc xml:space="preserve">Create a new PKCS#11 attribute with empty data.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new attribute; when done with the attribute
         use gck_attribute_free() to free it</doc>
          <type name="Attribute" c:type="GckAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_invalid" c:identifier="gck_attribute_new_invalid">
        <doc xml:space="preserve">Create a new PKCS#11 attribute as 'invalid' or 'not found'
state. Specifically this sets the value length to (CK_ULONG)-1
as specified in the PKCS#11 specification.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new attribute; when done with the attribute
         use gck_attribute_free() to free it</doc>
          <type name="Attribute" c:type="GckAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_string" c:identifier="gck_attribute_new_string">
        <doc xml:space="preserve">Initialize a PKCS#11 attribute to a string. This will result
in an attribute containing the text, but not the null terminator.
The text in the attribute will be of the same encoding as you pass
to this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new attribute; when done with the attribute u
         gck_attribute_free() to free it</doc>
          <type name="Attribute" c:type="GckAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the null-terminated string value of the attribute</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_ulong" c:identifier="gck_attribute_new_ulong">
        <doc xml:space="preserve">Initialize a PKCS#11 attribute to a unsigned long. This will result
in a `CK_ULONG` attribute from the PKCS#11 specs.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new attribute; when done with the attribute u
         gck_attribute_free() to free it</doc>
          <type name="Attribute" c:type="GckAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the ulong value of the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="clear" c:identifier="gck_attribute_clear">
        <doc xml:space="preserve">Clear allocated memory held by a #GckAttribute.

This attribute must have been allocated by a Gck library function, or
the results of this method are undefined.

The type of the attribute will remain set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">Attribute to clear.</doc>
            <type name="Attribute" c:type="GckAttribute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="gck_attribute_dump">
        <doc xml:space="preserve">Dump the specified attribute using g_printerr().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">The attribute</doc>
            <type name="Attribute" c:type="const GckAttribute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="gck_attribute_dup">
        <doc xml:space="preserve">Duplicate the PKCS#11 attribute. All value memory is
also copied.

The @attr must have been allocated or initialized by a Gck function or
the results of this function are undefined.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the duplicated attribute; use gck_attribute_free()
         to free it</doc>
          <type name="Attribute" c:type="GckAttribute*"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">the attribute to duplicate</doc>
            <type name="Attribute" c:type="const GckAttribute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="gck_attribute_equal">
        <doc xml:space="preserve">Compare two attributes. Useful with &lt;code&gt;GHashTable&lt;/code&gt;.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the attributes are equal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr1" transfer-ownership="none">
            <doc xml:space="preserve">first attribute to compare</doc>
            <type name="Attribute" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="attr2" transfer-ownership="none">
            <doc xml:space="preserve">second attribute to compare</doc>
            <type name="Attribute" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gck_attribute_free">
        <doc xml:space="preserve">Free an attribute and its allocated memory. These is usually
used with attributes that are allocated by [ctor@Attribute.new]
or a similar function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">attribute to free</doc>
            <type name="Attribute" c:type="gpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_boolean" c:identifier="gck_attribute_get_boolean">
        <doc xml:space="preserve">Get the CK_BBOOL of a PKCS#11 attribute. No conversion
is performed. It is an error to pass an attribute to this
function unless you're know it's supposed to contain a
boolean value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The boolean value of the attribute.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">The attribute to retrieve value from.</doc>
            <type name="Attribute" c:type="const GckAttribute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="gck_attribute_get_data">
        <doc xml:space="preserve">Get the raw value in the attribute.

This is useful from scripting languages. C callers will generally
access the #GckAttribute struct directly.

This function will %NULL if the attribute contains empty or invalid
data. The returned data must not be modified and is only valid
as long as this @attribute.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value data or %NULL</doc>
          <array length="0" zero-terminated="0" c:type="const guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">an attribute</doc>
            <type name="Attribute" c:type="const GckAttribute*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the length of the returned data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date" c:identifier="gck_attribute_get_date">
        <doc xml:space="preserve">Get the CK_DATE of a PKCS#11 attribute. No
conversion is performed. It is an error to pass an attribute
to this function unless you're know it's supposed to contain
a value of the right type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">The attribute to retrieve value from.</doc>
            <type name="Attribute" c:type="const GckAttribute*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The date value to fill in with the parsed date.</doc>
            <type name="GLib.Date" c:type="GDate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="gck_attribute_get_string">
        <doc xml:space="preserve">Get the string value of a PKCS#11 attribute. No
conversion is performed. It is an error to pass an attribute
to this function unless you're know it's supposed to contain
a value of the right type.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a null terminated string, to be freed with
              g_free(), or %NULL if the value was invalid</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">The attribute to retrieve value from.</doc>
            <type name="Attribute" c:type="const GckAttribute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ulong" c:identifier="gck_attribute_get_ulong">
        <doc xml:space="preserve">Get the CK_ULONG value of a PKCS#11 attribute. No
conversion is performed. It is an error to pass an attribute
to this function unless you're know it's supposed to contain
a value of the right type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The ulong value of the attribute.</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">The attribute to retrieve value from.</doc>
            <type name="Attribute" c:type="const GckAttribute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="gck_attribute_hash">
        <doc xml:space="preserve">Hash an attribute for use in &lt;code&gt;GHashTable&lt;/code&gt; keys.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hash code</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">attribute to hash</doc>
            <type name="Attribute" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gck_attribute_init" introspectable="0">
        <doc xml:space="preserve">Initialize a PKCS#11 attribute. This copies the value memory
into an internal buffer.

When done with the attribute you should use [method@Attribute.clear]
to free the internal memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized attribute</doc>
            <type name="Attribute" c:type="GckAttribute*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The raw value of the attribute.</doc>
            <array length="2" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">The length of the raw value.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_boolean" c:identifier="gck_attribute_init_boolean" introspectable="0">
        <doc xml:space="preserve">Initialize a PKCS#11 attribute to boolean. This will result
in a CK_BBOOL attribute from the PKCS#11 specs.

When done with the attribute you should use [method@Attribute.clear]
to free the internal memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized attribute</doc>
            <type name="Attribute" c:type="GckAttribute*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the boolean value of the attribute</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_copy" c:identifier="gck_attribute_init_copy">
        <doc xml:space="preserve">Initialize a PKCS#11 attribute as a copy of another attribute.
This copies the value memory as well.

When done with the copied attribute you should use
[method@Attribute.clear] to free the internal memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">An uninitialized attribute.</doc>
            <type name="Attribute" c:type="GckAttribute*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">An attribute to copy.</doc>
            <type name="Attribute" c:type="const GckAttribute*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_date" c:identifier="gck_attribute_init_date" introspectable="0">
        <doc xml:space="preserve">Initialize a PKCS#11 attribute to a date. This will result
in a CK_DATE attribute from the PKCS#11 specs.

When done with the attribute you should use [method@Attribute.clear]
to free the internal memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized attribute</doc>
            <type name="Attribute" c:type="GckAttribute*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the date value of the attribute</doc>
            <type name="GLib.Date" c:type="const GDate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_empty" c:identifier="gck_attribute_init_empty" introspectable="0">
        <doc xml:space="preserve">Initialize a PKCS#11 attribute to an empty state. The attribute
type will be set, but no data will be set.

When done with the attribute you should use [method@Attribute.clear]
to free the internal memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized attribute</doc>
            <type name="Attribute" c:type="GckAttribute*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_invalid" c:identifier="gck_attribute_init_invalid" introspectable="0">
        <doc xml:space="preserve">Initialize a PKCS#11 attribute to an 'invalid' or 'not found'
state. Specifically this sets the value length to (CK_ULONG)-1
as specified in the PKCS#11 specification.

When done with the attribute you should use [method@Attribute.clear]
to free the internal memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized attribute</doc>
            <type name="Attribute" c:type="GckAttribute*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_string" c:identifier="gck_attribute_init_string" introspectable="0">
        <doc xml:space="preserve">Initialize a PKCS#11 attribute to a string. This will result
in an attribute containing the text, but not the null terminator.
The text in the attribute will be of the same encoding as you pass
to this function.

When done with the attribute you should use [method@Attribute.clear]
to free the internal memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized attribute</doc>
            <type name="Attribute" c:type="GckAttribute*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the null terminated string value of the attribute</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_ulong" c:identifier="gck_attribute_init_ulong" introspectable="0">
        <doc xml:space="preserve">Initialize a PKCS#11 attribute to a unsigned long. This will result
in a CK_ULONG attribute from the PKCS#11 specs.

When done with the attribute you should use [method@Attribute.clear]
to free the internal memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized attribute</doc>
            <type name="Attribute" c:type="GckAttribute*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the PKCS#11 attribute type to set on the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the ulong value of the attribute</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_invalid" c:identifier="gck_attribute_is_invalid">
        <doc xml:space="preserve">Check if the PKCS#11 attribute represents 'invalid' or 'not found'
according to the PKCS#11 spec. That is, having length
of (CK_ULONG)-1.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the attribute represents invalid or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">The attribute to check.</doc>
            <type name="Attribute" c:type="const GckAttribute*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="Attributes" c:type="GckAttributes" glib:type-name="GckAttributes" glib:get-type="gck_attributes_get_type" c:symbol-prefix="attributes">
      <doc xml:space="preserve">A set of [struct@Attribute] structures.

These attributes contain information about a PKCS11 object. Use
[method@Object.get] or [method@Object.set] to set and retrieve attributes on
an object.</doc>
      <constructor name="new" c:identifier="gck_attributes_new">
        <doc xml:space="preserve">Create a new empty `GckAttributes` array.

The returned set of attributes is floating, and should either be passed to
another gck library function which consumes this floating reference, or if
you wish to keep these attributes around you should ref them with
gck_attributes_ref_sink() and unref them later with gck_attributes_unref().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to the new attributes array;
         when done with the array release it with gck_attributes_unref().</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <parameter name="reserved" transfer-ownership="none">
            <doc xml:space="preserve">Should be set to always be [const@INVALID]</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_empty" c:identifier="gck_attributes_new_empty" introspectable="0">
        <doc xml:space="preserve">Creates an GckAttributes array with empty attributes

Terminate the argument list with [const@INVALID].

The returned set of attributes is floating, and should either be passed to
another gck library function which consumes this floating reference, or if
you wish to keep these attributes around you should ref them with
gck_attributes_ref_sink() and unref them later with gck_attributes_unref().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to an empty set of attributes</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <parameter name="first_type" transfer-ownership="none">
            <doc xml:space="preserve">the first empty attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the other empty attribute types</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <method name="at" c:identifier="gck_attributes_at">
        <doc xml:space="preserve">Get attribute at the specified index in the attribute array.

Use [method@Attributes.count] to determine how many attributes are
in the array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the specified attribute</doc>
          <type name="Attribute" c:type="const GckAttribute*"/>
        </return-value>
        <parameters>
          <instance-parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attributes array.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">The attribute index to retrieve.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains" c:identifier="gck_attributes_contains">
        <doc xml:space="preserve">Check whether the attributes contain a certain attribute.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the attributes contain the attribute.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attributes to check</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </instance-parameter>
          <parameter name="match" transfer-ownership="none">
            <doc xml:space="preserve">The attribute to find</doc>
            <type name="Attribute" c:type="const GckAttribute*"/>
          </parameter>
        </parameters>
      </method>
      <method name="count" c:identifier="gck_attributes_count">
        <doc xml:space="preserve">Get the number of attributes in this attribute array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of contained attributes.</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attributes array to count.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="gck_attributes_dump">
        <doc xml:space="preserve">Dump the attributes using g_printerr().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attributes</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="find" c:identifier="gck_attributes_find">
        <doc xml:space="preserve">Find an attribute with the specified type in the array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the first attribute found with the specified type,
         or %NULL</doc>
          <type name="Attribute" c:type="const GckAttribute*"/>
        </return-value>
        <parameters>
          <instance-parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attributes array to search.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">The type of attribute to find.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_boolean" c:identifier="gck_attributes_find_boolean">
        <doc xml:space="preserve">Find an attribute with the specified type in the array.

The attribute (if found) must be of the right size to store
a boolean value (ie: CK_BBOOL). If the attribute is marked invalid
then it will be treated as not found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether a value was found or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attributes array to search.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">The type of attribute to find.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The resulting gboolean value.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_date" c:identifier="gck_attributes_find_date">
        <doc xml:space="preserve">Find an attribute with the specified type in the array.

The attribute (if found) must be of the right size to store
a date value (ie: CK_DATE). If the attribute is marked invalid
then it will be treated as not found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether a value was found or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attributes array to search.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">The type of attribute to find.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">The resulting GDate value.</doc>
            <type name="GLib.Date" c:type="GDate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_string" c:identifier="gck_attributes_find_string">
        <doc xml:space="preserve">Find an attribute with the specified type in the array.

If the attribute is marked invalid then it will be treated as not found.
The resulting string will be null-terminated, and must be freed by the caller
using g_free().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether a value was found or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attributes array to search.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">The type of attribute to find.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The resulting string value.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_ulong" c:identifier="gck_attributes_find_ulong">
        <doc xml:space="preserve">Find an attribute with the specified type in the array.

The attribute (if found) must be of the right size to store
a unsigned long value (ie: CK_ULONG). If the attribute is marked invalid
then it will be treated as not found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether a value was found or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attributes array to search.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">The type of attribute to find.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The resulting gulong value.</doc>
            <type name="gulong" c:type="gulong*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gck_attributes_ref">
        <doc xml:space="preserve">Reference this attributes array.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the attributes</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">An attribute array</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref_sink" c:identifier="gck_attributes_ref_sink">
        <doc xml:space="preserve">#GckAttributes uses a floating reference count system. [method@Builder.end]
and [ctor@Attributes.new_empty] both return floating references.

Calling this function on a `GckAttributes` with a floating
reference will convert the floating reference into a full reference.
Calling this function on a non-floating `GckAttributes` results
in an additional normal reference being added.

In other words, if the @attrs is floating, then this call "assumes
ownership" of the floating reference, converting it to a normal
reference.  If the @attrs is not floating, then this call adds a
new normal reference increasing the reference count by one.

All Gck library functions that assume ownership of floating references
are documented as such. Essentially any Gck function that performs
an operation using a #GckAttributes argument rather than operating on the
attributes themselves, will accept a floating reference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the referenced attributes</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">an attribute array</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gck_attributes_to_string">
        <doc xml:space="preserve">Print out attributes to a string in aform that's useful for debugging
or logging.

The format of the string returned may change in the future.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">the attributes</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gck_attributes_unref">
        <doc xml:space="preserve">Unreference this attribute array.

When all outstanding references are gone, the array will be freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attrs" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">An attribute array</doc>
            <type name="Attributes" c:type="gpointer"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="Builder" c:type="GckBuilder" glib:type-name="GckBuilder" glib:get-type="gck_builder_get_type" c:symbol-prefix="builder">
      <doc xml:space="preserve">A builder for a set of attributes. Add attributes to a builder, and then use
[method@Builder.end] to get the completed [struct@Attributes].

The fields of #GckBuilder are private and not to be accessed directly.</doc>
      <field name="x" readable="0" private="1">
        <array zero-terminated="0" fixed-size="16">
          <type name="gsize" c:type="gsize"/>
        </array>
      </field>
      <constructor name="new" c:identifier="gck_builder_new">
        <doc xml:space="preserve">Create a new `GckBuilder` not allocated on the stack, so it can be shared
across a single scope, and referenced / unreferenced.

Normally a `GckBuilder` is created on the stack, and simply initialized.

If the %GCK_BUILDER_SECURE_MEMORY flag is specified then non-pageable memory
will be used for the various values of the attributes in the builder</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new builder, to be freed with gck_builder_unref()</doc>
          <type name="Builder" c:type="GckBuilder*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags for the new builder</doc>
            <type name="BuilderFlags" c:type="GckBuilderFlags"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_all" c:identifier="gck_builder_add_all">
        <doc xml:space="preserve">Add all the @attrs attributes to the builder. The attributes are added
uncondititionally whether or not attributes with the same types already
exist in the builder.

As an optimization, the attribute memory values are automatically shared
between the attributes and the builder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">the attributes to add</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_attribute" c:identifier="gck_builder_add_attribute">
        <doc xml:space="preserve">Add an attribute to the builder. The attribute is added unconditionally whether
or not an attribute with the same type already exists on the builder.

The @attr attribute must have been created or owned by the Gck library.
If you call this function on an arbitrary `GckAttribute` that is allocated on
the stack or elsewhere, then this will result in undefined behavior.

As an optimization, the attribute memory value is automatically shared
between the attribute and the builder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr" transfer-ownership="none">
            <doc xml:space="preserve">the attribute to add</doc>
            <type name="Attribute" c:type="const GckAttribute*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_boolean" c:identifier="gck_builder_add_boolean">
        <doc xml:space="preserve">Add a new attribute to the builder for the boolean @value.
Unconditionally adds a new attribute, even if one with the same @attr_type
already exists.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the new attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the attribute value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_data" c:identifier="gck_builder_add_data">
        <doc xml:space="preserve">Add a new attribute to the builder with an arbitrary value. Unconditionally
adds a new attribute, even if one with the same @attr_type already exists.

The memory in @value is copied by the builder.

%NULL may be specified for the @value argument, in which case an empty
attribute is created. [const@INVALID] may be specified for the length, in
which case an invalid attribute is created in the PKCS#11 style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the new attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the new attribute memory</doc>
            <array length="2" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of the memory</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_date" c:identifier="gck_builder_add_date">
        <doc xml:space="preserve">Add a new attribute to the builder for the date @value.
Unconditionally adds a new attribute, even if one with the same @attr_type
already exists.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the new attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the attribute value</doc>
            <type name="GLib.Date" c:type="const GDate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_empty" c:identifier="gck_builder_add_empty">
        <doc xml:space="preserve">Add a new attribute to the builder that is empty. Unconditionally
adds a new attribute, even if one with the same @attr_type already exists.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the new attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_except" c:identifier="gck_builder_add_except" introspectable="0">
        <doc xml:space="preserve">Add the attributes in @attrs to the builder, with the exception of those
in the argument list. The attributes are added uncondititionally whether or
not attributes with the same types already exist in the builder.

The variable arguments must be unsigned longs.

```c
// Add all attributes in attrs except CKA_CLASS to the builder
gck_builder_add_except (builder, attrs, CKA_CLASS, GCK_INVALID);
```

As an optimization, the attribute memory values are automatically shared
between the attributes and the builder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">the attributes to add</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="except_type" transfer-ownership="none">
            <doc xml:space="preserve">the first type of attribute to to exclude</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the remaining attribute types to exclude, ending with [const@INVALID]</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_exceptv" c:identifier="gck_builder_add_exceptv" introspectable="0">
        <doc xml:space="preserve">Add the attributes in @attrs to the builder, with the exception of those
whose types are specified in @except_types. The attributes are added
uncondititionally whether or not attributes with the same types already
exist in the builder.

```c
// Add all attributes in attrs except CKA_CLASS to the builder
unsigned long except_types[] = { CKA_CLASS };
gck_builder_add_exceptv (builder, attrs, except_types, 1);
```

As an optimization, the attribute memory values are automatically shared
between the attributes and the builder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">the attributes to add</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="except_types" transfer-ownership="none">
            <doc xml:space="preserve">the except types</doc>
            <array length="2" zero-terminated="0" c:type="const gulong*">
              <type name="gulong" c:type="gulong"/>
            </array>
          </parameter>
          <parameter name="n_except_types" transfer-ownership="none">
            <doc xml:space="preserve">the number of except types</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_invalid" c:identifier="gck_builder_add_invalid">
        <doc xml:space="preserve">Add a new attribute to the builder that is invalid in the PKCS#11 sense.
Unconditionally adds a new attribute, even if one with the same @attr_type
already exists.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the new attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_only" c:identifier="gck_builder_add_only" shadowed-by="add_onlyv" introspectable="0">
        <doc xml:space="preserve">Add the attributes specified in the argument list from @attrs to the
builder. The attributes are added uncondititionally whether or not
attributes with the same types already exist in the builder.

The variable arguments must be unsigned longs.

```c
// Add the CKA_ID and CKA_CLASS attributes from attrs to builder
gck_builder_add_only (builder, attrs, CKA_ID, CKA_CLASS, GCK_INVALID);
```

As an optimization, the attribute memory values are automatically shared
between the attributes and the builder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">the attributes to add</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="only_type" transfer-ownership="none">
            <doc xml:space="preserve">the first type of attribute to add</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the remaining attribute types to add, ending with [const@INVALID]</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_onlyv" c:identifier="gck_builder_add_onlyv" shadows="add_only">
        <doc xml:space="preserve">Add the attributes with the types in @only_types from @attrs to the
builder. The attributes are added uncondititionally whether or not
attributes with the same types already exist in the builder.

```c
// Add the CKA_ID and CKA_CLASS attributes from attrs to builder
gulong only[] = { CKA_ID, CKA_CLASS };
gck_builder_add_onlyv (builder, attrs, only, 2);
```

As an optimization, the attribute memory values are automatically shared
between the attributes and the builder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">the attributes to add</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="only_types" transfer-ownership="none">
            <doc xml:space="preserve">the types of attributes to add</doc>
            <array length="2" zero-terminated="0" c:type="const gulong*">
              <type name="gulong" c:type="gulong"/>
            </array>
          </parameter>
          <parameter name="n_only_types" transfer-ownership="none">
            <doc xml:space="preserve">the number of attributes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_string" c:identifier="gck_builder_add_string">
        <doc xml:space="preserve">Add a new attribute to the builder for the string @value or %NULL.
Unconditionally adds a new attribute, even if one with the same @attr_type
already exists.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the new attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the attribute value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_ulong" c:identifier="gck_builder_add_ulong">
        <doc xml:space="preserve">Add a new attribute to the builder for the unsigned long @value.
Unconditionally adds a new attribute, even if one with the same @attr_type
already exists.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the new attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the attribute value</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="gck_builder_clear">
        <doc xml:space="preserve">Clear the builder and release all allocated memory. The builder may be used
again to build another set of attributes after this function call.

If memory is shared between this builder and other attributes, then that
memory is only freed when both of them are cleared or unreferenced.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gck_builder_copy">
        <doc xml:space="preserve">Make a copy of the builder and its state. The new builder is allocated
with [ctor@Builder.new] and should be freed with gck_builder_unref().

Attribute value memory is automatically shared between the two builders,
and is only freed when both are gone.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the builder copy, which should be freed with
         gck_builder_unref().</doc>
          <type name="Builder" c:type="GckBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder to copy</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="end" c:identifier="gck_builder_end">
        <doc xml:space="preserve">Complete the #GckBuilder, and return the attributes contained in the builder.
The #GckBuilder will be cleared after this function call, and it is no
longer necessary to use [method@Builder.clear] on it, although it is also
permitted. The builder may be used again to build another set of attributes
after this function call.

The returned set of attributes is floating, and should either be passed to
another gck library function which consumes this floating reference, or if
you wish to keep these attributes around you should ref them with
gck_attributes_ref_sink() and unref them later with gck_attributes_unref().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to the attributes created
         in the builder</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="find" c:identifier="gck_builder_find">
        <doc xml:space="preserve">Find an attribute in the builder. Both valid and invalid attributes (in
the PKCS#11 sense) are returned. If multiple attributes exist for the given
attribute type, then the first one is returned.

The returned [struct@Attribute] is owned by the builder and may not be
modified in any way. It is only valid until another attribute is added to or
set on the builder, or until the builder is cleared or unreferenced.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the attribute or %NULL if not found</doc>
          <type name="Attribute" c:type="const GckAttribute*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of attribute to find</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_boolean" c:identifier="gck_builder_find_boolean">
        <doc xml:space="preserve">Find a boolean attribute in the builder that has the type @attr_type, is
of the correct boolean size, and is not invalid in the PKCS#11 sense.
If multiple attributes exist for the given attribute type, then the first\
one is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether a valid boolean attribute was found</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of attribute to find</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the location to place the found value</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_date" c:identifier="gck_builder_find_date">
        <doc xml:space="preserve">Find a date attribute in the builder that has the type @attr_type, is of
the correct date size, and is not invalid in the PKCS#11 sense.
If multiple attributes exist for the given attribute type, then the first
one is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether a valid date attribute was found</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of attribute to find</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the location to place the found value</doc>
            <type name="GLib.Date" c:type="GDate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_string" c:identifier="gck_builder_find_string">
        <doc xml:space="preserve">Find a string attribute in the builder that has the type @attr_type, has a
non %NULL value pointer, and is not invalid in the PKCS#11 sense.
If multiple attributes exist for the given attribute type, then the first
one is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether a valid string attribute was found</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of attribute to find</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the location to place the found value</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_ulong" c:identifier="gck_builder_find_ulong">
        <doc xml:space="preserve">Find a unsigned long attribute in the builder that has the type @attr_type,
is of the correct unsigned long size, and is not invalid in the PKCS#11 sense.
If multiple attributes exist for the given attribute type, then the first
one is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether a valid unsigned long attribute was found</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of attribute to find</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the location to place the found value</doc>
            <type name="gulong" c:type="gulong*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gck_builder_init">
        <doc xml:space="preserve">Initialize a stack allocated builder, with the default flags.

This is equivalent to initializing a builder variable with the
%GCK_BUILDER_INIT constant, or setting it to zeroed memory.

```c
// Equivalent ways of initializing a GckBuilder
GckBuilder builder = GCK_BUILDER_INIT;
GckBuilder builder2;
GckBuilder builder3;

gck_builder_init (&amp;builder2);

memset (&amp;builder3, 0, sizeof (builder3));
```</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_full" c:identifier="gck_builder_init_full">
        <doc xml:space="preserve">Initialize a stack allocated builder, with the appropriate flags.

If the %GCK_BUILDER_SECURE_MEMORY flag is specified then non-pageable memory
will be used for the various values of the attributes in the builder</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the flags for the new builder</doc>
            <type name="BuilderFlags" c:type="GckBuilderFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gck_builder_ref">
        <doc xml:space="preserve">Add a reference to a builder that was created with [ctor@Builder.new]. The
builder must later be unreferenced again with gck_builder_unref().

It is an error to use this function on builders that were allocated on the
stack.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the builder</doc>
          <type name="Builder" c:type="GckBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_all" c:identifier="gck_builder_set_all">
        <doc xml:space="preserve">Set all the @attrs attributes to the builder. If any attributes with the
same types are already present in the builder, then those attributes are
changed to the new values.

As an optimization, the attribute memory values are automatically shared
between the attributes and the builder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">the attributes to set</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_boolean" c:identifier="gck_builder_set_boolean">
        <doc xml:space="preserve">Set an attribute on the builder for the boolean @value.
If an attribute with @attr_type already exists in the builder then it is
changed to the new value, otherwise an attribute is added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the new attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the attribute value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data" c:identifier="gck_builder_set_data">
        <doc xml:space="preserve">Set a new attribute to the builder with an arbitrary value. If an attribute
with @attr_type already exists in the builder then it is changed to the new
value, otherwise an attribute is added.

The memory in @value is copied by the builder.

%NULL may be specified for the @value argument, in which case an empty
attribute is created. [const@INVALID] may be specified for the length, in
which case an invalid attribute is created in the PKCS#11 style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the new attribute memory</doc>
            <array length="2" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of the memory</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_date" c:identifier="gck_builder_set_date">
        <doc xml:space="preserve">Set an attribute on the builder for the date @value.
If an attribute with @attr_type already exists in the builder then it is
changed to the new value, otherwise an attribute is added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the new attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the attribute value</doc>
            <type name="GLib.Date" c:type="const GDate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_empty" c:identifier="gck_builder_set_empty">
        <doc xml:space="preserve">Set an attribute on the builder that is empty. If an attribute
with @attr_type already exists in the builder then it is changed to the new
value, otherwise an attribute is added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_invalid" c:identifier="gck_builder_set_invalid">
        <doc xml:space="preserve">Set an attribute on the builder that is invalid in the PKCS#11 sense.
If an attribute with @attr_type already exists in the builder then it is
changed to the new value, otherwise an attribute is added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string" c:identifier="gck_builder_set_string">
        <doc xml:space="preserve">Set an attribute on the builder for the string @value or %NULL.
If an attribute with @attr_type already exists in the builder then it is
changed to the new value, otherwise an attribute is added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the new attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the attribute value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ulong" c:identifier="gck_builder_set_ulong">
        <doc xml:space="preserve">Set an attribute on the builder for the unsigned long @value.
If an attribute with @attr_type already exists in the builder then it is
changed to the new value, otherwise an attribute is added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the new attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the attribute value</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal" c:identifier="gck_builder_steal">
        <doc xml:space="preserve">Take the attributes that have been built in the #GckBuilder. The builder
will no longer contain any attributes after this function call.

The returned set of attributes is a full reference, not floating.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the stolen attributes, which should be freed with
         gck_attributes_unref()</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="take_data" c:identifier="gck_builder_take_data">
        <doc xml:space="preserve">Add a new attribute to the builder with an arbitrary value. Unconditionally
adds a new attribute, even if one with the same @attr_type already exists.

Ownership of the @value memory is taken by the builder, may be reallocated,
and is eventually freed with g_free(). The memory must have been allocated
using the standard GLib memory allocation routines.

%NULL may be specified for the @value argument, in which case an empty
attribute is created. [const@INVALID] may be specified for the length, in
which case an invalid attribute is created in the PKCS#11 style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">the builder</doc>
            <type name="Builder" c:type="GckBuilder*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">the new attribute type</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the new
        attribute memory</doc>
            <array length="2" zero-terminated="0" c:type="guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of the memory</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <function name="unref" c:identifier="gck_builder_unref">
        <doc xml:space="preserve">Unreferences a builder. If this was the last reference then the builder
is freed.

It is an error to use this function on builders that were allocated on the
stack.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="builder" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the builder</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="BuilderFlags" glib:type-name="GckBuilderFlags" glib:get-type="gck_builder_flags_get_type" c:type="GckBuilderFlags">
      <doc xml:space="preserve">Flags to be used with a [method@Builder.init_full] and [ctor@Builder.new].</doc>
      <member name="none" value="0" c:identifier="GCK_BUILDER_NONE" glib:nick="none" glib:name="GCK_BUILDER_NONE">
        <doc xml:space="preserve">no special flags</doc>
      </member>
      <member name="secure_memory" value="1" c:identifier="GCK_BUILDER_SECURE_MEMORY" glib:nick="secure-memory" glib:name="GCK_BUILDER_SECURE_MEMORY">
        <doc xml:space="preserve">use non-pageable memory for the values of the attributes</doc>
      </member>
    </enumeration>
    <function-macro name="CHECK_VERSION" c:identifier="GCK_CHECK_VERSION" introspectable="0">
      <doc xml:space="preserve">Checks the version of the Gck library that is being compiled
against.

```
#if !GCK_CHECK_VERSION (3, 0, 0)
#warning Old Gck version, disabling functionality
#endif
```</doc>
      <parameters>
        <parameter name="major">
          <doc xml:space="preserve">the major version to check for</doc>
        </parameter>
        <parameter name="minor">
          <doc xml:space="preserve">the minor version to check for</doc>
        </parameter>
        <parameter name="micro">
          <doc xml:space="preserve">the micro version to check for</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ENUMERATOR" c:identifier="GCK_ENUMERATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ENUMERATOR_CLASS" c:identifier="GCK_ENUMERATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ENUMERATOR_GET_CLASS" c:identifier="GCK_ENUMERATOR_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Enumerator" c:symbol-prefix="enumerator" c:type="GckEnumerator" parent="GObject.Object" glib:type-name="GckEnumerator" glib:get-type="gck_enumerator_get_type" glib:type-struct="EnumeratorClass">
      <doc xml:space="preserve">Can be used to enumerate through PKCS#11 objects. It will automatically
create sessions as necessary.

Use [func@modules_enumerate_objects] or [func@modules_enumerate_uri] to
create an enumerator. To get the objects, use [method@Enumerator.next] or
[method@Enumerator.next_async] functions.</doc>
      <method name="get_chained" c:identifier="gck_enumerator_get_chained" glib:get-property="chained">
        <doc xml:space="preserve">Get the enumerator that will be run after all objects from this one
are seen.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the chained enumerator or %NULL</doc>
          <type name="Enumerator" c:type="GckEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the enumerator</doc>
            <type name="Enumerator" c:type="GckEnumerator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interaction" c:identifier="gck_enumerator_get_interaction" glib:get-property="interaction">
        <doc xml:space="preserve">Get the interaction used when a pin is needed</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the interaction or %NULL</doc>
          <type name="Gio.TlsInteraction" c:type="GTlsInteraction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the enumerator</doc>
            <type name="Enumerator" c:type="GckEnumerator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_object_type" c:identifier="gck_enumerator_get_object_type" glib:get-property="object-type">
        <doc xml:space="preserve">Get the type of objects created by this enumerator. The type will always
either be #GckObject or derived from it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of objects created</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an enumerator</doc>
            <type name="Enumerator" c:type="GckEnumerator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="gck_enumerator_next" throws="1">
        <doc xml:space="preserve">Get the next object in the enumerator, or %NULL if there are no more objects.

%NULL is also returned if the function fails. Use the @error to determine
whether a failure occurred or not.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The next object, which must be released
using g_object_unref, or %NULL.</doc>
          <type name="Object" c:type="GckObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The enumerator</doc>
            <type name="Enumerator" c:type="GckEnumerator*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_async" c:identifier="gck_enumerator_next_async">
        <doc xml:space="preserve">Get the next set of objects from the enumerator. This operation completes
asynchronously.The maximum number of objects can be specified with
@max_objects. If -1 is specified, then all the remaining objects will be
enumerated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">An enumerator</doc>
            <type name="Enumerator" c:type="GckEnumerator*"/>
          </instance-parameter>
          <parameter name="max_objects" transfer-ownership="none">
            <doc xml:space="preserve">The maximum number of objects to get</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">Called when the result is ready</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_finish" c:identifier="gck_enumerator_next_finish" throws="1">
        <doc xml:space="preserve">Complete an operation to enumerate next objects.

%NULL is also returned if the function fails. Use the @error to determine
whether a failure occurred or not.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The list of objects, which
should be freed with gck_list_unref_free()</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Object"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">An enumerator</doc>
            <type name="Enumerator" c:type="GckEnumerator*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_n" c:identifier="gck_enumerator_next_n" throws="1">
        <doc xml:space="preserve">Get the next set of objects from the enumerator. The maximum number of
objects can be specified with @max_objects. If -1 is specified, then all
the remaining objects will be returned.

%NULL is also returned if the function fails. Use the @error to determine
whether a failure occurred or not.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A list of objects, which
should be freed using gck_list_unref_free().</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Object"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">An enumerator</doc>
            <type name="Enumerator" c:type="GckEnumerator*"/>
          </instance-parameter>
          <parameter name="max_objects" transfer-ownership="none">
            <doc xml:space="preserve">The maximum amount of objects to enumerate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_chained" c:identifier="gck_enumerator_set_chained" glib:set-property="chained">
        <doc xml:space="preserve">Set a chained enumerator that will be run after all objects from this one
are seen.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the enumerator</doc>
            <type name="Enumerator" c:type="GckEnumerator*"/>
          </instance-parameter>
          <parameter name="chained" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the chained enumerator or %NULL</doc>
            <type name="Enumerator" c:type="GckEnumerator*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_interaction" c:identifier="gck_enumerator_set_interaction" glib:set-property="interaction">
        <doc xml:space="preserve">Set the interaction used when a pin is needed</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the enumerator</doc>
            <type name="Enumerator" c:type="GckEnumerator*"/>
          </instance-parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the interaction or %NULL</doc>
            <type name="Gio.TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_object_type" c:identifier="gck_enumerator_set_object_type" shadowed-by="set_object_type_full" glib:set-property="object-type" introspectable="0">
        <doc xml:space="preserve">Set the type of objects to be created by this enumerator. The type must
always be either #GckObject or derived from it.

If the #GckObjectCache interface is implemented on the derived class
and the default_types class field is set, then the enumerator will retrieve
attributes for each object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an enumerator</doc>
            <type name="Enumerator" c:type="GckEnumerator*"/>
          </instance-parameter>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of objects to create</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_object_type_full" c:identifier="gck_enumerator_set_object_type_full" shadows="set_object_type">
        <doc xml:space="preserve">Set the type of objects to be created by this enumerator. The type must
always be either #GckObject or derived from it.

If @attr_types and @attr_count are non-NULL and non-zero respectively,
then the #GckObjectCache interface is expected to be implemented on the
derived class, then the enumerator will retrieve attributes for each object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">an enumerator</doc>
            <type name="Enumerator" c:type="GckEnumerator*"/>
          </instance-parameter>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of objects to create</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="attr_types" transfer-ownership="none">
            <doc xml:space="preserve">types of attributes to retrieve for objects</doc>
            <array length="2" zero-terminated="0" c:type="const gulong*">
              <type name="gulong" c:type="gulong"/>
            </array>
          </parameter>
          <parameter name="attr_count" transfer-ownership="none">
            <doc xml:space="preserve">the number of attributes to retrieve</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <property name="chained" writable="1" transfer-ownership="none" setter="set_chained" getter="get_chained">
        <doc xml:space="preserve">Chained enumerator, which will be enumerated when this enumerator
has enumerated all its objects.</doc>
        <type name="Enumerator"/>
      </property>
      <property name="interaction" writable="1" transfer-ownership="none" setter="set_interaction" getter="get_interaction">
        <doc xml:space="preserve">Interaction object used to ask the user for pins when opening
sessions. Used if the session_options of the enumerator have
%GCK_SESSION_LOGIN_USER</doc>
        <type name="Gio.TlsInteraction"/>
      </property>
      <property name="object-type" introspectable="0" writable="1" transfer-ownership="none" setter="set_object_type" getter="get_object_type">
        <doc xml:space="preserve">The type of objects that are created by the enumerator. Must be
GckObject or derived from it.</doc>
        <type name="GType" c:type="GType"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="EnumeratorPrivate" c:type="GckEnumeratorPrivate*"/>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="EnumeratorClass" c:type="GckEnumeratorClass" glib:is-gtype-struct-for="Enumerator">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="EnumeratorPrivate" c:type="GckEnumeratorPrivate" disguised="1"/>
    <enumeration name="Error" glib:type-name="GckError" glib:get-type="gck_error_get_type" c:type="GckError">
      <doc xml:space="preserve">Various error codes. All the `CKR_XXX` error codes from PKCS#11 are also
relevant error codes.

Note that errors are returned as [struct@GLib.Error] structures. The `code`
member of the error then contains the raw PKCS#11 `CK_RV` result value.</doc>
      <member name="problem" value="-951891199" c:identifier="GCK_ERROR_MODULE_PROBLEM" glib:nick="problem" glib:name="GCK_ERROR_MODULE_PROBLEM">
        <doc xml:space="preserve">a result code that signifies there was a problem
                           loading a PKCS#11 module, usually a shared library</doc>
      </member>
      <function name="get_quark" c:identifier="gck_error_get_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <constant name="INVALID" value="-1" c:type="GCK_INVALID">
      <doc xml:space="preserve">Used as a terminator at the end of variable argument lists.</doc>
      <type name="gulong" c:type="gulong"/>
    </constant>
    <function-macro name="IS_ENUMERATOR" c:identifier="GCK_IS_ENUMERATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_ENUMERATOR_CLASS" c:identifier="GCK_IS_ENUMERATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_MODULE" c:identifier="GCK_IS_MODULE" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_MODULE_CLASS" c:identifier="GCK_IS_MODULE_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_OBJECT" c:identifier="GCK_IS_OBJECT" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_OBJECT_CACHE" c:identifier="GCK_IS_OBJECT_CACHE" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_OBJECT_CLASS" c:identifier="GCK_IS_OBJECT_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PASSWORD" c:identifier="GCK_IS_PASSWORD" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PASSWORD_CLASS" c:identifier="GCK_IS_PASSWORD_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SESSION" c:identifier="GCK_IS_SESSION" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SESSION_CLASS" c:identifier="GCK_IS_SESSION_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SLOT" c:identifier="GCK_IS_SLOT" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SLOT_CLASS" c:identifier="GCK_IS_SLOT_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="MAJOR_VERSION" value="1" c:type="GCK_MAJOR_VERSION">
      <doc xml:space="preserve">The major version number of the Gck library.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MICRO_VERSION" value="0" c:type="GCK_MICRO_VERSION">
      <doc xml:space="preserve">The micro version number of the Gck library.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MINOR_VERSION" value="0" c:type="GCK_MINOR_VERSION">
      <doc xml:space="preserve">The minor version number of the Gck library.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="MODULE" c:identifier="GCK_MODULE" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="MODULE_CLASS" c:identifier="GCK_MODULE_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="MODULE_GET_CLASS" c:identifier="GCK_MODULE_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <record name="Mechanism" c:type="GckMechanism">
      <doc xml:space="preserve">Represents a mechanism used with crypto operations.</doc>
      <field name="type" writable="1">
        <doc xml:space="preserve">The mechanism type</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="parameter" writable="1">
        <doc xml:space="preserve">Mechanism specific data.</doc>
        <type name="gpointer" c:type="gconstpointer"/>
      </field>
      <field name="n_parameter" writable="1">
        <doc xml:space="preserve">Length of mechanism specific data.</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
    </record>
    <record name="MechanismInfo" c:type="GckMechanismInfo" glib:type-name="GckMechanismInfo" glib:get-type="gck_mechanism_info_get_type" c:symbol-prefix="mechanism_info">
      <doc xml:space="preserve">Represents information about a PKCS11 mechanism.

This is analogous to a CK_MECHANISM_INFO structure.

When you're done with this structure it should be released with
gck_mechanism_info_free().</doc>
      <field name="min_key_size" writable="1">
        <doc xml:space="preserve">The minimum key size that can be used with this mechanism.</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="max_key_size" writable="1">
        <doc xml:space="preserve">The maximum key size that can be used with this mechanism.</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">Various PKCS11 flags that apply to this mechanism.</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <method name="copy" c:identifier="gck_mechanism_info_copy">
        <doc xml:space="preserve">Make a copy of the mechanism info.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated copy mechanism info</doc>
          <type name="MechanismInfo" c:type="GckMechanismInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mech_info" transfer-ownership="none">
            <doc xml:space="preserve">a mechanism info</doc>
            <type name="MechanismInfo" c:type="GckMechanismInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gck_mechanism_info_free">
        <doc xml:space="preserve">Free the GckMechanismInfo and associated resources.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mech_info" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism info to free, or %NULL.</doc>
            <type name="MechanismInfo" c:type="GckMechanismInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="Module" c:symbol-prefix="module" c:type="GckModule" parent="GObject.Object" glib:type-name="GckModule" glib:get-type="gck_module_get_type" glib:type-struct="ModuleClass">
      <doc xml:space="preserve">Holds a loaded PKCS#11 module. A PKCS#11 module is a shared library.

You can load and initialize a PKCS#11 module with the
[func@Module.initialize] call. If you already have a loaded and
initialized module that you'd like to use with the various Gck functions,
then you can use [ctor@Module.new].</doc>
      <constructor name="new" c:identifier="gck_module_new" introspectable="0">
        <doc xml:space="preserve">Create a [class@Module] representing a PKCS#11 module. It is assumed that
this the module is already initialized. In addition it will not be
finalized when complete.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new PKCS#11 module.</doc>
          <type name="Module" c:type="GckModule*"/>
        </return-value>
        <parameters>
          <parameter name="funcs" transfer-ownership="none">
            <doc xml:space="preserve">Initialized PKCS#11 function list pointer</doc>
            <type c:type="CK_FUNCTION_LIST_PTR"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="initialize" c:identifier="gck_module_initialize" throws="1">
        <doc xml:space="preserve">Load and initialize a PKCS#11 module represented by a GckModule object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The loaded PKCS#11 module or %NULL if failed.</doc>
          <type name="Module" c:type="GckModule*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">The file system path to the PKCS#11 module to load.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="initialize_async" c:identifier="gck_module_initialize_async">
        <doc xml:space="preserve">Asynchronously load and initialize a PKCS#11 module represented by a
[class@Module] object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the file system path to the PKCS#11 module to load</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a callback which will be called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="initialize_finish" c:identifier="gck_module_initialize_finish" throws="1">
        <doc xml:space="preserve">Finishes the asynchronous initialize operation.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The initialized module, or %NULL</doc>
          <type name="Module" c:type="GckModule*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the asynchronous result</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="authenticate_object">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Module" c:type="GckModule*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="label" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="authenticate_slot">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Module" c:type="GckModule*"/>
          </instance-parameter>
          <parameter name="slot" transfer-ownership="none">
            <type name="Slot" c:type="GckSlot*"/>
          </parameter>
          <parameter name="label" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="equal" c:identifier="gck_module_equal">
        <doc xml:space="preserve">Checks equality of two modules. Two GckModule objects can point to the same
underlying PKCS#11 module.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if module1 and module2 are equal.
              %FALSE if either is not a GckModule.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="module1" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to the first #GckModule</doc>
            <type name="Module" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="module2" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to the second #GckModule</doc>
            <type name="Module" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_functions" c:identifier="gck_module_get_functions" glib:get-property="functions" introspectable="0">
        <doc xml:space="preserve">Get the PKCS#11 function list for the module.</doc>
        <return-value>
          <doc xml:space="preserve">The function list, do not modify this structure.</doc>
          <type c:type="CK_FUNCTION_LIST_PTR"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The module for which to get the function list.</doc>
            <type name="Module" c:type="GckModule*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_info" c:identifier="gck_module_get_info">
        <doc xml:space="preserve">Get the info about a PKCS#11 module.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the module info; release this with gck_module_info_free()</doc>
          <type name="ModuleInfo" c:type="GckModuleInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The module to get info for.</doc>
            <type name="Module" c:type="GckModule*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="gck_module_get_path" glib:get-property="path">
        <doc xml:space="preserve">Get the file path of this module. This may not be an absolute path, and
usually reflects the path passed to [func@Module.initialize].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The path, do not modify or free this value.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The module for which to get the path.</doc>
            <type name="Module" c:type="GckModule*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slots" c:identifier="gck_module_get_slots">
        <doc xml:space="preserve">Get the GckSlot objects for a given module.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The possibly empty
              list of slots. Release this with gck_list_unref_free().</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Slot"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The module for which to get the slots.</doc>
            <type name="Module" c:type="GckModule*"/>
          </instance-parameter>
          <parameter name="token_present" transfer-ownership="none">
            <doc xml:space="preserve">Whether to limit only to slots with a token present.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="gck_module_hash">
        <doc xml:space="preserve">Create a hash value for the GckModule.

This function is intended for easily hashing a [class@Module] to add to
a [struct@GLib.HashTable] or similar data structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An integer that can be used as a hash value, or 0 if invalid.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #GckModule</doc>
            <type name="Module" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="match" c:identifier="gck_module_match">
        <doc xml:space="preserve">Check whether the PKCS#11 URI matches the module</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the URI matches or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the module to match</doc>
            <type name="Module" c:type="GckModule*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the uri to match against the module</doc>
            <type name="UriData" c:type="GckUriData*"/>
          </parameter>
        </parameters>
      </method>
      <property name="functions" writable="1" construct-only="1" transfer-ownership="none" getter="get_functions">
        <doc xml:space="preserve">The raw PKCS&amp;num;11 function list for the module.

This points to a CK_FUNCTION_LIST structure.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="path" writable="1" construct-only="1" transfer-ownership="none" getter="get_path">
        <doc xml:space="preserve">The PKCS&amp;num;11 module file path.

This may be set to NULL if this object was created from an already
initialized module via the gck_module_new() function.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="ModulePrivate" c:type="GckModulePrivate*"/>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="authenticate-object" when="last" deprecated="1">
        <doc xml:space="preserve">Use gck_session_set_interaction() instead of connecting to this signal.</doc>
        <doc-deprecated xml:space="preserve">Since 3.4</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The object to be authenticated.</doc>
            <type name="Object"/>
          </parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve">A displayable label which describes the object.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A gchar** where a password should be returned.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="authenticate-slot" when="last" deprecated="1">
        <doc xml:space="preserve">Use gck_session_set_interaction() instead of connecting to this signal.</doc>
        <doc-deprecated xml:space="preserve">Since 3.4</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="slot" transfer-ownership="none">
            <doc xml:space="preserve">The slot to be authenticated.</doc>
            <type name="Slot"/>
          </parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">A displayable label which describes the object.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A gchar** where a password should be returned.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ModuleClass" c:type="GckModuleClass" glib:is-gtype-struct-for="Module">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="authenticate_slot">
        <callback name="authenticate_slot">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Module" c:type="GckModule*"/>
            </parameter>
            <parameter name="slot" transfer-ownership="none">
              <type name="Slot" c:type="GckSlot*"/>
            </parameter>
            <parameter name="label" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="password" transfer-ownership="none">
              <type name="utf8" c:type="gchar**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="authenticate_object">
        <callback name="authenticate_object">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Module" c:type="GckModule*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GckObject*"/>
            </parameter>
            <parameter name="label" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="password" transfer-ownership="none">
              <type name="utf8" c:type="gchar**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ModuleInfo" c:type="GckModuleInfo" glib:type-name="GckModuleInfo" glib:get-type="gck_module_info_get_type" c:symbol-prefix="module_info">
      <doc xml:space="preserve">Holds information about the PKCS#11 module.

This structure corresponds to `CK_MODULE_INFO` in the PKCS#11 standard. The
strings are %NULL terminated for easier use.

Use gck_module_info_free() to release this structure when done with it.</doc>
      <field name="pkcs11_version_major" writable="1">
        <doc xml:space="preserve">The major version of the module.</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="pkcs11_version_minor" writable="1">
        <doc xml:space="preserve">The minor version of the module.</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="manufacturer_id" writable="1">
        <doc xml:space="preserve">The module manufacturer.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">The module PKCS&amp;num;11 flags.</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="library_description" writable="1">
        <doc xml:space="preserve">The module description.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="library_version_major" writable="1">
        <doc xml:space="preserve">The major version of the library.</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="library_version_minor" writable="1">
        <doc xml:space="preserve">The minor version of the library.</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <method name="copy" c:identifier="gck_module_info_copy">
        <doc xml:space="preserve">Make a copy of the module info.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated copy module info</doc>
          <type name="ModuleInfo" c:type="GckModuleInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="module_info" transfer-ownership="none">
            <doc xml:space="preserve">a module info</doc>
            <type name="ModuleInfo" c:type="GckModuleInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gck_module_info_free">
        <doc xml:space="preserve">Free a GckModuleInfo structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="module_info" transfer-ownership="none">
            <doc xml:space="preserve">The module info to free, or %NULL.</doc>
            <type name="ModuleInfo" c:type="GckModuleInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="ModulePrivate" c:type="GckModulePrivate" disguised="1"/>
    <function-macro name="OBJECT" c:identifier="GCK_OBJECT" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_CACHE" c:identifier="GCK_OBJECT_CACHE" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_CACHE_GET_INTERFACE" c:identifier="GCK_OBJECT_CACHE_GET_INTERFACE" introspectable="0">
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_CLASS" c:identifier="GCK_OBJECT_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_GET_CLASS" c:identifier="GCK_OBJECT_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Object" c:symbol-prefix="object" c:type="GckObject" parent="GObject.Object" glib:type-name="GckObject" glib:get-type="gck_object_get_type" glib:type-struct="ObjectClass">
      <doc xml:space="preserve">Holds a handle to a PKCS11 object such as a key or certificate. Token
objects are stored on the token persistently. Others are transient and are
called session objects.</doc>
      <constructor name="from_handle" c:identifier="gck_object_from_handle">
        <doc xml:space="preserve">Initialize a GckObject from a raw PKCS#11 handle. Normally you would use
[method@Session.create_object] or [method@Session.find_objects] to access
objects.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new object</doc>
          <type name="Object" c:type="GckObject*"/>
        </return-value>
        <parameters>
          <parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">The session through which this object is accessed or created.</doc>
            <type name="Session" c:type="GckSession*"/>
          </parameter>
          <parameter name="object_handle" transfer-ownership="none">
            <doc xml:space="preserve">The raw `CK_OBJECT_HANDLE` of the object.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="cache_lookup" c:identifier="gck_object_cache_lookup" throws="1">
        <doc xml:space="preserve">Lookup attributes in the cache, or retrieve them from the object if necessary.

If @object is a #GckObjectCache then this will lookup the attributes there
first if available, otherwise will read them from the object and update
the cache.

If @object is not a #GckObjectCache, then the attributes will simply be
read from the object.

This may block, use the asynchronous version when this is not desirable</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the attributes retrieved or %NULL on failure</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the object</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="attr_types" transfer-ownership="none">
            <doc xml:space="preserve">the types of attributes to update</doc>
            <array length="1" zero-terminated="0" c:type="const gulong*">
              <type name="gulong" c:type="gulong"/>
            </array>
          </parameter>
          <parameter name="n_attr_types" transfer-ownership="none">
            <doc xml:space="preserve">the number of attribute types</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="cache_lookup_async" c:identifier="gck_object_cache_lookup_async">
        <doc xml:space="preserve">Lookup attributes in the cache, or retrieve them from the object if necessary.

If @object is a #GckObjectCache then this will lookup the attributes there
first if available, otherwise will read them from the object and update
the cache.

If @object is not a #GckObjectCache, then the attributes will simply be
read from the object.

This will return immediately and complete asynchronously</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the object</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="attr_types" transfer-ownership="none">
            <doc xml:space="preserve">the types of attributes to update</doc>
            <array length="1" zero-terminated="0" c:type="const gulong*">
              <type name="gulong" c:type="gulong"/>
            </array>
          </parameter>
          <parameter name="n_attr_types" transfer-ownership="none">
            <doc xml:space="preserve">the number of attribute types</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="cache_lookup_finish" c:identifier="gck_object_cache_lookup_finish" throws="1">
        <doc xml:space="preserve">Complete an operation to lookup attributes in the cache or retrieve them
from the object if necessary.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the attributes retrieved or %NULL on failure</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the object</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the asynchrounous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="gck_object_destroy" throws="1">
        <doc xml:space="preserve">Destroy a PKCS#11 object, deleting it from storage or the session.
This call may block for an indefinite period.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the call was successful or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to destroy.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellable object, or %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_async" c:identifier="gck_object_destroy_async">
        <doc xml:space="preserve">Destroy a PKCS#11 object, deleting it from storage or the session.
This call will return immediately and complete asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to destroy.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellable object, or %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">Callback which is called when operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_finish" c:identifier="gck_object_destroy_finish" throws="1">
        <doc xml:space="preserve">Get the status of the operation to destroy a PKCS#11 object, begun with
gck_object_destroy_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the object was destroyed successfully or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object being destroyed.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result of the destory operation passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="gck_object_equal">
        <doc xml:space="preserve">Checks equality of two objects. Two GckObject objects can point to the same
underlying PKCS#11 object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if object1 and object2 are equal.
              %FALSE if either is not a GckObject.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object1" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to the first #GckObject</doc>
            <type name="Object" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="object2" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to the second #GckObject</doc>
            <type name="Object" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="gck_object_get" introspectable="0">
        <doc xml:space="preserve">Get the specified attributes from the object. This call may
block for an indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the resulting PKCS#11 attributes, or %NULL if an
         error occurred; the result must be unreffed when you're finished
         with it</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to get attributes from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A location to store an error.</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">The attribute types to get.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get_async" c:identifier="gck_object_get_async">
        <doc xml:space="preserve">Get the specified attributes from the object. The attributes will be cleared
of their current values, and new attributes will be stored. The attributes
should not be accessed in any way except for referencing and unreferencing
them until gck_object_get_finish() is called.

This call returns immediately and completes asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to get attributes from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="attr_types" transfer-ownership="none">
            <doc xml:space="preserve">the types of the attributes to get</doc>
            <array length="1" zero-terminated="0" c:type="const gulong*">
              <type name="gulong" c:type="gulong"/>
            </array>
          </parameter>
          <parameter name="n_attr_types" transfer-ownership="none">
            <doc xml:space="preserve">the number of attr_types</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">A callback which is called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to be passed to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="gck_object_get_data" throws="1">
        <doc xml:space="preserve">Get the data for the specified attribute from the object. For convenience
the returned data has a null terminator.

This call may block for an indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the resulting PKCS#11
         attribute data, or %NULL if an error occurred</doc>
          <array length="2" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to get attribute data from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">The attribute to get data for.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="n_data" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The length of the resulting data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_data_async" c:identifier="gck_object_get_data_async">
        <doc xml:space="preserve">Get the data for the specified attribute from the object.

This call will return immediately and complete asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to get attribute data from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">The attribute to get data for.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="allocator" transfer-ownership="none" skip="1">
            <doc xml:space="preserve">An allocator with which to allocate memory for the data, or %NULL for default.</doc>
            <type name="Allocator" c:type="GckAllocator"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to be passed to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_data_finish" c:identifier="gck_object_get_data_finish" throws="1">
        <doc xml:space="preserve">Get the result of an operation to get attribute data from
an object. For convenience the returned data has an extra null terminator,
not included in the returned length.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The PKCS#11 attribute data
         or %NULL if an error occurred.</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to get an attribute from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="n_data" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The length of the resulting data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_data_full" c:identifier="gck_object_get_data_full" introspectable="0" throws="1">
        <doc xml:space="preserve">Get the data for the specified attribute from the object. For convenience
the returned data has an extra null terminator, not included in the returned length.

This call may block for an indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The resulting PKCS#11
         attribute data, or %NULL if an error occurred.</doc>
          <array length="3" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to get attribute data from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">The attribute to get data for.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="allocator" transfer-ownership="none">
            <doc xml:space="preserve">An allocator with which to allocate memory for the data, or %NULL for default.</doc>
            <type name="Allocator" c:type="GckAllocator"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="n_data" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The length of the resulting data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_finish" c:identifier="gck_object_get_finish" throws="1">
        <doc xml:space="preserve">Get the result of a get operation and return specified attributes from
the object.

No extra references are added to the returned attributes pointer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The filled in attributes structure if successful or
%NULL if not successful.</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to get attributes from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_full" c:identifier="gck_object_get_full" throws="1">
        <doc xml:space="preserve">Get the specified attributes from the object. This call may
block for an indefinite period.

No extra references are added to the returned attributes pointer.
During this call you may not access the attributes in any way.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a pointer to the filled in attributes if successful,
         or %NULL if not</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to get attributes from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="attr_types" transfer-ownership="none">
            <doc xml:space="preserve">the types of the attributes to get</doc>
            <array length="1" zero-terminated="0" c:type="const gulong*">
              <type name="gulong" c:type="gulong"/>
            </array>
          </parameter>
          <parameter name="n_attr_types" transfer-ownership="none">
            <doc xml:space="preserve">the number of attr_types</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_handle" c:identifier="gck_object_get_handle" glib:get-property="handle">
        <doc xml:space="preserve">Get the raw PKCS#11 handle of a GckObject.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the raw CK_OBJECT_HANDLE object handle</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_module" c:identifier="gck_object_get_module" glib:get-property="module">
        <doc xml:space="preserve">Get the PKCS#11 module to which this object belongs.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the module, which should be unreffed after use</doc>
          <type name="Module" c:type="GckModule*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_session" c:identifier="gck_object_get_session" glib:get-property="session">
        <doc xml:space="preserve">Get the PKCS#11 session assigned to make calls on when operating
on this object.

This will only return a session if it was set explitly on this
object. By default an object will open and close sessions
appropriate for its calls.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the assigned session, which must be unreffed after use</doc>
          <type name="Session" c:type="GckSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_template" c:identifier="gck_object_get_template" throws="1">
        <doc xml:space="preserve">Get an attribute template from the object. The attr_type must be for
an attribute which returns a template.

This call may block for an indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the resulting PKCS#11 attribute template, or %NULL
         if an error occurred</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to get an attribute template from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">The template attribute type.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_template_async" c:identifier="gck_object_get_template_async">
        <doc xml:space="preserve">Get an attribute template from the object. The @attr_type must be for
an attribute which returns a template.

This call will return immediately and complete asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to get an attribute template from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">The template attribute type.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to be passed to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_template_finish" c:identifier="gck_object_get_template_finish" throws="1">
        <doc xml:space="preserve">Get the result of an operation to get attribute template from
an object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the resulting PKCS#11 attribute template, or %NULL
         if an error occurred</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to get an attribute from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="gck_object_hash">
        <doc xml:space="preserve">Create a hash value for the GckObject.

This function is intended for easily hashing a GckObject to add to
a GHashTable or similar data structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An integer that can be used as a hash value, or 0 if invalid.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #GckObject</doc>
            <type name="Object" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="gck_object_set" throws="1">
        <doc xml:space="preserve">Set PKCS#11 attributes on an object. This call may block for an indefinite period.

If the @attrs #GckAttributes is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the call was successful or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to set attributes on.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attributes to set on the object.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellable object, or %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_async" c:identifier="gck_object_set_async">
        <doc xml:space="preserve">Set PKCS#11 attributes on an object. This call will return
immediately and completes asynchronously.

If the @attrs #GckAttributes is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to set attributes on.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attributes to set on the object.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellable object, or %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">Callback which is called when operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_finish" c:identifier="gck_object_set_finish" throws="1">
        <doc xml:space="preserve">Get the status of the operation to set attributes on a PKCS#11 object,
begun with gck_object_set_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the attributes were successfully set on the object or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to set attributes on.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result of the destory operation passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_template" c:identifier="gck_object_set_template" throws="1">
        <doc xml:space="preserve">Set an attribute template on the object. The attr_type must be for
an attribute which contains a template.

If the @attrs #GckAttributes is floating, it is consumed.

This call may block for an indefinite period.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to set an attribute template on.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">The attribute template type.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attribute template.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_template_async" c:identifier="gck_object_set_template_async">
        <doc xml:space="preserve">Set an attribute template on the object. The attr_type must be for
an attribute which contains a template.

If the @attrs #GckAttributes is floating, it is consumed.

This call will return immediately and complete asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to set an attribute template on.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:space="preserve">The attribute template type.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attribute template.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to be passed to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_template_finish" c:identifier="gck_object_set_template_finish" throws="1">
        <doc xml:space="preserve">Get the result of an operation to set attribute template on
an object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The object to set an attribute template on.</doc>
            <type name="Object" c:type="GckObject*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="handle" writable="1" construct-only="1" transfer-ownership="none" getter="get_handle">
        <doc xml:space="preserve">The raw PKCS11 handle for this object.</doc>
        <type name="gulong" c:type="gulong"/>
      </property>
      <property name="module" writable="1" construct-only="1" transfer-ownership="none" getter="get_module">
        <doc xml:space="preserve">The GckModule that this object belongs to.</doc>
        <type name="Module"/>
      </property>
      <property name="session" writable="1" construct-only="1" transfer-ownership="none" getter="get_session">
        <doc xml:space="preserve">The PKCS11 session to make calls on when this object needs to
perform operations on itself.

If this is NULL then a new session is opened for each operation,
such as gck_object_get(), gck_object_set() or gck_object_destroy().</doc>
        <type name="Session"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="ObjectPrivate" c:type="GckObjectPrivate*"/>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <interface name="ObjectCache" c:symbol-prefix="object_cache" c:type="GckObjectCache" glib:type-name="GckObjectCache" glib:get-type="gck_object_cache_get_type" glib:type-struct="ObjectCacheIface">
      <doc xml:space="preserve">An interface implemented by derived classes of [class@Object] to indicate
which attributes they'd like an enumerator to retrieve.

These attributes are then cached on the object and can be retrieved through
the [property@ObjectCache:attributes] property.</doc>
      <prerequisite name="Object"/>
      <virtual-method name="fill" invoker="fill">
        <doc xml:space="preserve">Adds the attributes to the set cached on this object. If an attribute is
already present in the cache it will be overridden by this value.

This will be done in a thread-safe manner.

If the @attrs #GckAttributes is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">an object with the cache</doc>
            <type name="ObjectCache" c:type="GckObjectCache*"/>
          </instance-parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">the attributes to cache</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="fill" c:identifier="gck_object_cache_fill">
        <doc xml:space="preserve">Adds the attributes to the set cached on this object. If an attribute is
already present in the cache it will be overridden by this value.

This will be done in a thread-safe manner.

If the @attrs #GckAttributes is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">an object with the cache</doc>
            <type name="ObjectCache" c:type="GckObjectCache*"/>
          </instance-parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">the attributes to cache</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attributes" c:identifier="gck_object_cache_get_attributes" glib:get-property="attributes" introspectable="0">
        <doc xml:space="preserve">Gets the attributes cached on this object.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the attributes</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">an object with an attribute cache</doc>
            <type name="ObjectCache" c:type="GckObjectCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_attributes" c:identifier="gck_object_cache_set_attributes" glib:set-property="attributes">
        <doc xml:space="preserve">Sets the attributes cached on this object.

If the @attrs #GckAttributes is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">an object with an attribute cache</doc>
            <type name="ObjectCache" c:type="GckObjectCache*"/>
          </instance-parameter>
          <parameter name="attrs" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the attributes to set</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update" c:identifier="gck_object_cache_update" throws="1">
        <doc xml:space="preserve">Update the object cache with given attributes. If an attribute already
exists in the cache, it will be updated, and if it doesn't it will be added.

This may block, use the asynchronous version when this is not desirable</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the cache update was successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the object with the cache</doc>
            <type name="ObjectCache" c:type="GckObjectCache*"/>
          </instance-parameter>
          <parameter name="attr_types" transfer-ownership="none">
            <doc xml:space="preserve">the types of attributes to update</doc>
            <array length="1" zero-terminated="0" c:type="const gulong*">
              <type name="gulong" c:type="gulong"/>
            </array>
          </parameter>
          <parameter name="n_attr_types" transfer-ownership="none">
            <doc xml:space="preserve">the number of attribute types</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_async" c:identifier="gck_object_cache_update_async">
        <doc xml:space="preserve">Update the object cache with given attributes. If an attribute already
exists in the cache, it will be updated, and if it doesn't it will be added.

This call will return immediately and complete asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the object with the cache</doc>
            <type name="ObjectCache" c:type="GckObjectCache*"/>
          </instance-parameter>
          <parameter name="attr_types" transfer-ownership="none">
            <doc xml:space="preserve">the types of attributes to update</doc>
            <array length="1" zero-terminated="0" c:type="const gulong*">
              <type name="gulong" c:type="gulong"/>
            </array>
          </parameter>
          <parameter name="n_attr_types" transfer-ownership="none">
            <doc xml:space="preserve">the number of attribute types</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_finish" c:identifier="gck_object_cache_update_finish" throws="1">
        <doc xml:space="preserve">Complete an asynchronous operation to update the object cache with given
attributes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the cache update was successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the object with the cache</doc>
            <type name="ObjectCache" c:type="GckObjectCache*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="attributes" writable="1" transfer-ownership="none" setter="set_attributes" getter="get_attributes">
        <doc xml:space="preserve">The attributes cached on this object.</doc>
        <type name="Attributes"/>
      </property>
    </interface>
    <record name="ObjectCacheIface" c:type="GckObjectCacheIface" glib:is-gtype-struct-for="ObjectCache">
      <doc xml:space="preserve">Interface for [iface@ObjectCache]. If the @default_types field is
implemented by a implementing class, then that will be used by a
[class@Enumerator] which has been setup using
[method@Enumerator.set_object_type]

The implementation for @populate should add the attributes to the
cache. It must be thread safe.</doc>
      <field name="interface">
        <doc xml:space="preserve">parent interface</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="default_types">
        <doc xml:space="preserve">attribute types that an
                  enumerator should retrieve</doc>
        <array length="2" zero-terminated="0" c:type="const gulong*">
          <type name="gulong" c:type="gulong"/>
        </array>
      </field>
      <field name="n_default_types">
        <doc xml:space="preserve">number of attribute types to be retrieved</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="fill">
        <callback name="fill">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve">an object with the cache</doc>
              <type name="ObjectCache" c:type="GckObjectCache*"/>
            </parameter>
            <parameter name="attrs" transfer-ownership="none">
              <doc xml:space="preserve">the attributes to cache</doc>
              <type name="Attributes" c:type="GckAttributes*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ObjectClass" c:type="GckObjectClass" glib:is-gtype-struct-for="Object">
      <doc xml:space="preserve">The class for a [class@Object].

If the @attribute_types field is set by a derived class, then the a
#GckEnumerator which has been setup using [method@Enumerator.set_object_type]
with this derived type will retrieve these attributes when enumerating. In
this case the class must implement an 'attributes' property of boxed type
`GCK_TYPE_ATTRIBUTES`.</doc>
      <field name="parent">
        <doc xml:space="preserve">derived from this</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ObjectPrivate" c:type="GckObjectPrivate" disguised="1"/>
    <function-macro name="PASSWORD" c:identifier="GCK_PASSWORD" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PASSWORD_CLASS" c:identifier="GCK_PASSWORD_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PASSWORD_GET_CLASS" c:identifier="GCK_PASSWORD_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Password" c:symbol-prefix="password" c:type="GckPassword" parent="Gio.TlsPassword" glib:type-name="GckPassword" glib:get-type="gck_password_get_type" glib:type-struct="PasswordClass">
      <doc xml:space="preserve">Represents a password which is requested of the user.

This is used in conjuction with [class@Gio.TlsInteraction]. `GckPassword` is
a [class@Gio.TlsPassword] which contains additional information about which
PKCS#11 token or key the password is being requested for.</doc>
      <method name="get_key" c:identifier="gck_password_get_key" glib:get-property="key">
        <doc xml:space="preserve">If the password request is to unlock a PKCS#11 key, then this is the
the object representing that key.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the password is for this key, or %NULL if not
         being requested for a key; must be unreferenced after use</doc>
          <type name="Object" c:type="GckObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the password object</doc>
            <type name="Password" c:type="GckPassword*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_module" c:identifier="gck_password_get_module" glib:get-property="module">
        <doc xml:space="preserve">Get the PKCS#11 module that is requesting the password.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the module that is requesting the password, which
         must be unreferenced after use</doc>
          <type name="Module" c:type="GckModule*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the password object</doc>
            <type name="Password" c:type="GckPassword*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_token" c:identifier="gck_password_get_token" glib:get-property="token">
        <doc xml:space="preserve">If the password request is to unlock a PKCS#11 token, then this is the
slot containing that token.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the slot that contains the token, or %NULL if not
         being requested for a token; must be unreferenced after use</doc>
          <type name="Slot" c:type="GckSlot*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the password object</doc>
            <type name="Password" c:type="GckPassword*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="key" writable="1" construct-only="1" transfer-ownership="none" getter="get_key">
        <doc xml:space="preserve">The PKCS#11 key that the password is being requested for. If this
is set then the GckPassword:token property will be %NULL</doc>
        <type name="Object"/>
      </property>
      <property name="module" transfer-ownership="none" getter="get_module">
        <doc xml:space="preserve">The PKCS#11 module that is requesting the password</doc>
        <type name="Module"/>
      </property>
      <property name="token" writable="1" construct-only="1" transfer-ownership="none" getter="get_token">
        <doc xml:space="preserve">The PKCS#11 token the password is for, if this is set then
the GckPassword:object property will be %NULL</doc>
        <type name="Slot"/>
      </property>
      <field name="parent">
        <type name="Gio.TlsPassword" c:type="GTlsPassword"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="PasswordPrivate" c:type="GckPasswordPrivate*"/>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="PasswordClass" c:type="GckPasswordClass" glib:is-gtype-struct-for="Password">
      <doc xml:space="preserve">The class struct for [class@Password].</doc>
      <field name="parent">
        <doc xml:space="preserve">parent class</doc>
        <type name="Gio.TlsPasswordClass" c:type="GTlsPasswordClass"/>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="PasswordPrivate" c:type="GckPasswordPrivate" disguised="1"/>
    <function-macro name="SESSION" c:identifier="GCK_SESSION" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SESSION_CLASS" c:identifier="GCK_SESSION_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SESSION_GET_CLASS" c:identifier="GCK_SESSION_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SLOT" c:identifier="GCK_SLOT" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SLOT_CLASS" c:identifier="GCK_SLOT_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SLOT_GET_CLASS" c:identifier="GCK_SLOT_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Session" c:symbol-prefix="session" c:type="GckSession" parent="GObject.Object" glib:type-name="GckSession" glib:get-type="gck_session_get_type" glib:type-struct="SessionClass">
      <doc xml:space="preserve">Represents an open PKCS11 session.

Before performing any PKCS11 operations, a session must be opened. This is
analogous to an open database handle, or a file handle.</doc>
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <function name="from_handle" c:identifier="gck_session_from_handle">
        <doc xml:space="preserve">Initialize a session object from a raw PKCS#11 session handle.
Usually one would use the [method@Slot.open_session] function to
create a session.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new GckSession object</doc>
          <type name="Session" c:type="GckSession*"/>
        </return-value>
        <parameters>
          <parameter name="slot" transfer-ownership="none">
            <doc xml:space="preserve">The slot which the session belongs to.</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </parameter>
          <parameter name="session_handle" transfer-ownership="none">
            <doc xml:space="preserve">the raw PKCS#11 handle of the session</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">Session options. Those which are used during opening a session have no effect.</doc>
            <type name="SessionOptions" c:type="GckSessionOptions"/>
          </parameter>
        </parameters>
      </function>
      <function name="open" c:identifier="gck_session_open" throws="1">
        <doc xml:space="preserve">Open a session on the slot. This call may block for an indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new session</doc>
          <type name="Session" c:type="GckSession*"/>
        </return-value>
        <parameters>
          <parameter name="slot" transfer-ownership="none">
            <doc xml:space="preserve">the slot to open session on</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">session options</doc>
            <type name="SessionOptions" c:type="GckSessionOptions"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional interaction for logins or object authentication</doc>
            <type name="Gio.TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="open_async" c:identifier="gck_session_open_async">
        <doc xml:space="preserve">Open a session on the slot. This call will return immediately and complete
asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="slot" transfer-ownership="none">
            <doc xml:space="preserve">the slot to open session on</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">session options</doc>
            <type name="SessionOptions" c:type="GckSessionOptions"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional interaction for logins or object authentication</doc>
            <type name="Gio.TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="open_finish" c:identifier="gck_session_open_finish" throws="1">
        <doc xml:space="preserve">Get the result of an open session operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new session</doc>
          <type name="Session" c:type="GckSession*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="discard_handle" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="handle" transfer-ownership="none">
            <type c:type="CK_SESSION_HANDLE"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="create_object" c:identifier="gck_session_create_object" throws="1">
        <doc xml:space="preserve">Create a new PKCS#11 object. This call may block for an
indefinite period.

If the @attrs #GckAttributes is floating, it is consumed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created object or %NULL if an error occurred</doc>
          <type name="Object" c:type="GckObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to create the object on.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attributes to create the object with.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_object_async" c:identifier="gck_session_create_object_async">
        <doc xml:space="preserve">Create a new PKCS#11 object. This call will return immediately
and complete asynchronously.

If @attrs is a floating reference, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to create the object on.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">The attributes to create the object with.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_object_finish" c:identifier="gck_session_create_object_finish" throws="1">
        <doc xml:space="preserve">Get the result of creating a new PKCS#11 object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created object or %NULL if an error occurred</doc>
          <type name="Object" c:type="GckObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to create the object on.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="decrypt" c:identifier="gck_session_decrypt" throws="1">
        <doc xml:space="preserve">Decrypt data in a mechanism specific manner. This call may
block for an indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the data that was decrypted,
         or %NULL if an error occured</doc>
          <array length="4" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The key to decrypt with.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mech_type" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type to use for decryption.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">data to decrypt</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">length of the data to decrypt</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="n_result" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to store the length of the result data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="decrypt_async" c:identifier="gck_session_decrypt_async">
        <doc xml:space="preserve">Decrypt data in a mechanism specific manner. This call will
return immediately and complete asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The key to decrypt with.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type and parameters to use for decryption.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">data to decrypt</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">length of the data to decrypt</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A GCancellable which can be used to cancel the operation.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A pointer to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="decrypt_finish" c:identifier="gck_session_decrypt_finish" throws="1">
        <doc xml:space="preserve">Get the result of an decryption operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the data that was decrypted,
         or %NULL if an error occurred</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result object passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="n_result" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">A location to store the length of the result data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="decrypt_full" c:identifier="gck_session_decrypt_full" throws="1">
        <doc xml:space="preserve">Decrypt data in a mechanism specific manner. This call may
block for an indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the data that was decrypted,
         or %NULL if an error occured</doc>
          <array length="4" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The key to decrypt with.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type and parameters to use for decryption.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">data to decrypt</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">length of the data to decrypt</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="n_result" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to store the length of the result data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A GCancellable which can be used to cancel the operation.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="derive_key" c:identifier="gck_session_derive_key" throws="1">
        <doc xml:space="preserve">Derive a key from another key. This call may block for an
indefinite period.

If the @attrs #GckAttributes is floating, it is consumed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new derived key or %NULL if the operation
         failed</doc>
          <type name="Object" c:type="GckObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="base" transfer-ownership="none">
            <doc xml:space="preserve">The key to derive from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mech_type" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism to use for derivation.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">Additional attributes for the derived key.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="derive_key_async" c:identifier="gck_session_derive_key_async">
        <doc xml:space="preserve">Derive a key from another key. This call will
return immediately and complete asynchronously.

If the @attrs #GckAttributes is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="base" transfer-ownership="none">
            <doc xml:space="preserve">The key to derive from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism to use for derivation.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">Additional attributes for the derived key.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="derive_key_finish" c:identifier="gck_session_derive_key_finish" throws="1">
        <doc xml:space="preserve">Get the result of a derive key operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new derived key or %NULL if the operation
         failed</doc>
          <type name="Object" c:type="GckObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The async result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="derive_key_full" c:identifier="gck_session_derive_key_full" throws="1">
        <doc xml:space="preserve">Derive a key from another key. This call may block for an
indefinite period.

If the @attrs #GckAttributes is floating, it is consumed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new derived key or %NULL if the operation
         failed</doc>
          <type name="Object" c:type="GckObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="base" transfer-ownership="none">
            <doc xml:space="preserve">The key to derive from.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism to use for derivation.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">Additional attributes for the derived key.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="encrypt" c:identifier="gck_session_encrypt" throws="1">
        <doc xml:space="preserve">Encrypt data in a mechanism specific manner. This call may
block for an indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the data that was encrypted,
         or %NULL if an error occured.</doc>
          <array length="4" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The key to encrypt with.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mech_type" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type to use for encryption.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">the data to encrypt</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">the length of the data to encrypt</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="n_result" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to store the length of the result data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="encrypt_async" c:identifier="gck_session_encrypt_async">
        <doc xml:space="preserve">Encrypt data in a mechanism specific manner. This call will
return immediately and complete asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The key to encrypt with.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type and parameters to use for encryption.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">the data to encrypt</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">length of the data to encrypt</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A GCancellable which can be used to cancel the operation.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A pointer to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="encrypt_finish" c:identifier="gck_session_encrypt_finish" throws="1">
        <doc xml:space="preserve">Get the result of an encryption operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the data that was encrypted,
         or %NULL if an error occurred.</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result object passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="n_result" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">A location to store the length of the result data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="encrypt_full" c:identifier="gck_session_encrypt_full" throws="1">
        <doc xml:space="preserve">Encrypt data in a mechanism specific manner. This call may
block for an indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the data that was encrypted,
         or %NULL if an error occured</doc>
          <array length="4" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The key to encrypt with.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type and parameters to use for encryption.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">the data to encrypt</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">the length of the data to encrypt</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="n_result" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to store the length of the result data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A GCancellable which can be used to cancel the operation.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_objects" c:identifier="gck_session_enumerate_objects">
        <doc xml:space="preserve">Setup an enumerator for listing matching objects available via this session.

If @match is a floating reference, it is consumed.

This call will not block but will return an enumerator immediately.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new enumerator</doc>
          <type name="Enumerator" c:type="GckEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">session to enumerate objects on</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="match" transfer-ownership="none">
            <doc xml:space="preserve">attributes that the objects must match, or empty for all objects</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_handles" c:identifier="gck_session_find_handles" throws="1">
        <doc xml:space="preserve">Find the objects matching the passed attributes. This call may
block for an indefinite period.

If @match is a floating reference, it is consumed.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a list of
         the matching objects, which may be empty</doc>
          <array length="2" zero-terminated="0" c:type="gulong*">
            <type name="gulong" c:type="gulong"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the session to find objects on</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="match" transfer-ownership="none">
            <doc xml:space="preserve">the attributes to match against objects</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="n_handles" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to return number of handles</doc>
            <type name="gulong" c:type="gulong*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_handles_async" c:identifier="gck_session_find_handles_async">
        <doc xml:space="preserve">Find the objects matching the passed attributes. This call will
return immediately and complete asynchronously.

If @match is a floating reference, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the session to find objects on</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="match" transfer-ownership="none">
            <doc xml:space="preserve">the attributes to match against the objects</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_handles_finish" c:identifier="gck_session_find_handles_finish" throws="1">
        <doc xml:space="preserve">Get the result of a find handles operation.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">an array of
         handles that matched, which may be empty, or %NULL on failure</doc>
          <array length="1" zero-terminated="0" c:type="gulong*">
            <type name="gulong" c:type="gulong"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the session</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the asynchronous result</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="n_handles" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to store number of handles returned</doc>
            <type name="gulong" c:type="gulong*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_objects" c:identifier="gck_session_find_objects" throws="1">
        <doc xml:space="preserve">Find the objects matching the passed attributes. This call may
block for an indefinite period.

If @match is a floating reference, it is consumed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a list of the matching
         objects, which may be empty</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Object"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to find objects on.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="match" transfer-ownership="none">
            <doc xml:space="preserve">the attributes to match</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_objects_async" c:identifier="gck_session_find_objects_async">
        <doc xml:space="preserve">Find the objects matching the passed attributes. This call will
return immediately and complete asynchronously.

If the @match #GckAttributes is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to find objects on.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="match" transfer-ownership="none">
            <doc xml:space="preserve">The attributes to match.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_objects_finish" c:identifier="gck_session_find_objects_finish" throws="1">
        <doc xml:space="preserve">Get the result of a find operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a list of the matching
         objects, which may be empty</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Object"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to find objects on.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The attributes to match.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="generate_key_pair" c:identifier="gck_session_generate_key_pair" throws="1">
        <doc xml:space="preserve">Generate a new key pair of public and private keys. This call may block for
an indefinite period.

If @public_attrs and/or @private_attrs is a floating reference, it is
consumed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="mech_type" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type to use for key generation.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="public_attrs" transfer-ownership="none">
            <doc xml:space="preserve">Additional attributes for the generated public key.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="private_attrs" transfer-ownership="none">
            <doc xml:space="preserve">Additional attributes for the generated private key.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="public_key" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to return the resulting public key</doc>
            <type name="Object" c:type="GckObject**"/>
          </parameter>
          <parameter name="private_key" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to return the resulting private key.</doc>
            <type name="Object" c:type="GckObject**"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="generate_key_pair_async" c:identifier="gck_session_generate_key_pair_async">
        <doc xml:space="preserve">Generate a new key pair of public and private keys. This call will
return immediately and complete asynchronously.

If @public_attrs and/or @private_attrs is a floating reference, it is
consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism to use for key generation.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="public_attrs" transfer-ownership="none">
            <doc xml:space="preserve">Additional attributes for the generated public key.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="private_attrs" transfer-ownership="none">
            <doc xml:space="preserve">Additional attributes for the generated private key.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="generate_key_pair_finish" c:identifier="gck_session_generate_key_pair_finish" throws="1">
        <doc xml:space="preserve">Get the result of a generate key pair operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The async result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="public_key" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to return the resulting public key</doc>
            <type name="Object" c:type="GckObject**"/>
          </parameter>
          <parameter name="private_key" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to return the resulting private key</doc>
            <type name="Object" c:type="GckObject**"/>
          </parameter>
        </parameters>
      </method>
      <method name="generate_key_pair_full" c:identifier="gck_session_generate_key_pair_full" throws="1">
        <doc xml:space="preserve">Generate a new key pair of public and private keys. This call may block for an
indefinite period.

If @public_attrs and/or @private_attrs is a floating reference, it is
consumed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism to use for key generation.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="public_attrs" transfer-ownership="none">
            <doc xml:space="preserve">Additional attributes for the generated public key.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="private_attrs" transfer-ownership="none">
            <doc xml:space="preserve">Additional attributes for the generated private key.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="public_key" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to return the resulting public key</doc>
            <type name="Object" c:type="GckObject**"/>
          </parameter>
          <parameter name="private_key" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to return the resulting private key</doc>
            <type name="Object" c:type="GckObject**"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_handle" c:identifier="gck_session_get_handle" glib:get-property="handle">
        <doc xml:space="preserve">Get the raw PKCS#11 session handle from a session object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The raw session handle.</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session object.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_info" c:identifier="gck_session_get_info">
        <doc xml:space="preserve">Get information about the session.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the session info. Use the gck_session_info_free()
         to release when done</doc>
          <type name="SessionInfo" c:type="GckSessionInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session object.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interaction" c:identifier="gck_session_get_interaction" glib:get-property="interaction">
        <doc xml:space="preserve">Get the interaction object set on this session, which is used to prompt
for pins and the like.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the interaction object, or %NULL</doc>
          <type name="Gio.TlsInteraction" c:type="GTlsInteraction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the session</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_module" c:identifier="gck_session_get_module" glib:get-property="module">
        <doc xml:space="preserve">Get the PKCS#11 module to which this session belongs.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the module, which should be unreffed after use</doc>
          <type name="Module" c:type="GckModule*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session object.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_options" c:identifier="gck_session_get_options" glib:get-property="options">
        <doc xml:space="preserve">Get the options this session was opened with.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The session options.</doc>
          <type name="SessionOptions" c:type="GckSessionOptions"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to get options from.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slot" c:identifier="gck_session_get_slot" glib:get-property="slot">
        <doc xml:space="preserve">Get the PKCS#11 slot to which this session belongs.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The slot, which should be unreffed after use.</doc>
          <type name="Slot" c:type="GckSlot*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session object.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state" c:identifier="gck_session_get_state">
        <doc xml:space="preserve">Get the session state. The state is the various PKCS#11 CKS_XXX flags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the session state</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the session</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_pin" c:identifier="gck_session_init_pin" throws="1">
        <doc xml:space="preserve">Initialize the user's pin on this slot that this session is opened on.
According to the PKCS#11 standards, the session must be logged in with
the CKU_SO user type.

This call may block for an indefinite period.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether successful or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">Initialize PIN for this session's slot.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="pin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user's PIN, or %NULL for
      protected authentication path</doc>
            <array length="1" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_pin" transfer-ownership="none">
            <doc xml:space="preserve">the length of the PIN</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_pin_async" c:identifier="gck_session_init_pin_async">
        <doc xml:space="preserve">Initialize the user's pin on this slot that this session is opened on.
According to the PKCS#11 standards, the session must be logged in with
the `CKU_SO` user type.

This call will return immediately and completes asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">Initialize PIN for this session's slot.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="pin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user's PIN, or %NULL for protected authentication path</doc>
            <array length="1" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_pin" transfer-ownership="none">
            <doc xml:space="preserve">the length of the PIN</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_pin_finish" c:identifier="gck_session_init_pin_finish" throws="1">
        <doc xml:space="preserve">Get the result of initializing a user's PIN.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the operation was successful or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="login" c:identifier="gck_session_login" throws="1">
        <doc xml:space="preserve">Login the user on the session. This call may block for
an indefinite period.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether successful or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">Log in to this session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="user_type" transfer-ownership="none">
            <doc xml:space="preserve">The type of login user.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="pin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user's PIN, or %NULL for
      protected authentication path</doc>
            <array length="2" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_pin" transfer-ownership="none">
            <doc xml:space="preserve">The length of the PIN.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="login_async" c:identifier="gck_session_login_async">
        <doc xml:space="preserve">Login the user on the session. This call will return
immediately and completes asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">Log in to this session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="user_type" transfer-ownership="none">
            <doc xml:space="preserve">The type of login user.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="pin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user's PIN, or %NULL for
      protected authentication path</doc>
            <array length="2" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_pin" transfer-ownership="none">
            <doc xml:space="preserve">The length of the PIN.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="login_finish" c:identifier="gck_session_login_finish" throws="1">
        <doc xml:space="preserve">Get the result of a login operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the operation was successful or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session logged into.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="login_interactive" c:identifier="gck_session_login_interactive" throws="1">
        <doc xml:space="preserve">Login the user on the session requesting the password interactively
when necessary. This call may block for an indefinite period.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether successful or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">session to use for login</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="user_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of login user</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">interaction to request PIN when necessary</doc>
            <type name="Gio.TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="login_interactive_async" c:identifier="gck_session_login_interactive_async">
        <doc xml:space="preserve">Login the user on the session prompting for passwords interactively when
necessary. This call will return immediately and completes asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">session to use for login</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="user_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of login user</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">interaction to request PIN when necessary</doc>
            <type name="Gio.TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="login_interactive_finish" c:identifier="gck_session_login_interactive_finish" throws="1">
        <doc xml:space="preserve">Get the result of a login operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the operation was successful or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the session logged into</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="logout" c:identifier="gck_session_logout" throws="1">
        <doc xml:space="preserve">Log out of the session. This call may block for an indefinite period.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the logout was successful or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">Logout of this session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="logout_async" c:identifier="gck_session_logout_async">
        <doc xml:space="preserve">Log out of the session. This call returns immediately and completes
asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">Logout of this session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="logout_finish" c:identifier="gck_session_logout_finish" throws="1">
        <doc xml:space="preserve">Get the result of logging out of a session.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the logout was successful or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">Logout of this session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_interaction" c:identifier="gck_session_set_interaction" glib:set-property="interaction">
        <doc xml:space="preserve">Set the interaction object on this session, which is used to prompt for
pins and the like.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the session</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the interaction or %NULL</doc>
            <type name="Gio.TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pin" c:identifier="gck_session_set_pin" throws="1">
        <doc xml:space="preserve">Change the user's pin on this slot that this session is opened on.

This call may block for an indefinite period.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether successful or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">Change the PIN for this session's slot.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="old_pin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user's old PIN, or %NULL
          for protected authentication path.</doc>
            <array length="1" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_old_pin" transfer-ownership="none">
            <doc xml:space="preserve">The length of the PIN.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="new_pin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user's new PIN, or %NULL
          for protected authentication path</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_new_pin" transfer-ownership="none">
            <doc xml:space="preserve">The length of the PIN.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pin_async" c:identifier="gck_session_set_pin_async">
        <doc xml:space="preserve">Change the user's pin on this slot that this session is opened on.

This call will return immediately and completes asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">Change the PIN for this session's slot.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="old_pin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user's old PIN, or %NULL
          for protected authentication path</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_old_pin" transfer-ownership="none">
            <doc xml:space="preserve">the length of the old PIN</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="new_pin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user's new PIN, or %NULL
          for protected authentication path</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_new_pin" transfer-ownership="none">
            <doc xml:space="preserve">the length of the new PIN</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pin_finish" c:identifier="gck_session_set_pin_finish" throws="1">
        <doc xml:space="preserve">Get the result of changing a user's PIN.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the operation was successful or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sign" c:identifier="gck_session_sign" throws="1">
        <doc xml:space="preserve">Sign data in a mechanism specific manner. This call may
block for an indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the data that was signed,
         or %NULL if an error occured</doc>
          <array length="4" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The key to sign with.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mech_type" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type to use for signing.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">data to sign</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">length of the data to sign</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="n_result" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to store the length of the result data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sign_async" c:identifier="gck_session_sign_async">
        <doc xml:space="preserve">Sign data in a mechanism specific manner. This call will
return immediately and complete asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The key to sign with.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type and parameters to use for signing.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">data to sign</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">length of the data to sign</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A GCancellable which can be used to cancel the operation.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A pointer to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="sign_finish" c:identifier="gck_session_sign_finish" throws="1">
        <doc xml:space="preserve">Get the result of an signing operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the data that was signed,
         or %NULL if an error occurred</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result object passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="n_result" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">A location to store the length of the result data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sign_full" c:identifier="gck_session_sign_full" throws="1">
        <doc xml:space="preserve">Sign data in a mechanism specific manner. This call may
block for an indefinite period.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The data that was signed, or %NULL if an error occured.</doc>
          <type name="guint8" c:type="guchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The key to sign with.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type and parameters to use for signing.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">data to sign</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">length of the data to sign</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="n_result" transfer-ownership="none">
            <doc xml:space="preserve">location to store the length of the result data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A GCancellable which can be used to cancel the operation.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unwrap_key" c:identifier="gck_session_unwrap_key" throws="1">
        <doc xml:space="preserve">Unwrap a key from a byte stream. This call may block for an
indefinite period.

If @attrs is a floating reference, it is consumed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new unwrapped key or %NULL if the
         operation failed</doc>
          <type name="Object" c:type="GckObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="wrapper" transfer-ownership="none">
            <doc xml:space="preserve">The key to use for unwrapping.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mech_type" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism to use for unwrapping.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">the wrapped data as a byte stream</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">The length of the wrapped data.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">Additional attributes for the unwrapped key.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unwrap_key_async" c:identifier="gck_session_unwrap_key_async">
        <doc xml:space="preserve">Unwrap a key from a byte stream. This call will
return immediately and complete asynchronously.

If @attrs is a floating reference, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="wrapper" transfer-ownership="none">
            <doc xml:space="preserve">The key to use for unwrapping.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism to use for unwrapping.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">the wrapped data as a byte stream</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">The length of the wrapped data.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">Additional attributes for the unwrapped key.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unwrap_key_finish" c:identifier="gck_session_unwrap_key_finish" throws="1">
        <doc xml:space="preserve">Get the result of a unwrap key operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new unwrapped key or %NULL if the operation
         failed.</doc>
          <type name="Object" c:type="GckObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The async result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unwrap_key_full" c:identifier="gck_session_unwrap_key_full" throws="1">
        <doc xml:space="preserve">Unwrap a key from a byte stream. This call may block for an
indefinite period.

If @attrs is a floating reference, it is consumed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new unwrapped key or %NULL if the operation
         failed</doc>
          <type name="Object" c:type="GckObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="wrapper" transfer-ownership="none">
            <doc xml:space="preserve">The key to use for unwrapping.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism to use for unwrapping.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">the wrapped data as a byte stream</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">The length of the wrapped data.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">Additional attributes for the unwrapped key.</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify" c:identifier="gck_session_verify" throws="1">
        <doc xml:space="preserve">Verify data in a mechanism specific manner. This call may
block for an indefinite period.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the data verified correctly, otherwise a failure or error occurred.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The key to verify with.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mech_type" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type to use for verifying.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">data to verify</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">length of the data to verify</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="signature" transfer-ownership="none">
            <doc xml:space="preserve">the signature</doc>
            <array length="5" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_signature" transfer-ownership="none">
            <doc xml:space="preserve">length of the signature</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify_async" c:identifier="gck_session_verify_async">
        <doc xml:space="preserve">Verify data in a mechanism specific manner. This call returns
immediately and completes asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The key to verify with.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type and parameters to use for signing.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">data to verify</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">the length of the data to verify</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="signature" transfer-ownership="none">
            <doc xml:space="preserve">the signature</doc>
            <array length="5" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_signature" transfer-ownership="none">
            <doc xml:space="preserve">the length of the signature</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A GCancellable which can be used to cancel the operation.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="8">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A pointer to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify_finish" c:identifier="gck_session_verify_finish" throws="1">
        <doc xml:space="preserve">Get the result of an verify operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the data verified correctly, otherwise a failure or error occurred.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result object passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify_full" c:identifier="gck_session_verify_full" throws="1">
        <doc xml:space="preserve">Verify data in a mechanism specific manner. This call may
block for an indefinite period.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the data verified correctly, otherwise a failure or error occurred.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The key to verify with.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type and parameters to use for signing.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">data to verify</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_input" transfer-ownership="none">
            <doc xml:space="preserve">the length of the data to verify</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="signature" transfer-ownership="none">
            <doc xml:space="preserve">the signature</doc>
            <array length="5" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_signature" transfer-ownership="none">
            <doc xml:space="preserve">length of the signature</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A GCancellable which can be used to cancel the operation.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wrap_key" c:identifier="gck_session_wrap_key" throws="1">
        <doc xml:space="preserve">Wrap a key into a byte stream. This call may block for an
indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the wrapped data or %NULL
         if the operation failed</doc>
          <array length="3" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="wrapper" transfer-ownership="none">
            <doc xml:space="preserve">The key to use for wrapping.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mech_type" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism type to use for wrapping.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="wrapped" transfer-ownership="none">
            <doc xml:space="preserve">The key to wrap.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="n_result" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">A location in which to return the length of the wrapped data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wrap_key_async" c:identifier="gck_session_wrap_key_async">
        <doc xml:space="preserve">Wrap a key into a byte stream. This call will
return immediately and complete asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="wrapper" transfer-ownership="none">
            <doc xml:space="preserve">The key to use for wrapping.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism to use for wrapping.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="wrapped" transfer-ownership="none">
            <doc xml:space="preserve">The key to wrap.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="wrap_key_finish" c:identifier="gck_session_wrap_key_finish" throws="1">
        <doc xml:space="preserve">Get the result of a wrap key operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the wrapped data or %NULL
         if the operation failed</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The async result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="n_result" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">A location in which to return the length of the wrapped data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wrap_key_full" c:identifier="gck_session_wrap_key_full" throws="1">
        <doc xml:space="preserve">Wrap a key into a byte stream. This call may block for an
indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the wrapped data or %NULL
         if the operation failed</doc>
          <array length="3" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The session to use.</doc>
            <type name="Session" c:type="GckSession*"/>
          </instance-parameter>
          <parameter name="wrapper" transfer-ownership="none">
            <doc xml:space="preserve">The key to use for wrapping.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism to use for wrapping.</doc>
            <type name="Mechanism" c:type="GckMechanism*"/>
          </parameter>
          <parameter name="wrapped" transfer-ownership="none">
            <doc xml:space="preserve">The key to wrap.</doc>
            <type name="Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="n_result" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">A location in which to return the length of the wrapped data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <property name="app-data" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Raw PKCS#11 application data used to open the PKCS#11 session.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="handle" writable="1" construct-only="1" transfer-ownership="none" getter="get_handle">
        <doc xml:space="preserve">The raw CK_SESSION_HANDLE handle of this session.</doc>
        <type name="gulong" c:type="gulong"/>
      </property>
      <property name="interaction" writable="1" transfer-ownership="none" setter="set_interaction" getter="get_interaction">
        <doc xml:space="preserve">Interaction object used to ask the user for pins when opening
sessions. Used if the session_options of the enumerator have
%GCK_SESSION_LOGIN_USER</doc>
        <type name="Gio.TlsInteraction"/>
      </property>
      <property name="module" transfer-ownership="none" getter="get_module">
        <doc xml:space="preserve">The GckModule that this session is opened on.</doc>
        <type name="Module"/>
      </property>
      <property name="opening-flags" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Raw PKCS#11 flags used to open the PKCS#11 session.</doc>
        <type name="gulong" c:type="gulong"/>
      </property>
      <property name="options" writable="1" construct-only="1" transfer-ownership="none" getter="get_options">
        <doc xml:space="preserve">The options this session was opened with.</doc>
        <type name="SessionOptions"/>
      </property>
      <property name="slot" writable="1" construct-only="1" transfer-ownership="none" getter="get_slot">
        <doc xml:space="preserve">The GckSlot this session is opened on.</doc>
        <type name="Slot"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="SessionPrivate" c:type="GckSessionPrivate*"/>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="discard-handle" when="last">
        <doc xml:space="preserve">When a GckSession is being disposed of it emits this signal to allow
a session pool to pick up the handle and keep it around.

If no signal handler claims the handle, then it is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether or not this handle was claimed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">The handle being discarded.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="SessionClass" c:type="GckSessionClass" glib:is-gtype-struct-for="Session">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="discard_handle" introspectable="0">
        <callback name="discard_handle" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="GckSession*"/>
            </parameter>
            <parameter name="handle" transfer-ownership="none">
              <type c:type="CK_SESSION_HANDLE"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SessionInfo" c:type="GckSessionInfo" glib:type-name="GckSessionInfo" glib:get-type="gck_session_info_get_type" c:symbol-prefix="session_info">
      <doc xml:space="preserve">Information about the session. This is analogous to a CK_SESSION_INFO structure.

When done with this structure, release it using gck_session_info_free().</doc>
      <field name="slot_id" writable="1">
        <doc xml:space="preserve">The handle of the PKCS11 slot that this session is opened on.</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="state" writable="1">
        <doc xml:space="preserve">The user login state of the session.</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">Various PKCS11 flags.</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="device_error" writable="1">
        <doc xml:space="preserve">The last device error that occurred from an operation on this session.</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <method name="copy" c:identifier="gck_session_info_copy">
        <doc xml:space="preserve">Make a new copy of a session info structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new copy of the session info</doc>
          <type name="SessionInfo" c:type="GckSessionInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session_info" transfer-ownership="none">
            <doc xml:space="preserve">a session info structure</doc>
            <type name="SessionInfo" c:type="GckSessionInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gck_session_info_free">
        <doc xml:space="preserve">Free the GckSessionInfo structure and all associated memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session_info" transfer-ownership="none">
            <doc xml:space="preserve">Session info to free.</doc>
            <type name="SessionInfo" c:type="GckSessionInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="SessionOptions" glib:type-name="GckSessionOptions" glib:get-type="gck_session_options_get_type" c:type="GckSessionOptions">
      <doc xml:space="preserve">Options for creating sessions.</doc>
      <member name="read_only" value="0" c:identifier="GCK_SESSION_READ_ONLY" glib:nick="read-only" glib:name="GCK_SESSION_READ_ONLY">
        <doc xml:space="preserve">Open session as read only</doc>
      </member>
      <member name="read_write" value="2" c:identifier="GCK_SESSION_READ_WRITE" glib:nick="read-write" glib:name="GCK_SESSION_READ_WRITE">
        <doc xml:space="preserve">Open sessions as read/write</doc>
      </member>
      <member name="login_user" value="4" c:identifier="GCK_SESSION_LOGIN_USER" glib:nick="login-user" glib:name="GCK_SESSION_LOGIN_USER">
        <doc xml:space="preserve">Login as user on new sessions</doc>
      </member>
      <member name="authenticate" value="8" c:identifier="GCK_SESSION_AUTHENTICATE" glib:nick="authenticate" glib:name="GCK_SESSION_AUTHENTICATE">
        <doc xml:space="preserve">Authenticate as necessary</doc>
      </member>
    </bitfield>
    <record name="SessionPrivate" c:type="GckSessionPrivate" disguised="1"/>
    <class name="Slot" c:symbol-prefix="slot" c:type="GckSlot" parent="GObject.Object" glib:type-name="GckSlot" glib:get-type="gck_slot_get_type" glib:type-struct="SlotClass">
      <doc xml:space="preserve">Represents a PKCS#11 slot that can contain a token.

A PKCS#11 slot can contain a token. As an example, a slot might be a card
reader, and the token the card. If the PKCS#11 module is not a hardware
driver, often the slot and token are equivalent.</doc>
      <function name="from_handle" c:identifier="gck_slot_from_handle">
        <doc xml:space="preserve">Create a new GckSlot object for a raw PKCS#11 handle.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new GckSlot object.</doc>
          <type name="Slot" c:type="GckSlot*"/>
        </return-value>
        <parameters>
          <parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">The module that this slot is on.</doc>
            <type name="Module" c:type="GckModule*"/>
          </parameter>
          <parameter name="slot_id" transfer-ownership="none">
            <doc xml:space="preserve">The raw PKCS#11 handle or slot id of this slot.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </function>
      <method name="enumerate_objects" c:identifier="gck_slot_enumerate_objects">
        <doc xml:space="preserve">Setup an enumerator for listing matching objects on the slot.

If the @match #GckAttributes is floating, it is consumed.

This call will not block but will return an enumerator immediately.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new enumerator</doc>
          <type name="Enumerator" c:type="GckEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GckSlot to enumerate objects on</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
          <parameter name="match" transfer-ownership="none">
            <doc xml:space="preserve">attributes that the objects must match, or empty for all objects</doc>
            <type name="Attributes" c:type="GckAttributes*"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">options for opening a session</doc>
            <type name="SessionOptions" c:type="GckSessionOptions"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="gck_slot_equal">
        <doc xml:space="preserve">Checks equality of two slots. Two GckSlot objects can point to the same
underlying PKCS#11 slot.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if slot1 and slot2 are equal.
              %FALSE if either is not a GckSlot.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="slot1" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to the first #GckSlot</doc>
            <type name="Slot" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="slot2" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to the second #GckSlot</doc>
            <type name="Slot" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_handle" c:identifier="gck_slot_get_handle" glib:get-property="handle">
        <doc xml:space="preserve">Get the raw PKCS#11 handle of a slot.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the raw CK_SLOT_ID handle</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The slot to get the handle of.</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_info" c:identifier="gck_slot_get_info">
        <doc xml:space="preserve">Get the information for this slot.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the slot information, when done, use gck_slot_info_free()
         to release it.</doc>
          <type name="SlotInfo" c:type="GckSlotInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The slot to get info for.</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mechanism_info" c:identifier="gck_slot_get_mechanism_info">
        <doc xml:space="preserve">Get information for the specified mechanism.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the mechanism information, or %NULL if failed; use
         gck_mechanism_info_free() when done with it</doc>
          <type name="MechanismInfo" c:type="GckMechanismInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The slot to get mechanism info from.</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
          <parameter name="mech_type" transfer-ownership="none">
            <doc xml:space="preserve">The mechanisms type to get info for.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_mechanisms" c:identifier="gck_slot_get_mechanisms">
        <doc xml:space="preserve">Get the available mechanisms for this slot.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a list of the mechanisms
         for this slot, which should be freed with g_array_free ()</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gulong"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The slot to get mechanisms for.</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_module" c:identifier="gck_slot_get_module" glib:get-property="module">
        <doc xml:space="preserve">Get the module that this slot is on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The module, you must unreference this after
         you're done with it.</doc>
          <type name="Module" c:type="GckModule*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The slot to get the module for.</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_token_info" c:identifier="gck_slot_get_token_info">
        <doc xml:space="preserve">Get the token information for this slot.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the token information; when done, use gck_token_info_free()
         to release it</doc>
          <type name="TokenInfo" c:type="GckTokenInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The slot to get info for.</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_flags" c:identifier="gck_slot_has_flags">
        <doc xml:space="preserve">Check if the PKCS11 slot has the given flags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether one or more flags exist.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The GckSlot object.</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">The flags to check.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="gck_slot_hash">
        <doc xml:space="preserve">Create a hash value for the GckSlot.

This function is intended for easily hashing a GckSlot to add to
a GHashTable or similar data structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An integer that can be used as a hash value, or 0 if invalid.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="slot" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #GckSlot</doc>
            <type name="Slot" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="match" c:identifier="gck_slot_match">
        <doc xml:space="preserve">Check whether the PKCS#11 URI matches the slot</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the URI matches or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the slot to match</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the uri to match against the slot</doc>
            <type name="UriData" c:type="GckUriData*"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_session" c:identifier="gck_slot_open_session" throws="1">
        <doc xml:space="preserve">Open a session on the slot. If the 'auto reuse' setting is set,
then this may be a recycled session with the same flags.

This call may block for an indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new session or %NULL if an error occurs</doc>
          <type name="Session" c:type="GckSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The slot ot open a session on.</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">The #GckSessionOptions to open a session with.</doc>
            <type name="SessionOptions" c:type="GckSessionOptions"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">An optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_session_async" c:identifier="gck_slot_open_session_async">
        <doc xml:space="preserve">Open a session on the slot. If the 'auto reuse' setting is set,
then this may be a recycled session with the same flags.

This call will return immediately and complete asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The slot to open a session on.</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">The options to open the new session with.</doc>
            <type name="SessionOptions" c:type="GckSessionOptions"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_session_finish" c:identifier="gck_slot_open_session_finish" throws="1">
        <doc xml:space="preserve">Get the result of an open session operation. If the 'auto reuse' setting is set,
then this may be a recycled session with the same flags.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new session or %NULL if an error occurs</doc>
          <type name="Session" c:type="GckSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The slot to open a session on.</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The result passed to the callback.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_session_full" c:identifier="gck_slot_open_session_full" introspectable="0" throws="1">
        <doc xml:space="preserve">Open a session on the slot. If the 'auto reuse' setting is set,
then this may be a recycled session with the same flags.

This call may block for an indefinite period.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new session or %NULL if an error occurs</doc>
          <type name="Session" c:type="GckSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The slot to open a session on.</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">The options to open the new session with.</doc>
            <type name="SessionOptions" c:type="GckSessionOptions"/>
          </parameter>
          <parameter name="pkcs11_flags" transfer-ownership="none">
            <doc xml:space="preserve">Additional raw PKCS#11 flags.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="app_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Application data for notification callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none">
            <doc xml:space="preserve">PKCS#11 notification callback.</doc>
            <type c:type="CK_NOTIFY"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_session_full_async" c:identifier="gck_slot_open_session_full_async" introspectable="0">
        <doc xml:space="preserve">Open a session on the slot. If the 'auto reuse' setting is set,
then this may be a recycled session with the same flags.

This call will return immediately and complete asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The slot to open a session on.</doc>
            <type name="Slot" c:type="GckSlot*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">Options to open the new session with.</doc>
            <type name="SessionOptions" c:type="GckSessionOptions"/>
          </parameter>
          <parameter name="pkcs11_flags" transfer-ownership="none">
            <doc xml:space="preserve">Additional raw PKCS#11 flags.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="app_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Application data for notification callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none">
            <doc xml:space="preserve">PKCS#11 notification callback.</doc>
            <type c:type="CK_NOTIFY"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional cancellation object, or %NULL.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">Called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to the callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="handle" writable="1" construct-only="1" transfer-ownership="none" getter="get_handle">
        <doc xml:space="preserve">The raw CK_SLOT_ID handle of this slot.</doc>
        <type name="gulong" c:type="gulong"/>
      </property>
      <property name="module" writable="1" construct-only="1" transfer-ownership="none" getter="get_module">
        <doc xml:space="preserve">The PKCS11 object that this slot is a part of.</doc>
        <type name="Module"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="SlotPrivate" c:type="GckSlotPrivate*"/>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="SlotClass" c:type="GckSlotClass" glib:is-gtype-struct-for="Slot">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="9">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SlotInfo" c:type="GckSlotInfo" glib:type-name="GckSlotInfo" glib:get-type="gck_slot_info_get_type" c:symbol-prefix="slot_info">
      <doc xml:space="preserve">Represents information about a PKCS11 slot.

This is analogous to a CK_SLOT_INFO structure, but the
strings are far more usable.

When you're done with this structure it should be released with
gck_slot_info_free().</doc>
      <field name="slot_description" writable="1">
        <doc xml:space="preserve">Description of the slot.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="manufacturer_id" writable="1">
        <doc xml:space="preserve">The manufacturer of this slot.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">Various PKCS11 flags that apply to this slot.</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="hardware_version_major" writable="1">
        <doc xml:space="preserve">The major version of the hardware.</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="hardware_version_minor" writable="1">
        <doc xml:space="preserve">The minor version of the hardware.</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="firmware_version_major" writable="1">
        <doc xml:space="preserve">The major version of the firmware.</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="firmware_version_minor" writable="1">
        <doc xml:space="preserve">The minor version of the firmware.</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <method name="copy" c:identifier="gck_slot_info_copy">
        <doc xml:space="preserve">Make a copy of the slot info.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated copy slot info</doc>
          <type name="SlotInfo" c:type="GckSlotInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="slot_info" transfer-ownership="none">
            <doc xml:space="preserve">a slot info</doc>
            <type name="SlotInfo" c:type="GckSlotInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gck_slot_info_free">
        <doc xml:space="preserve">Free the GckSlotInfo and associated resources.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="slot_info" transfer-ownership="none">
            <doc xml:space="preserve">The slot info to free, or %NULL.</doc>
            <type name="SlotInfo" c:type="GckSlotInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="SlotPrivate" c:type="GckSlotPrivate" disguised="1"/>
    <record name="TokenInfo" c:type="GckTokenInfo" glib:type-name="GckTokenInfo" glib:get-type="gck_token_info_get_type" c:symbol-prefix="token_info">
      <doc xml:space="preserve">Represents information about a PKCS11 token.

This is analogous to a CK_TOKEN_INFO structure, but the
strings are far more usable.

When you're done with this structure it should be released with
gck_token_info_free().</doc>
      <field name="label" writable="1">
        <doc xml:space="preserve">The displayable token label.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="manufacturer_id" writable="1">
        <doc xml:space="preserve">The manufacturer of this slot.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="model" writable="1">
        <doc xml:space="preserve">The token model number as a string.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="serial_number" writable="1">
        <doc xml:space="preserve">The token serial number as a string.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">Various PKCS11 flags that apply to this token.</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="max_session_count" writable="1">
        <doc xml:space="preserve">The maximum number of sessions allowed on this token.</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="session_count" writable="1">
        <doc xml:space="preserve">The number of sessions open on this token.</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="max_rw_session_count" writable="1">
        <doc xml:space="preserve">The maximum number of read/write sessions allowed on this token.</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="rw_session_count" writable="1">
        <doc xml:space="preserve">The number of sessions open on this token.</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="max_pin_len" writable="1">
        <doc xml:space="preserve">The maximum length of a PIN for locking this token.</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="min_pin_len" writable="1">
        <doc xml:space="preserve">The minimum length of a PIN for locking this token.</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="total_public_memory" writable="1">
        <doc xml:space="preserve">The total amount of memory on this token for storing public objects.</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="free_public_memory" writable="1">
        <doc xml:space="preserve">The available amount of memory on this token for storing public objects.</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="total_private_memory" writable="1">
        <doc xml:space="preserve">The total amount of memory on this token for storing private objects.</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="free_private_memory" writable="1">
        <doc xml:space="preserve">The available amount of memory on this token for storing private objects.</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="hardware_version_major" writable="1">
        <doc xml:space="preserve">The major version of the hardware.</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="hardware_version_minor" writable="1">
        <doc xml:space="preserve">The minor version of the hardware.</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="firmware_version_major" writable="1">
        <doc xml:space="preserve">The major version of the firmware.</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="firmware_version_minor" writable="1">
        <doc xml:space="preserve">The minor version of the firmware.</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="utc_time" writable="1">
        <doc xml:space="preserve">If the token has a hardware clock, this is set to the number of seconds since the epoch.</doc>
        <type name="gint64" c:type="gint64"/>
      </field>
      <method name="copy" c:identifier="gck_token_info_copy">
        <doc xml:space="preserve">Make a copy of the token info.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated copy token info</doc>
          <type name="TokenInfo" c:type="GckTokenInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="token_info" transfer-ownership="none">
            <doc xml:space="preserve">a token info</doc>
            <type name="TokenInfo" c:type="GckTokenInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gck_token_info_free">
        <doc xml:space="preserve">Free the GckTokenInfo and associated resources.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="token_info" transfer-ownership="none">
            <doc xml:space="preserve">The token info to free, or %NULL.</doc>
            <type name="TokenInfo" c:type="GckTokenInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <constant name="URI_FOR_MODULE_WITH_VERSION" value="24" c:type="GCK_URI_FOR_MODULE_WITH_VERSION">
      <doc xml:space="preserve">The URI will match specific version of modules. To be used as a GckUriFlags argument.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="URI_FOR_OBJECT_ON_TOKEN" value="6" c:type="GCK_URI_FOR_OBJECT_ON_TOKEN">
      <doc xml:space="preserve">The URI will match objects on a specific token. To be used as a GckUriFlags argument.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="URI_FOR_OBJECT_ON_TOKEN_AND_MODULE" value="8" c:type="GCK_URI_FOR_OBJECT_ON_TOKEN_AND_MODULE">
      <doc xml:space="preserve">The token inserted into a device with a specific module.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="UriData" c:type="GckUriData" glib:type-name="GckUriData" glib:get-type="gck_uri_data_get_type" c:symbol-prefix="uri_data">
      <doc xml:space="preserve">Information about the contents of a PKCS#11 URI. Various fields may be %NULL
depending on the context that the URI was parsed for.

Since PKCS#11 URIs represent a set which results from the intersections of
all of the URI parts, if @any_recognized is set to %TRUE then usually the URI
should be treated as not matching anything.</doc>
      <field name="any_unrecognized" writable="1">
        <doc xml:space="preserve">whether any parts of the PKCS#11 URI were unsupported or unrecognized.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="module_info" writable="1">
        <doc xml:space="preserve">information about the PKCS#11 modules matching the URI.</doc>
        <type name="ModuleInfo" c:type="GckModuleInfo*"/>
      </field>
      <field name="token_info" writable="1">
        <doc xml:space="preserve">information about the PKCS#11 tokens matching the URI.</doc>
        <type name="TokenInfo" c:type="GckTokenInfo*"/>
      </field>
      <field name="attributes" writable="1">
        <doc xml:space="preserve">information about the PKCS#11 objects matching the URI.</doc>
        <type name="Attributes" c:type="GckAttributes*"/>
      </field>
      <field name="dummy" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <constructor name="new" c:identifier="gck_uri_data_new">
        <doc xml:space="preserve">Allocate a new GckUriData structure. None of the fields
will be set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated GckUriData, free with
         gck_uri_data_free()</doc>
          <type name="UriData" c:type="GckUriData*"/>
        </return-value>
      </constructor>
      <method name="copy" c:identifier="gck_uri_data_copy">
        <doc xml:space="preserve">Copy a #GckUriData</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">newly allocated copy of the uri data</doc>
          <type name="UriData" c:type="GckUriData*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri_data" transfer-ownership="none">
            <doc xml:space="preserve">URI data to copy</doc>
            <type name="UriData" c:type="GckUriData*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gck_uri_data_free">
        <doc xml:space="preserve">Free a #GckUriData.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri_data" transfer-ownership="full">
            <doc xml:space="preserve">URI data to free.</doc>
            <type name="UriData" c:type="GckUriData*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="UriError" glib:type-name="GckUriError" glib:get-type="gck_uri_error_get_type" c:type="GckUriError">
      <doc xml:space="preserve">Various error codes used with PKCS#11 URIs</doc>
      <member name="bad_scheme" value="1" c:identifier="GCK_URI_BAD_SCHEME" glib:nick="bad-scheme" glib:name="GCK_URI_BAD_SCHEME">
        <doc xml:space="preserve">invalid URI scheme</doc>
      </member>
      <member name="bad_encoding" value="2" c:identifier="GCK_URI_BAD_ENCODING" glib:nick="bad-encoding" glib:name="GCK_URI_BAD_ENCODING">
        <doc xml:space="preserve">bad URI encoding</doc>
      </member>
      <member name="bad_syntax" value="3" c:identifier="GCK_URI_BAD_SYNTAX" glib:nick="bad-syntax" glib:name="GCK_URI_BAD_SYNTAX">
        <doc xml:space="preserve">bad URI syntax</doc>
      </member>
      <member name="bad_version" value="4" c:identifier="GCK_URI_BAD_VERSION" glib:nick="bad-version" glib:name="GCK_URI_BAD_VERSION">
        <doc xml:space="preserve">bad URI version component</doc>
      </member>
      <member name="not_found" value="5" c:identifier="GCK_URI_NOT_FOUND" glib:nick="not-found" glib:name="GCK_URI_NOT_FOUND">
        <doc xml:space="preserve">piece of the URI was not found</doc>
      </member>
      <function name="get_quark" c:identifier="gck_uri_error_get_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <bitfield name="UriFlags" glib:type-name="GckUriFlags" glib:get-type="gck_uri_flags_get_type" c:type="GckUriFlags">
      <doc xml:space="preserve">Which parts of the PKCS#11 URI will be parsed or formatted. These can be
combined.</doc>
      <member name="for_object" value="2" c:identifier="GCK_URI_FOR_OBJECT" glib:nick="for-object" glib:name="GCK_URI_FOR_OBJECT">
        <doc xml:space="preserve">the URI will be used to match objects.</doc>
      </member>
      <member name="for_token" value="4" c:identifier="GCK_URI_FOR_TOKEN" glib:nick="for-token" glib:name="GCK_URI_FOR_TOKEN">
        <doc xml:space="preserve">the URI will be used to match tokens.</doc>
      </member>
      <member name="for_module" value="8" c:identifier="GCK_URI_FOR_MODULE" glib:nick="for-module" glib:name="GCK_URI_FOR_MODULE">
        <doc xml:space="preserve">the URI will be used to match modules.</doc>
      </member>
      <member name="with_version" value="16" c:identifier="GCK_URI_WITH_VERSION" glib:nick="with-version" glib:name="GCK_URI_WITH_VERSION">
        <doc xml:space="preserve">the URI has specific version numbers for module and/or token</doc>
      </member>
      <member name="for_any" value="65535" c:identifier="GCK_URI_FOR_ANY" glib:nick="for-any" glib:name="GCK_URI_FOR_ANY">
        <doc xml:space="preserve">parse all recognized components of the URI.</doc>
      </member>
    </bitfield>
    <constant name="VENDOR_CODE" value="1195592448" c:type="GCK_VENDOR_CODE">
      <doc xml:space="preserve">Custom PKCS#11 errors that originate from the gck library, are
based at this error code.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function name="builder_unref" c:identifier="gck_builder_unref" moved-to="Builder.unref">
      <doc xml:space="preserve">Unreferences a builder. If this was the last reference then the builder
is freed.

It is an error to use this function on builders that were allocated on the
stack.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="builder" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the builder</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_get_quark" c:identifier="gck_error_get_quark" moved-to="Error.get_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="list_get_boxed_type" c:identifier="gck_list_get_boxed_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="list_ref_copy" c:identifier="gck_list_ref_copy" introspectable="0">
      <doc xml:space="preserve">Copy a list of GObject based pointers. All objects
in the list will be reffed and the list will be copied.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the copied and
              reffed list, when done, free it with gck_list_unref_free ()</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="GObject.Object"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="reflist" transfer-ownership="none">
          <doc xml:space="preserve">list of GObject reference counted
          objects</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="GObject.Object"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="list_unref_free" c:identifier="gck_list_unref_free" introspectable="0">
      <doc xml:space="preserve">Free a list of GObject based pointers. All objects in the list
will be unreffed and then the list itself will be freed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="reflist" transfer-ownership="none">
          <doc xml:space="preserve">list of Gobject reference counted pointers</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="GObject.Object"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function-macro name="mechanisms_at" c:identifier="gck_mechanisms_at" introspectable="0">
      <doc xml:space="preserve">Get a specific mechanism in a the set.</doc>
      <parameters>
        <parameter name="a">
          <doc xml:space="preserve">A GckMechanisms set.</doc>
        </parameter>
        <parameter name="i">
          <doc xml:space="preserve">The index of a mechanism</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="mechanisms_check" c:identifier="gck_mechanisms_check" introspectable="0">
      <doc xml:space="preserve">Check whether all the mechanism types are in the list.

The arguments should be a list of CKM_XXX mechanism types. The last argument
should be GCK_INVALID.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether the mechanism is in the list or not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mechanisms" transfer-ownership="none">
          <doc xml:space="preserve">A list of mechanisms, perhaps
             retrieved from gck_slot_get_mechanisms().</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gulong"/>
          </array>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">A list of mechanism types followed by GCK_INVALID.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="mechanisms_length" c:identifier="gck_mechanisms_length" introspectable="0">
      <doc xml:space="preserve">Get the number of GckMechanismInfo in the set.</doc>
      <parameters>
        <parameter name="a">
          <doc xml:space="preserve">A GckMechanisms set.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="message_from_rv" c:identifier="gck_message_from_rv">
      <doc xml:space="preserve">Get a message for a PKCS#11 return value or error code. Do not
pass `CKR_OK` or other non-errors to this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The user readable message.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="rv" transfer-ownership="none">
          <doc xml:space="preserve">The PKCS#11 return value to get a message for.</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="modules_enumerate_objects" c:identifier="gck_modules_enumerate_objects">
      <doc xml:space="preserve">Setup an enumerator for listing matching objects on the modules.

This call will not block but will return an enumerator immediately.

If the @attrs [struct@Attributes] is floating, it is consumed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new enumerator, which should be released
with g_object_unref().</doc>
        <type name="Enumerator" c:type="GckEnumerator*"/>
      </return-value>
      <parameters>
        <parameter name="modules" transfer-ownership="none">
          <doc xml:space="preserve">The modules</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Module"/>
          </type>
        </parameter>
        <parameter name="attrs" transfer-ownership="none">
          <doc xml:space="preserve">attributes that the objects must have, or empty for all objects</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </parameter>
        <parameter name="session_options" transfer-ownership="none">
          <doc xml:space="preserve">Options from GckSessionOptions</doc>
          <type name="SessionOptions" c:type="GckSessionOptions"/>
        </parameter>
      </parameters>
    </function>
    <function name="modules_enumerate_uri" c:identifier="gck_modules_enumerate_uri" throws="1">
      <doc xml:space="preserve">Enumerate objects that match a URI.

This call will not block. Use the [class@Enumerator] functions in order to
get at the actual objects that match.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GckEnumerator, or %NULL if an error occurs.</doc>
        <type name="Enumerator" c:type="GckEnumerator*"/>
      </return-value>
      <parameters>
        <parameter name="modules" transfer-ownership="none">
          <doc xml:space="preserve">The modules</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Module"/>
          </type>
        </parameter>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">The URI that the enumerator will match</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="session_options" transfer-ownership="none">
          <doc xml:space="preserve">Options from GckSessionOptions</doc>
          <type name="SessionOptions" c:type="GckSessionOptions"/>
        </parameter>
      </parameters>
    </function>
    <function name="modules_get_slots" c:identifier="gck_modules_get_slots">
      <doc xml:space="preserve">Get a list of slots for across all of the modules.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A list of #GckSlot
objects, which should be freed with gck_list_unref_free().</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Slot"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="modules" transfer-ownership="none">
          <doc xml:space="preserve">The modules</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Module"/>
          </type>
        </parameter>
        <parameter name="token_present" transfer-ownership="none">
          <doc xml:space="preserve">Whether to only list slots with token present</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="modules_initialize_registered" c:identifier="gck_modules_initialize_registered" throws="1">
      <doc xml:space="preserve">Load and initialize all the registered modules.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A newly allocated list
of #GckModule objects, which should be released with gck_list_unref_free().</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Module"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="modules_initialize_registered_async" c:identifier="gck_modules_initialize_registered_async">
      <doc xml:space="preserve">Load and initialize all the registered modules asynchronously.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
          <doc xml:space="preserve">a callback which will be called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="modules_initialize_registered_finish" c:identifier="gck_modules_initialize_registered_finish" throws="1">
      <doc xml:space="preserve">Finishes the asynchronous operation to initialize the registered
PKCS#11 modules.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a list of newly
initialized #GckModule objects</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Module"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">the asynchronous result</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="modules_object_for_uri" c:identifier="gck_modules_object_for_uri" throws="1">
      <doc xml:space="preserve">Find an object that matches a URI.

This call can block. Use [func@modules_enumerate_uri] for a non-blocking
version.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">A new #GckObject which should be released with
g_object_unref(), or %NULL if no matching object was found.</doc>
        <type name="Object" c:type="GckObject*"/>
      </return-value>
      <parameters>
        <parameter name="modules" transfer-ownership="none">
          <doc xml:space="preserve">The modules</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Module"/>
          </type>
        </parameter>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">The URI the objects must match</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="session_options" transfer-ownership="none">
          <doc xml:space="preserve">Options from GckSessionOptions</doc>
          <type name="SessionOptions" c:type="GckSessionOptions"/>
        </parameter>
      </parameters>
    </function>
    <function name="modules_objects_for_uri" c:identifier="gck_modules_objects_for_uri" throws="1">
      <doc xml:space="preserve">Find objects that match a URI.

This call can block. Use [func@modules_enumerate_uri] for a non-blocking
version.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A list of #GckObject which
should be released with gck_list_unref_free(), or %NULL if no matching object
was found.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Object"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="modules" transfer-ownership="none">
          <doc xml:space="preserve">The modules</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Module"/>
          </type>
        </parameter>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">The URI the objects must match</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="session_options" transfer-ownership="none">
          <doc xml:space="preserve">Options from GckSessionOptions</doc>
          <type name="SessionOptions" c:type="GckSessionOptions"/>
        </parameter>
      </parameters>
    </function>
    <function name="modules_token_for_uri" c:identifier="gck_modules_token_for_uri" throws="1">
      <doc xml:space="preserve">Lookup a token that matches the URI.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A newly allocated #GckSlot or %NULL if no such
token was found.</doc>
        <type name="Slot" c:type="GckSlot*"/>
      </return-value>
      <parameters>
        <parameter name="modules" transfer-ownership="none">
          <doc xml:space="preserve">The modules</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Module"/>
          </type>
        </parameter>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">The URI that the token must match</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="modules_tokens_for_uri" c:identifier="gck_modules_tokens_for_uri" throws="1">
      <doc xml:space="preserve">Lookup a token that matches the URI.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A list of newly allocated
#GckSlot objects. Use gck_list_unref_free() to release the list once you're
done with it.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Slot"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="modules" transfer-ownership="none">
          <doc xml:space="preserve">The modules</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Module"/>
          </type>
        </parameter>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">The URI that the token must match</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="objects_from_handle_array" c:identifier="gck_objects_from_handle_array">
      <doc xml:space="preserve">Initialize a list of GckObject from raw PKCS#11 handles. The handles argument must contain
contiguous CK_OBJECT_HANDLE handles in an array.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The list of #GckObject
         objects. You should use gck_list_unref_free() when done with this
         list.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Object"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="session" transfer-ownership="none">
          <doc xml:space="preserve">The session for these objects</doc>
          <type name="Session" c:type="GckSession*"/>
        </parameter>
        <parameter name="object_handles" transfer-ownership="none">
          <doc xml:space="preserve">The raw object handles.</doc>
          <array length="2" zero-terminated="0" c:type="gulong*">
            <type name="gulong" c:type="gulong"/>
          </array>
        </parameter>
        <parameter name="n_object_handles" transfer-ownership="none">
          <doc xml:space="preserve">The number of raw object handles.</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="slots_enumerate_objects" c:identifier="gck_slots_enumerate_objects">
      <doc xml:space="preserve">Setup an enumerator for listing matching objects on the slots.

If the @match #GckAttributes is floating, it is consumed.

This call will not block but will return an enumerator immediately.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new enumerator</doc>
        <type name="Enumerator" c:type="GckEnumerator*"/>
      </return-value>
      <parameters>
        <parameter name="slots" transfer-ownership="none">
          <doc xml:space="preserve">a list of #GckSlot to enumerate objects on.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Slot"/>
          </type>
        </parameter>
        <parameter name="match" transfer-ownership="none">
          <doc xml:space="preserve">attributes that the objects must match, or empty for all objects</doc>
          <type name="Attributes" c:type="GckAttributes*"/>
        </parameter>
        <parameter name="options" transfer-ownership="none">
          <doc xml:space="preserve">options for opening a session</doc>
          <type name="SessionOptions" c:type="GckSessionOptions"/>
        </parameter>
      </parameters>
    </function>
    <function name="string_from_chars" c:identifier="gck_string_from_chars" introspectable="0">
      <doc xml:space="preserve">Create a string from a set of PKCS#11 characters. This is
similar to [func@GLib.strndup], except for that it also strips trailing
spaces. These space padded strings are often used in PKCS#11
structures.

If the space padded string is filled with null characters then
this function will return %NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The null terminated string.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">The character data to turn into a null terminated string.</doc>
          <type name="guint8" c:type="const guchar*"/>
        </parameter>
        <parameter name="max" transfer-ownership="none">
          <doc xml:space="preserve">The maximum length of the charater data.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="string_to_chars" c:identifier="gck_string_to_chars" introspectable="0">
      <doc xml:space="preserve">Create a space padded PKCS#11 string from a null terminated string.
The string must be shorter than the buffer or %FALSE will be
returned.

If a %NULL string is passed, then the space padded string will be
set to zero characters.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The null terminated string.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">The character buffer to place string into.</doc>
          <type name="guint8" c:type="guchar*"/>
        </parameter>
        <parameter name="max" transfer-ownership="none">
          <doc xml:space="preserve">The maximum length of the charater buffer.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">The string to place in the buffer.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_build" c:identifier="gck_uri_build">
      <doc xml:space="preserve">Build a PKCS#11 URI. The various parts relevant to the flags
specified will be used to build the URI.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string containing a PKCS#11 URI.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="uri_data" transfer-ownership="none">
          <doc xml:space="preserve">the info to build the URI from.</doc>
          <type name="UriData" c:type="GckUriData*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">The context that the URI is for</doc>
          <type name="UriFlags" c:type="GckUriFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_error_get_quark" c:identifier="gck_uri_error_get_quark" moved-to="UriError.get_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="uri_parse" c:identifier="gck_uri_parse" throws="1">
      <doc xml:space="preserve">Parse a PKCS#11 URI for use in a given context.

The result will contain the fields that are relevant for
the given context. See #GckUriData  for more info.
Other fields will be set to %NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated #GckUriData; which should be
         freed with gck_uri_data_free()</doc>
        <type name="UriData" c:type="GckUriData*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the URI to parse.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">the context in which the URI will be used.</doc>
          <type name="UriFlags" c:type="GckUriFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_to_boolean" c:identifier="gck_value_to_boolean">
      <doc xml:space="preserve">Convert `CK_BBOOL` type memory to a boolean.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether the conversion was successful.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">memory to convert</doc>
          <array length="1" zero-terminated="0" c:type="const guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">length of memory</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="result" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">A location to store the result</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_to_ulong" c:identifier="gck_value_to_ulong">
      <doc xml:space="preserve">Convert `CK_ULONG` type memory to a boolean.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether the conversion was successful.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">memory to convert</doc>
          <array length="1" zero-terminated="0" c:type="const guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">length of memory</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="result" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">A location to store the result</doc>
          <type name="gulong" c:type="gulong*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
