<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="nice"/>
  <namespace name="Nice" version="0.1" shared-library="libnice.so.10" c:identifier-prefixes="Nice" c:symbol-prefixes="nice">
    <function-macro name="AGENT" c:identifier="NICE_AGENT" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AGENT_CLASS" c:identifier="NICE_AGENT_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AGENT_GET_CLASS" c:identifier="NICE_AGENT_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="AGENT_MAX_REMOTE_CANDIDATES" value="25" c:type="NICE_AGENT_MAX_REMOTE_CANDIDATES">
      <doc xml:space="preserve">A hard limit for the number of remote candidates. This
limit is enforced to protect against malevolent remote
clients.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Address" c:type="NiceAddress">
      <doc xml:space="preserve">The #NiceAddress structure that represents an IPv4 or IPv6 address.</doc>
      <union name="s" c:type="s">
        <field name="addr" writable="1">
          <type name="gpointer" c:type="sockaddr"/>
        </field>
        <field name="ip4" writable="1">
          <type name="gpointer" c:type="sockaddr_in"/>
        </field>
        <field name="ip6" writable="1">
          <type name="gpointer" c:type="sockaddr_in6"/>
        </field>
      </union>
      <method name="copy_to_sockaddr" c:identifier="nice_address_copy_to_sockaddr">
        <doc xml:space="preserve">Fills the sockaddr structure @sin with the address contained in @addr</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to query</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
          <parameter name="sin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The sockaddr to fill</doc>
            <type name="gpointer" c:type="sockaddr*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="nice_address_dup" introspectable="0">
        <doc xml:space="preserve">Creates a new #NiceAddress with the same address as @addr</doc>
        <return-value>
          <doc xml:space="preserve">The new #NiceAddress</doc>
          <type name="Address" c:type="NiceAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to dup</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="nice_address_equal">
        <doc xml:space="preserve">Compares two #NiceAddress structures to see if they contain the same address
and the same port.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @a and @b are the same address, %FALSE if they are different</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">First #NiceAddress to compare</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">Second #NiceAddress to compare</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal_no_port" c:identifier="nice_address_equal_no_port" version="0.1.8">
        <doc xml:space="preserve">Compares two #NiceAddress structures to see if they contain the same address,
ignoring the port.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @a and @b are the same address, %FALSE if they
are different</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">First #NiceAddress to compare</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">Second #NiceAddress to compare</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="nice_address_free">
        <doc xml:space="preserve">Frees a #NiceAddress created with nice_address_new() or nice_address_dup()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to free</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port" c:identifier="nice_address_get_port">
        <doc xml:space="preserve">Retreive the port of @addr</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The port of @addr</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to query</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="nice_address_init">
        <doc xml:space="preserve">Initialize a #NiceAddress into an undefined address</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to init</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ip_version" c:identifier="nice_address_ip_version">
        <doc xml:space="preserve">Returns the IP version of the address</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">4 for IPv4, 6 for IPv6 and 0 for undefined address</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to query</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_private" c:identifier="nice_address_is_private">
        <doc xml:space="preserve">Verifies if the address in @addr is a private address or not</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @addr is a private address, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to query</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_valid" c:identifier="nice_address_is_valid">
        <doc xml:space="preserve">Validate whether the #NiceAddress @addr is a valid IPv4 or IPv6 address</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @addr is valid, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to query</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_from_sockaddr" c:identifier="nice_address_set_from_sockaddr">
        <doc xml:space="preserve">Sets an IPv4 or IPv6 address from the sockaddr structure @sin</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to modify</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
          <parameter name="sin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The sockaddr to set</doc>
            <type name="gpointer" c:type="const sockaddr*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_string" c:identifier="nice_address_set_from_string">
        <doc xml:space="preserve">Sets an IPv4 or IPv6 address from the string @str</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to modify</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">The string to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ipv4" c:identifier="nice_address_set_ipv4">
        <doc xml:space="preserve">Set @addr to an IPv4 address using the data from @addr_ipv4

 &lt;note&gt;
  &lt;para&gt;
   This function will reset the port to 0, so make sure you call it before
   nice_address_set_port()
  &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to modify</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
          <parameter name="addr_ipv4" transfer-ownership="none">
            <doc xml:space="preserve">The IPv4 address</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ipv6" c:identifier="nice_address_set_ipv6">
        <doc xml:space="preserve">Set @addr to an IPv6 address using the data from @addr_ipv6

 &lt;note&gt;
  &lt;para&gt;
   This function will reset the port to 0, so make sure you call it before
   nice_address_set_port()
  &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to modify</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
          <parameter name="addr_ipv6" transfer-ownership="none">
            <doc xml:space="preserve">The IPv6 address</doc>
            <type name="guint8" c:type="const guchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_port" c:identifier="nice_address_set_port">
        <doc xml:space="preserve">Set the port of @addr to @port</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to modify</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">The port to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="nice_address_to_string">
        <doc xml:space="preserve">Transforms the address @addr into a human readable string</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to query</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
          <parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve">The string to fill</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="nice_address_new" introspectable="0">
        <doc xml:space="preserve">Create a new #NiceAddress with undefined address
You must free it with nice_address_free()</doc>
        <return-value>
          <doc xml:space="preserve">The new #NiceAddress</doc>
          <type name="Address" c:type="NiceAddress*"/>
        </return-value>
      </function>
    </record>
    <class name="Agent" c:symbol-prefix="agent" c:type="NiceAgent" parent="GObject.Object" glib:type-name="NiceAgent" glib:get-type="nice_agent_get_type" glib:type-struct="AgentClass">
      <doc xml:space="preserve">The #NiceAgent is the main GObject of the libnice library and represents
the ICE agent.</doc>
      <constructor name="new" c:identifier="nice_agent_new">
        <doc xml:space="preserve">Create a new #NiceAgent.
The returned object must be freed with g_object_unref()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new agent GObject</doc>
          <type name="Agent" c:type="NiceAgent*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve">The Glib Mainloop Context to use for timers</doc>
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
          <parameter name="compat" transfer-ownership="none">
            <doc xml:space="preserve">The compatibility mode of the agent</doc>
            <type name="Compatibility" c:type="NiceCompatibility"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full" c:identifier="nice_agent_new_full" version="0.1.15">
        <doc xml:space="preserve">Create a new #NiceAgent with parameters that must be be defined at
construction time.
The returned object must be freed with g_object_unref()
&lt;para&gt; See also: #NiceNominationMode and #NiceAgentOption&lt;/para&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new agent GObject</doc>
          <type name="Agent" c:type="NiceAgent*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve">The Glib Mainloop Context to use for timers</doc>
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
          <parameter name="compat" transfer-ownership="none">
            <doc xml:space="preserve">The compatibility mode of the agent</doc>
            <type name="Compatibility" c:type="NiceCompatibility"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags to set the properties</doc>
            <type name="AgentOption" c:type="NiceAgentOption"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_reliable" c:identifier="nice_agent_new_reliable" version="0.0.11">
        <doc xml:space="preserve">Create a new #NiceAgent in reliable mode. If the connectivity is established
through ICE-UDP, then a #PseudoTcpSocket will be transparently used to
ensure reliability of the messages.
The returned object must be freed with g_object_unref()
&lt;para&gt; See also: #NiceAgent::reliable-transport-writable &lt;/para&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new agent GObject</doc>
          <type name="Agent" c:type="NiceAgent*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve">The Glib Mainloop Context to use for timers</doc>
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
          <parameter name="compat" transfer-ownership="none">
            <doc xml:space="preserve">The compatibility mode of the agent</doc>
            <type name="Compatibility" c:type="NiceCompatibility"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_local_address" c:identifier="nice_agent_add_local_address">
        <doc xml:space="preserve">Add a local address from which to derive local host candidates for
candidate gathering.
&lt;para&gt;
Since 0.0.5, if this method is not called, libnice will automatically
discover the local addresses available
&lt;/para&gt;

See also: nice_agent_gather_candidates()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on fatal (memory allocation) errors</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The address to listen to
If the port is 0, then a random port will be chosen by the system</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_stream" c:identifier="nice_agent_add_stream">
        <doc xml:space="preserve">Adds a data stream to @agent containing @n_components components. The
returned stream ID is guaranteed to be positive on success.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The ID of the new stream, 0 on failure</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve">The number of components to add to the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="attach_recv" c:identifier="nice_agent_attach_recv" introspectable="0">
        <doc xml:space="preserve">Attaches the stream's component's sockets to the Glib Mainloop Context in
order to be notified whenever data becomes available for a component,
and to enable #NiceAgent to receive STUN messages (during the
establishment of ICE connectivity).

This must not be used in combination with nice_agent_recv_messages() (or
#NiceIOStream or #NiceInputStream) on the same stream/component pair.

Calling nice_agent_attach_recv() with a %NULL @func will detach any existing
callback and cause reception to be paused for the given stream/component
pair. You must iterate the previously specified #GMainContext sufficiently to
ensure all pending I/O callbacks have been received before calling this
function to unset @func, otherwise data loss of received packets may occur.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if the stream or component IDs are invalid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve">The Glib Mainloop Context to use for listening on the component</doc>
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="4">
            <doc xml:space="preserve">The callback function to be called when data is received on
the stream's component (will not be called for STUN messages that
should be handled by #NiceAgent itself)</doc>
            <type name="AgentRecvFunc" c:type="NiceAgentRecvFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data associated with the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async" c:identifier="nice_agent_close_async" version="0.1.16">
        <doc xml:space="preserve">Asynchronously closes resources the agent has allocated on remote servers.

The agent will call the callback in the current #GMainContext in
which this function is called. The #GAsyncResult in the callback
can be ignored as this operation never fails.

Calling this function before freeing the agent makes sure the allocated relay
ports aren't left behind on TURN server but properly removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="1">
            <doc xml:space="preserve">A callback that will be called when the closing is
 complete</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="callback_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A pointer that will be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="forget_relays" c:identifier="nice_agent_forget_relays" version="0.1.6">
        <doc xml:space="preserve">Forget all the relay servers previously added using
nice_agent_set_relay_info(). Currently connected streams will keep
using the relay as long as they have not been restarted and haven't
succesfully negotiated a different path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the component could not be found, %TRUE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="gather_candidates" c:identifier="nice_agent_gather_candidates">
        <doc xml:space="preserve">Allocate and start listening on local candidate ports and start the remote
candidate gathering process.
Once done, #NiceAgent::candidate-gathering-done is called for the stream.
As soon as this function is called, #NiceAgent::new-candidate signals may be
emitted, even before this function returns.

nice_agent_get_local_candidates() will only return non-empty results after
calling this function.

&lt;para&gt;See also: nice_agent_add_local_address()&lt;/para&gt;
&lt;para&gt;See also: nice_agent_set_port_range()&lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the stream ID is invalid or if a host candidate couldn't
be allocated on the requested interfaces/ports; %TRUE otherwise

 &lt;note&gt;
   &lt;para&gt;
    Local addresses can be previously set with nice_agent_add_local_address()
  &lt;/para&gt;
  &lt;para&gt;
    Since 0.0.5, If no local address was previously added, then the nice agent
    will automatically detect the local address using
    nice_interfaces_get_local_ips()
   &lt;/para&gt;
 &lt;/note&gt;</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to start</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="generate_local_candidate_sdp" c:identifier="nice_agent_generate_local_candidate_sdp" version="0.1.4">
        <doc xml:space="preserve">Generate an SDP string representing a local candidate.

&lt;para&gt;See also: nice_agent_parse_remote_candidate_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_stream_sdp() &lt;/para&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A string representing the SDP for the candidate. Must be freed
with g_free() once done.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="candidate" transfer-ownership="none">
            <doc xml:space="preserve">The candidate to generate</doc>
            <type name="Candidate" c:type="NiceCandidate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="generate_local_sdp" c:identifier="nice_agent_generate_local_sdp" version="0.1.4">
        <doc xml:space="preserve">Generate an SDP string containing the local candidates and credentials for
all streams and components in the agent.

 &lt;note&gt;
   &lt;para&gt;
     The SDP will not contain any codec lines and the 'm' line will not list
     any payload types.
   &lt;/para&gt;
   &lt;para&gt;
    It is highly recommended to set names on the streams prior to calling this
    function. Unnamed streams will show up as '-' in the 'm' line, but the SDP
    will not be parseable with nice_agent_parse_remote_sdp() if a stream is
    unnamed.
   &lt;/para&gt;
   &lt;para&gt;
     The default candidate in the SDP will be selected based on the lowest
     priority candidate for the first component.
   &lt;/para&gt;
 &lt;/note&gt;

&lt;para&gt;See also: nice_agent_set_stream_name() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_stream_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_candidate_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_get_default_local_candidate() &lt;/para&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A string representing the local SDP. Must be freed with g_free()
once done.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="generate_local_stream_sdp" c:identifier="nice_agent_generate_local_stream_sdp" version="0.1.4">
        <doc xml:space="preserve">Generate an SDP string containing the local candidates and credentials
for a stream.

 &lt;note&gt;
   &lt;para&gt;
     The SDP will not contain any codec lines and the 'm' line will not list
     any payload types.
   &lt;/para&gt;
   &lt;para&gt;
    It is highly recommended to set the name of the stream prior to calling this
    function. Unnamed streams will show up as '-' in the 'm' line.
   &lt;/para&gt;
   &lt;para&gt;
     The default candidate in the SDP will be selected based on the lowest
     priority candidate.
   &lt;/para&gt;
 &lt;/note&gt;

&lt;para&gt;See also: nice_agent_set_stream_name() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_stream_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_candidate_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_get_default_local_candidate() &lt;/para&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A string representing the local SDP for the stream. Must be freed
with g_free() once done.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="include_non_ice" transfer-ownership="none">
            <doc xml:space="preserve">Whether or not to include non ICE specific lines
(m=, c= and a=rtcp: lines)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_component_state" c:identifier="nice_agent_get_component_state" version="0.1.8">
        <doc xml:space="preserve">Retrieves the current state of a component.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NiceComponentState of the component and
%NICE_COMPONENT_STATE_FAILED if the component was invalid.</doc>
          <type name="ComponentState" c:type="NiceComponentState"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_default_local_candidate" c:identifier="nice_agent_get_default_local_candidate">
        <doc xml:space="preserve">This helper function will return the recommended default candidate to be
used for non-ICE compatible clients. This will usually be the candidate
with the lowest priority, since it will be the longest path but the one with
the most chances of success.
&lt;note&gt;
     &lt;para&gt;
     This function is only useful in order to manually generate the
     local SDP
     &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The candidate to be used as the default candidate, or %NULL in case
of error. Must be freed with nice_candidate_free() once done.</doc>
          <type name="Candidate" c:type="NiceCandidate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_io_stream" c:identifier="nice_agent_get_io_stream" version="0.1.5">
        <doc xml:space="preserve">Gets a #GIOStream wrapper around the given stream and component in
@agent. The I/O stream will be valid for as long as @stream_id is valid.
The #GInputStream and #GOutputStream implement #GPollableInputStream and
#GPollableOutputStream.

This function may only be called on reliable #NiceAgents. It is a
programming error to try and create an I/O stream wrapper for an
unreliable stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GIOStream.</doc>
          <type name="Gio.IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">A #NiceAgent</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to wrap</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component to wrap</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_local_candidates" c:identifier="nice_agent_get_local_candidates">
        <doc xml:space="preserve">Retrieve from the agent the list of all local candidates
for a stream's component

 &lt;note&gt;
   &lt;para&gt;
     The caller owns the returned GSList as well as the candidates contained
     within it.
     To get full results, the client should wait for the
     #NiceAgent::candidate-gathering-done signal.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSList of
#NiceCandidate objects representing the local candidates of @agent</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Candidate"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_local_credentials" c:identifier="nice_agent_get_local_credentials">
        <doc xml:space="preserve">Gets the local credentials for stream @stream_id. This may be called any time
after creating a stream using nice_agent_add_stream().

An error will be returned if this is called for a non-existent stream, or if
either of @ufrag or @pwd are %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="ufrag" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for a nul-terminated string
containing an ICE username fragment; must be freed with g_free()</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="pwd" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for a nul-terminated string
containing an ICE password; must be freed with g_free()</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_remote_candidates" c:identifier="nice_agent_get_remote_candidates">
        <doc xml:space="preserve">Get a list of the remote candidates set on a stream's component

 &lt;note&gt;
   &lt;para&gt;
     The caller owns the returned GSList as well as the candidates contained
     within it.
   &lt;/para&gt;
   &lt;para&gt;
     The list of remote candidates can change during processing.
     The client should register for the #NiceAgent::new-remote-candidate signal
     to get notified of new remote candidates.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSList of
#NiceCandidates objects representing the remote candidates set on the @agent</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Candidate"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_selected_pair" c:identifier="nice_agent_get_selected_pair">
        <doc xml:space="preserve">Retreive the selected candidate pair for media transmission
for a given stream's component.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if there is no selected candidate pair</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="local" transfer-ownership="none">
            <doc xml:space="preserve">The local selected candidate</doc>
            <type name="Candidate" c:type="NiceCandidate**"/>
          </parameter>
          <parameter name="remote" transfer-ownership="none">
            <doc xml:space="preserve">The remote selected candidate</doc>
            <type name="Candidate" c:type="NiceCandidate**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_selected_socket" c:identifier="nice_agent_get_selected_socket" version="0.1.5">
        <doc xml:space="preserve">Retreive the local socket associated with the selected candidate pair
for media transmission for a given stream's component.

This is useful for adding ICE support to legacy applications that already
have a protocol that maintains a connection. If the socket is duplicated
before unrefing the agent, the application can take over and continue to use
it. New applications are encouraged to use the built in libnice stream
handling instead and let libnice handle the connection maintenance.

Users of this method are encouraged to not use a TURN relay or any kind
of proxy, as in this case, the socket will not be available to the
application because the packets are encapsulated.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">pointer to the #GSocket, or %NULL if
there is no selected candidate or if the selected candidate is a relayed
candidate.</doc>
          <type name="Gio.Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_sockets" c:identifier="nice_agent_get_sockets" version="0.1.17">
        <doc xml:space="preserve">Each component can have multiple sockets, this is an API to retrieve them all
to be able to set properties. Most of the sockets for a component are created when
calling nice_agent_gather_candidates(), so this API should be called right after to
able to set properties on the sockets before they are used.

These sockets can be a mix of UDP &amp; TCP sockets depending on the compatibility mode
and options that have been set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">An array
containing all of the sockets for this component. Free with
g_ptr_array_unref() when done.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Gio.Socket"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_stream_name" c:identifier="nice_agent_get_stream_name" version="0.1.4">
        <doc xml:space="preserve">This function will return the name assigned to a stream.

&lt;para&gt;See also: nice_agent_set_stream_name()&lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The name of the stream. The name is only valid while the stream
exists or until it changes through a call to nice_agent_set_stream_name().</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to change</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_remote_candidate_sdp" c:identifier="nice_agent_parse_remote_candidate_sdp" version="0.1.4">
        <doc xml:space="preserve">Parse an SDP string and extracts the candidate from it.

&lt;para&gt;See also: nice_agent_generate_local_candidate_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_stream_sdp() &lt;/para&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The parsed candidate or %NULL if there was an error.</doc>
          <type name="Candidate" c:type="NiceCandidate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream the candidate belongs to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="sdp" transfer-ownership="none">
            <doc xml:space="preserve">The remote SDP to parse</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_remote_sdp" c:identifier="nice_agent_parse_remote_sdp" version="0.1.4">
        <doc xml:space="preserve">Parse an SDP string and extracts candidates and credentials from it and sets
them on the agent.

&lt;para&gt;See also: nice_agent_set_stream_name() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_stream_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_candidate_sdp() &lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of candidates added, negative on errors</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="sdp" transfer-ownership="none">
            <doc xml:space="preserve">The remote SDP to parse</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_remote_stream_sdp" c:identifier="nice_agent_parse_remote_stream_sdp" version="0.1.4">
        <doc xml:space="preserve">Parse an SDP string representing a single stream and extracts candidates
and credentials from it.

&lt;para&gt;See also: nice_agent_generate_local_stream_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_candidate_sdp() &lt;/para&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GSList of
candidates parsed from the SDP, or %NULL in case of errors</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Candidate"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to parse</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="sdp" transfer-ownership="none">
            <doc xml:space="preserve">The remote SDP to parse</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="ufrag" transfer-ownership="none">
            <doc xml:space="preserve">Pointer to store the ice ufrag if non %NULL. Must be freed with
g_free() after use</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="pwd" transfer-ownership="none">
            <doc xml:space="preserve">Pointer to store the ice password if non %NULL. Must be freed with
g_free() after use</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="peer_candidate_gathering_done" c:identifier="nice_agent_peer_candidate_gathering_done" version="0.1.16">
        <doc xml:space="preserve">Notifies the agent that the remote peer has concluded candidate gathering and
thus no more remote candidates are expected to arrive for @stream_id.

This will allow the stream components without a successful connectivity check
to stop waiting for more candidates to come and finally transit into
%NICE_COMPONENT_STATE_FAILED.

Calling the function has an effect only when #NiceAgent:trickle-ice is %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the stream could not be found, %TRUE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="recv" c:identifier="nice_agent_recv" version="0.1.5" throws="1">
        <doc xml:space="preserve">A single-message version of nice_agent_recv_messages().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written to @buf on success (guaranteed to be
greater than 0 unless @buf_len is 0), 0 if in reliable mode and the remote
peer closed the stream, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">a #NiceAgent</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the stream to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the component to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buf" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">caller-allocated buffer
to write the received data into, of length at least @buf_len</doc>
            <array length="3" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="buf_len" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">length of @buf</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable to allow the operation to be
cancelled from another thread, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="recv_messages" c:identifier="nice_agent_recv_messages" version="0.1.5" throws="1">
        <doc xml:space="preserve">Block on receiving data from the given stream/component combination on
@agent, returning only once exactly @n_messages messages have been received
and written into @messages, the stream is closed by the other end or by
calling nice_agent_remove_stream(), or @cancellable is cancelled.

Any STUN packets received will not be added to @messages; instead,
they'll be passed for processing to #NiceAgent itself. Since #NiceAgent
does not poll for messages on its own, it's therefore essential to keep
calling this function for ICE connection establishment to work.

In the non-error case, in reliable mode, this will block until all buffers in
all @n_messages have been filled with received data (i.e. @messages is
treated as a large, flat array of buffers). In non-reliable mode, it will
block until @n_messages messages have been received, each of which does not
have to fill all the buffers in its #NiceInputMessage. In the non-reliable
case, each #NiceInputMessage must have enough buffers to contain an entire
message (65536 bytes), or any excess data may be silently dropped.

For each received message, #NiceInputMessage::length will be set to the
number of valid bytes stored in the message&#x2019;s buffers. The bytes are stored
sequentially in the buffers; there are no gaps apart from at the end of the
buffer array (in non-reliable mode). If non-%NULL on input,
#NiceInputMessage::from will have the address of the sending peer stored in
it. The base addresses, sizes, and number of buffers in each message will not
be modified in any case.

This must not be used in combination with nice_agent_attach_recv() on the
same stream/component pair.

If the stream/component pair doesn&#x2019;t exist, or if a suitable candidate socket
hasn&#x2019;t yet been selected for it, a %G_IO_ERROR_BROKEN_PIPE error will be
returned. A %G_IO_ERROR_CANCELLED error will be returned if the operation was
cancelled. %G_IO_ERROR_FAILED will be returned for other errors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of valid messages written to @messages on success
(guaranteed to be greater than 0 unless @n_messages is 0), 0 if the remote
peer closed the stream, or -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">a #NiceAgent</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the stream to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the component to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="messages" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">caller-allocated
array of #NiceInputMessages to write the received messages into, of length at
least @n_messages</doc>
            <array length="3" zero-terminated="0" c:type="NiceInputMessage*">
              <type name="InputMessage" c:type="NiceInputMessage"/>
            </array>
          </parameter>
          <parameter name="n_messages" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">number of entries in @messages</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable to allow the operation to be
cancelled from another thread, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="recv_messages_nonblocking" c:identifier="nice_agent_recv_messages_nonblocking" version="0.1.5" throws="1">
        <doc xml:space="preserve">Try to receive data from the given stream/component combination on @agent,
without blocking. If receiving data would block, -1 is returned and
%G_IO_ERROR_WOULD_BLOCK is set in @error. If any other error occurs, -1 is
returned and @error is set accordingly. Otherwise, 0 is returned if (and only
if) @n_messages is 0. In all other cases, the number of valid messages stored
in @messages is returned, and will be greater than 0.

This function behaves similarly to nice_agent_recv_messages(), except that it
will not block on filling (in reliable mode) or receiving (in non-reliable
mode) exactly @n_messages messages. In reliable mode, it will receive bytes
into @messages until it would block; in non-reliable mode, it will receive
messages until it would block.

Any STUN packets received will not be added to @messages; instead,
they'll be passed for processing to #NiceAgent itself. Since #NiceAgent
does not poll for messages on its own, it's therefore essential to keep
calling this function for ICE connection establishment to work.

As this function is non-blocking, @cancellable is included only for parity
with nice_agent_recv_messages(). If @cancellable is cancelled before this
function is called, a %G_IO_ERROR_CANCELLED error will be returned
immediately.

This must not be used in combination with nice_agent_attach_recv() on the
same stream/component pair.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of valid messages written to @messages on success
(guaranteed to be greater than 0 unless @n_messages is 0), 0 if in reliable
mode and the remote peer closed the stream, or -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">a #NiceAgent</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the stream to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the component to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="messages" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">caller-allocated
array of #NiceInputMessages to write the received messages into, of length at
least @n_messages</doc>
            <array length="3" zero-terminated="0" c:type="NiceInputMessage*">
              <type name="InputMessage" c:type="NiceInputMessage"/>
            </array>
          </parameter>
          <parameter name="n_messages" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">number of entries in @messages</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable to allow the operation to be
cancelled from another thread, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="recv_nonblocking" c:identifier="nice_agent_recv_nonblocking" version="0.1.5" throws="1">
        <doc xml:space="preserve">A single-message version of nice_agent_recv_messages_nonblocking().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes received into @buf on success (guaranteed to be
greater than 0 unless @buf_len is 0), 0 if in reliable mode and the remote
peer closed the stream, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">a #NiceAgent</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the stream to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the component to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buf" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">caller-allocated buffer
to write the received data into, of length at least @buf_len</doc>
            <array length="3" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="buf_len" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">length of @buf</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable to allow the operation to be
cancelled from another thread, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_stream" c:identifier="nice_agent_remove_stream">
        <doc xml:space="preserve">Remove and free a previously created data stream from @agent. If any I/O
streams have been created using nice_agent_get_io_stream(), they should be
closed completely using g_io_stream_close() before this is called, or they
will get broken pipe errors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="restart" c:identifier="nice_agent_restart">
        <doc xml:space="preserve">Restarts the session as defined in ICE draft 19. This function
needs to be called both when initiating (ICE spec section 9.1.1.1.
"ICE Restarts"), as well as when reacting (spec section 9.2.1.1.
"Detecting ICE Restart") to a restart.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="restart_stream" c:identifier="nice_agent_restart_stream" version="0.1.6">
        <doc xml:space="preserve">Restarts a single stream as defined in RFC 5245. This function
needs to be called both when initiating (ICE spec section 9.1.1.1.
"ICE Restarts"), as well as when reacting (spec section 9.2.1.1.
"Detecting ICE Restart") to a restart.

Unlike nice_agent_restart(), this applies to a single stream. It also
does not generate a new tie breaker.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="send" c:identifier="nice_agent_send">
        <doc xml:space="preserve">Sends a data payload over a stream's component.

 &lt;note&gt;
   &lt;para&gt;
     Component state MUST be NICE_COMPONENT_STATE_READY, or as a special case,
     in any state if component was in READY state before and was then restarted
   &lt;/para&gt;
   &lt;para&gt;
   In reliable mode, the -1 error value means either that you are not yet
   connected or that the send buffer is full (equivalent to EWOULDBLOCK).
   In both cases, you simply need to wait for the
   #NiceAgent::reliable-transport-writable signal to be fired before resending
   the data.
   &lt;/para&gt;
   &lt;para&gt;
   In non-reliable mode, it will virtually never happen with UDP sockets, but
   it might happen if the active candidate is a TURN-TCP connection that got
   disconnected.
   &lt;/para&gt;
   &lt;para&gt;
   In both reliable and non-reliable mode, a -1 error code could also mean that
   the stream_id and/or component_id are invalid.
   &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes sent, or negative error code</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to send to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component to send to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">The length of the buffer to send</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">The buffer of data to send</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_messages_nonblocking" c:identifier="nice_agent_send_messages_nonblocking" version="0.1.5" throws="1">
        <doc xml:space="preserve">Sends multiple messages on the socket identified by the given
stream/component pair. Transmission is non-blocking, so a
%G_IO_ERROR_WOULD_BLOCK error may be returned if the send buffer is full.

As with nice_agent_send(), the given component must be in
%NICE_COMPONENT_STATE_READY or, as a special case, in any state if it was
previously ready and was then restarted.

On success, the number of messages written to the socket will be returned,
which may be less than @n_messages if transmission would have blocked
part-way through. Zero will be returned if @n_messages is zero, or if
transmission would have blocked on the first message.

In reliable mode, it is instead recommended to use
nice_agent_send().  The return value can be less than @n_messages
or 0 even if it is still possible to send a partial message. In
this case, "nice-agent-writable" will never be triggered, so the
application would have to use nice_agent_sent() to fill the buffer or have
to retry sending at a later point.

On failure, -1 will be returned and @error will be set. If the #NiceAgent is
reliable and the socket is not yet connected, %G_IO_ERROR_BROKEN_PIPE will be
returned; if the write buffer is full, %G_IO_ERROR_WOULD_BLOCK will be
returned. In both cases, wait for the #NiceAgent::reliable-transport-writable
signal before trying again. If the given @stream_id or @component_id are
invalid or not yet connected, %G_IO_ERROR_BROKEN_PIPE will be returned.
%G_IO_ERROR_FAILED will be returned for other errors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of messages sent (may be zero), or -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">a #NiceAgent</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the stream to send to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the component to send to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="messages" transfer-ownership="none">
            <doc xml:space="preserve">array of messages to send, of at least
@n_messages entries in length</doc>
            <array length="3" zero-terminated="0" c:type="const NiceOutputMessage*">
              <type name="OutputMessage" c:type="NiceOutputMessage"/>
            </array>
          </parameter>
          <parameter name="n_messages" transfer-ownership="none">
            <doc xml:space="preserve">number of entries in @messages</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable to cancel the operation from
another thread, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_local_credentials" c:identifier="nice_agent_set_local_credentials">
        <doc xml:space="preserve">Sets the local credentials for stream @stream_id.

 &lt;note&gt;
   &lt;para&gt;
     This is only effective before ICE negotiation has started.
   &lt;/para&gt;
 &lt;/note&gt;

Since 0.1.11</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="ufrag" transfer-ownership="none">
            <doc xml:space="preserve">nul-terminated string containing an ICE username fragment
   (length must be between 22 and 256 chars)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pwd" transfer-ownership="none">
            <doc xml:space="preserve">nul-terminated string containing an ICE password
   (length must be between 4 and 256 chars)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_port_range" c:identifier="nice_agent_set_port_range">
        <doc xml:space="preserve">Sets a preferred port range for allocating host candidates.
&lt;para&gt;
If a local host candidate cannot be created on that port
range, then the nice_agent_gather_candidates() call will fail.
&lt;/para&gt;
&lt;para&gt;
This MUST be called before nice_agent_gather_candidates()
&lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="min_port" transfer-ownership="none">
            <doc xml:space="preserve">The minimum port to use</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="max_port" transfer-ownership="none">
            <doc xml:space="preserve">The maximum port to use</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_relay_info" c:identifier="nice_agent_set_relay_info">
        <doc xml:space="preserve">Sets the settings for using a relay server during the candidate discovery.
This may be called multiple times to add multiple relay servers to the
discovery process; one TCP and one UDP, for example.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the TURN settings were accepted.
%FALSE if the address was invalid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="server_ip" transfer-ownership="none">
            <doc xml:space="preserve">The IP address of the TURN server</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="server_port" transfer-ownership="none">
            <doc xml:space="preserve">The port of the TURN server</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">The TURN username to use for the allocate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">The TURN password to use for the allocate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The type of relay to use</doc>
            <type name="RelayType" c:type="NiceRelayType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_remote_candidates" c:identifier="nice_agent_set_remote_candidates">
        <doc xml:space="preserve">Sets, adds or updates the remote candidates for a component of a stream.

 &lt;note&gt;
   &lt;para&gt;
    NICE_AGENT_MAX_REMOTE_CANDIDATES is the absolute maximum limit
    for remote candidates.
   &lt;/para&gt;
   &lt;para&gt;
   You must first call nice_agent_gather_candidates() and wait for the
   #NiceAgent::candidate-gathering-done signale before
   calling nice_agent_set_remote_candidates()
   &lt;/para&gt;
   &lt;para&gt;
    Since 0.1.3, there is no need to wait for the candidate-gathering-done signal.
    Remote candidates can be set even while gathering local candidates.
    Newly discovered local candidates will automatically be paired with
    existing remote candidates.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of candidates added, negative on errors (memory
allocation error or invalid component)</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream the candidates are for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component the candidates are for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="candidates" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList of
#NiceCandidate items describing each candidate to add</doc>
            <type name="GLib.SList" c:type="const GSList*">
              <type name="Candidate"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_remote_credentials" c:identifier="nice_agent_set_remote_credentials">
        <doc xml:space="preserve">Sets the remote credentials for stream @stream_id.

 &lt;note&gt;
   &lt;para&gt;
     Stream credentials do not override per-candidate credentials if set
   &lt;/para&gt;
   &lt;para&gt;
     Due to the native of peer-reflexive candidates, any agent using a per-stream
     credentials (RFC5245, WLM2009, OC2007R2 and DRAFT19) instead of
     per-candidate credentials (GOOGLE, MSN, OC2007), must
     use the nice_agent_set_remote_credentials() API instead of setting the
     username and password on the candidates.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="ufrag" transfer-ownership="none">
            <doc xml:space="preserve">nul-terminated string containing an ICE username fragment
   (length must be between 22 and 256 chars)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pwd" transfer-ownership="none">
            <doc xml:space="preserve">nul-terminated string containing an ICE password
   (length must be between 4 and 256 chars)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_selected_pair" c:identifier="nice_agent_set_selected_pair">
        <doc xml:space="preserve">Sets the selected candidate pair for media transmission
for a given stream's component. Calling this function will
disable all further ICE processing (connection check,
state machine updates, etc). Note that keepalives will
continue to be sent.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if the candidate pair cannot be found</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="lfoundation" transfer-ownership="none">
            <doc xml:space="preserve">The local foundation of the candidate to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="rfoundation" transfer-ownership="none">
            <doc xml:space="preserve">The remote foundation of the candidate to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_selected_remote_candidate" c:identifier="nice_agent_set_selected_remote_candidate">
        <doc xml:space="preserve">Sets the selected remote candidate for media transmission
for a given stream's component. This is used to force the selection of
a specific remote candidate even when connectivity checks are failing
(e.g. non-ICE compatible candidates).
Calling this function will disable all further ICE processing
(connection check, state machine updates, etc). Note that keepalives will
continue to be sent.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="candidate" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceCandidate to select</doc>
            <type name="Candidate" c:type="NiceCandidate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_software" c:identifier="nice_agent_set_software" version="0.0.10">
        <doc xml:space="preserve">This function will set the value of the SOFTWARE attribute to be added to
STUN requests, responses and error responses sent during connectivity checks.
&lt;para&gt;
The SOFTWARE attribute will only be added in the #NICE_COMPATIBILITY_RFC5245
and #NICE_COMPATIBILITY_WLM2009 compatibility modes.

&lt;/para&gt;
&lt;note&gt;
     &lt;para&gt;
       The @software argument will be appended with the libnice version before
       being sent.
     &lt;/para&gt;
     &lt;para&gt;
       The @software argument must be in UTF-8 encoding and only the first
       128 characters will be sent.
     &lt;/para&gt;
   &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="software" transfer-ownership="none">
            <doc xml:space="preserve">The value of the SOFTWARE attribute to add.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stream_name" c:identifier="nice_agent_set_stream_name" version="0.1.4">
        <doc xml:space="preserve">This function will assign a media type to a stream. The only values
that can be used to produce a valid SDP are: "audio", "video",
"text", "application", "image" and "message".

This is only useful when parsing and generating an SDP of the
candidates.

&lt;para&gt;See also: nice_agent_generate_local_sdp()&lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_sdp()&lt;/para&gt;
&lt;para&gt;See also: nice_agent_get_stream_name()&lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the name has been set. %FALSE in case of error
(invalid stream or duplicate name).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to change</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The new name of the stream or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stream_tos" c:identifier="nice_agent_set_stream_tos" version="0.0.9">
        <doc xml:space="preserve">Sets the IP_TOS and/or IPV6_TCLASS field on the stream's sockets' options</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="tos" transfer-ownership="none">
            <doc xml:space="preserve">The ToS to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <property name="bytestream-tcp" version="0.1.8" transfer-ownership="none">
        <doc xml:space="preserve">This property defines whether receive/send over a TCP or pseudo-TCP, in
reliable mode, are considered as packetized or as bytestream.
In unreliable mode, every send/recv is considered as packetized, and
this property is ignored and cannot be set.
&lt;para&gt;
In reliable mode, this property will always return %TRUE in the
%NICE_COMPATIBILITY_GOOGLE compatibility mode.
&lt;/para&gt;
If the property is %TRUE, the stream is considered in bytestream mode
and data can be read with any receive size. If the property is %FALSE, then
the stream is considred packetized and each receive will return one packet
of the same size as what was sent from the peer. If in packetized mode,
then doing a receive with a size smaller than the packet, will cause the
remaining bytes in the packet to be dropped, breaking the reliability
of the stream.
&lt;para&gt;
This property is currently read-only, and will become read/write once
bytestream mode will be supported.
&lt;/para&gt;</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="compatibility" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The Nice agent can work in various compatibility modes depending on
what the application/peer needs.
&lt;para&gt; See also: #NiceCompatibility&lt;/para&gt;</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="controlling-mode" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the agent has the controlling role. This property should
be modified before gathering candidates, any modification occuring
later will be hold until ICE is restarted.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="force-relay" version="0.1.14" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Force all traffic to go through a relay for added privacy, this
allows hiding the local IP address. When this is enabled, so
local candidates are available before relay servers have been set
with nice_agent_set_relay_info().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="full-mode" writable="1" construct-only="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="ice-tcp" version="0.1.8" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the agent should use ICE-TCP when gathering candidates.
If the option is disabled, no TCP candidates will be generated. If the
agent is in reliable mode, then pseudotcp will need to be used over UDP
candidates.
&lt;para&gt;
This option should be set before gathering candidates and should not be
modified afterwards.
&lt;/para&gt;
The #NiceAgent:ice-tcp property can be set at the same time as the
#NiceAgent:ice-udp property, but both cannot be unset at the same time.
If #NiceAgent:ice-udp is set to %FALSE, then this property cannot be set
to %FALSE as well.
&lt;note&gt;
   &lt;para&gt;
   ICE-TCP is only supported for %NICE_COMPATIBILITY_RFC5245,
   %NICE_COMPATIBILITY_OC2007 and %NICE_COMPATIBILITY_OC2007R2 compatibility
   modes.
   &lt;/para&gt;
&lt;/note&gt;</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="ice-trickle" version="0.1.16" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether to perform Trickle ICE as per draft-ietf-ice-trickle-ice-21.
When %TRUE, the agent will postpone changing a component state to
%NICE_COMPONENT_STATE_FAILED until nice_agent_peer_candidate_gathering_done()
has been called with the ID of the component's stream.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="ice-udp" version="0.1.8" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the agent should use ICE-UDP when gathering candidates.
If the option is disabled, no UDP candidates will be generated. If the
agent is in reliable mode, then pseudotcp will not be used since pseudotcp
works on top of UDP candidates.
&lt;para&gt;
This option should be set before gathering candidates and should not be
modified afterwards.
&lt;/para&gt;
The #NiceAgent:ice-udp property can be set at the same time as the
#NiceAgent:ice-tcp property, but both cannot be unset at the same time.
If #NiceAgent:ice-tcp is set to %FALSE, then this property cannot be set
to %FALSE as well.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="idle-timeout" version="0.1.17" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">A final timeout in msec, launched when the agent becomes idle,
before stopping its activity.

This timer will delay the decision to set a component as failed.
This delay is added to reduce the chance to see the agent receiving
new stun activity just after the conncheck list has been declared
failed (some valid pairs, no nominated pair, and no in-progress
pairs), reactiviting conncheck activity, and causing a (valid)
state transitions like that: connecting -&gt; failed -&gt; connecting -&gt;
connected -&gt; ready.  Such transitions are not buggy per-se, but may
break the test-suite, that counts precisely the number of time each
state has been set, and doesnt expect these transcient failed
states.

This timer is also useful when the agent is in controlled mode and
the other controlling peer takes some time to elect its nominated
pair (this may be the case for SfB peers).

This timer is *NOT* part if the RFC5245, as this situation is not
covered in sect 8.1.2 "Updating States", but deals with a real
use-case, where a controlled agent can not wait forever for the
other peer to make a nomination decision.

Also note that the value of this timeout will not delay the
emission of 'connected' and 'ready' agent signals, and will not
slow down the behaviour of the agent when the peer agent works
in a timely manner.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="keepalive-conncheck" version="0.1.8" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Use binding requests as keepalives instead of binding
indications. This means that the keepalives may time out which
will change the component state to %NICE_COMPONENT_STATE_FAILED.

Enabing this is a slight violation of RFC 5245 section 10 which
recommends using Binding Indications for keepalives.

This is always enabled if the compatibility mode is
%NICE_COMPATIBILITY_GOOGLE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="main-context" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">A GLib main context is needed for all timeouts used by libnice.
This is a property being set by the nice_agent_new() call.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="max-connectivity-checks" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="nomination-mode" version="0.1.15" introspectable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The nomination mode used in the ICE specification for describing
the selection of valid pairs to be used upstream.
&lt;para&gt; See also: #NiceNominationMode &lt;/para&gt;</doc>
        <type/>
      </property>
      <property name="proxy-ip" version="0.0.4" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The proxy server IP used to bypass a proxy firewall</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="proxy-password" version="0.0.4" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The password used to authenticate with the proxy</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="proxy-port" version="0.0.4" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The proxy server port used to bypass a proxy firewall</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="proxy-type" version="0.0.4" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The type of proxy set in the proxy-ip property</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="proxy-username" version="0.0.4" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The username used to authenticate with the proxy</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="reliable" version="0.0.11" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the agent is providing a reliable transport of messages (through
ICE-TCP or PseudoTCP over ICE-UDP)</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="stun-initial-timeout" version="0.1.15" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The initial timeout (msecs) of the STUN binding requests
used in the gathering stage, to find our local candidates.
This property is described as 'RTO' in the RFC 5389 and RFC 5245.
This timeout is doubled for each retransmission, until
#NiceAgent:stun-max-retransmissions have been done,
with an exception for the last restransmission, where the timeout is
divided by two instead (RFC 5389 indicates that a customisable
multiplier 'Rm' to 'RTO' should be used).</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="stun-max-retransmissions" version="0.1.15" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The maximum number of retransmissions of the STUN binding requests
used in the gathering stage, to find our local candidates, and used
in the connection check stage, to test the validity of each
constructed pair. This property is described as 'Rc' in the RFC
5389, with a default value of 7. The timeout of each STUN request
is doubled for each retransmission, so the choice of this value has
a direct impact on the time needed to move from the CONNECTED state
to the READY state, and on the time needed to complete the GATHERING
state.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="stun-pacing-timer" writable="1" construct="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="stun-reliable-timeout" version="0.1.15" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The initial timeout of the STUN binding requests used
for a reliable timer.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="stun-server" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="stun-server-port" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="support-renomination" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Support RENOMINATION STUN attribute proposed here:
https://tools.ietf.org/html/draft-thatcher-ice-renomination-00 As
soon as RENOMINATION attribute is received from remote
candidate's address, corresponding candidates pair gets
selected. This is specific to Google Chrome/libWebRTC.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="upnp" version="0.0.7" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the agent should use UPnP to open a port in the router and
get the external IP</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="upnp-timeout" version="0.0.7" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The maximum amount of time (in milliseconds) to wait for UPnP discovery to
finish before signaling the #NiceAgent::candidate-gathering-done signal</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <glib:signal name="candidate-gathering-done" when="last">
        <doc xml:space="preserve">This signal is fired whenever a stream has finished gathering its
candidates after a call to nice_agent_gather_candidates()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="component-state-changed" when="last">
        <doc xml:space="preserve">This signal is fired whenever a component&#x2019;s state changes. There are many
valid state transitions.

![State transition diagram](states.png)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">The new #NiceComponentState of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="initial-binding-request-received" when="last">
        <doc xml:space="preserve">This signal is fired when we received our first binding request from
the peer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-candidate" when="last" deprecated="1" deprecated-version="0.1.8">
        <doc xml:space="preserve">This signal is fired when the agent discovers a new local candidate.
When this signal is emitted, a matching #NiceAgent::new-candidate-full is
also emitted with the candidate.

See also: #NiceAgent::candidate-gathering-done,
#NiceAgent::new-candidate-full</doc>
        <doc-deprecated xml:space="preserve">Use #NiceAgent::new-candidate-full</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="foundation" transfer-ownership="none">
            <doc xml:space="preserve">The foundation of the new candidate</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-candidate-full" when="last" version="0.1.8">
        <doc xml:space="preserve">This signal is fired when the agent discovers a new local candidate.
When this signal is emitted, a matching #NiceAgent::new-candidate is
also emitted with the candidate's foundation.

See also: #NiceAgent::candidate-gathering-done,
#NiceAgent::new-candidate</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="candidate" transfer-ownership="none">
            <doc xml:space="preserve">The new #NiceCandidate</doc>
            <type name="Candidate"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-remote-candidate" when="last" deprecated="1" deprecated-version="0.1.8">
        <doc xml:space="preserve">This signal is fired when the agent discovers a new remote
candidate.  This can happen with peer reflexive candidates.  When
this signal is emitted, a matching
#NiceAgent::new-remote-candidate-full is also emitted with the
candidate.

See also: #NiceAgent::new-remote-candidate-full</doc>
        <doc-deprecated xml:space="preserve">Use #NiceAgent::new-remote-candidate-full</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="foundation" transfer-ownership="none">
            <doc xml:space="preserve">The foundation of the new candidate</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-remote-candidate-full" when="last" version="0.1.8">
        <doc xml:space="preserve">This signal is fired when the agent discovers a new remote candidate.
This can happen with peer reflexive candidates.
When this signal is emitted, a matching #NiceAgent::new-remote-candidate is
also emitted with the candidate's foundation.

See also: #NiceAgent::new-remote-candidate</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="candidate" transfer-ownership="none">
            <doc xml:space="preserve">The new #NiceCandidate</doc>
            <type name="Candidate"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-selected-pair" when="last" deprecated="1" deprecated-version="0.1.8">
        <doc xml:space="preserve">This signal is fired once a candidate pair is selected for data
transfer for a stream's component This is emitted along with
#NiceAgent::new-selected-pair-full which has the whole candidate,
the Foundation of a Candidate is not a unique identifier.

See also: #NiceAgent::new-selected-pair-full</doc>
        <doc-deprecated xml:space="preserve">Use #NiceAgent::new-selected-pair-full</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="lfoundation" transfer-ownership="none">
            <doc xml:space="preserve">The local foundation of the selected candidate pair</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="rfoundation" transfer-ownership="none">
            <doc xml:space="preserve">The remote foundation of the selected candidate pair</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-selected-pair-full" when="last" version="0.1.8">
        <doc xml:space="preserve">This signal is fired once a candidate pair is selected for data
transfer for a stream's component. This is emitted along with
#NiceAgent::new-selected-pair.

See also: #NiceAgent::new-selected-pair</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="lcandidate" transfer-ownership="none">
            <doc xml:space="preserve">The local #NiceCandidate of the selected candidate pair</doc>
            <type name="Candidate"/>
          </parameter>
          <parameter name="rcandidate" transfer-ownership="none">
            <doc xml:space="preserve">The remote #NiceCandidate of the selected candidate pair</doc>
            <type name="Candidate"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="reliable-transport-writable" when="last" version="0.0.11">
        <doc xml:space="preserve">This signal is fired on the reliable #NiceAgent when the underlying reliable
transport becomes writable.
This signal is only emitted when the nice_agent_send() function returns less
bytes than requested to send (or -1) and once when the connection
is established.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="streams-removed" when="last" version="0.1.5">
        <doc xml:space="preserve">This signal is fired whenever one or more streams are removed from the
@agent.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stream_ids" transfer-ownership="none">
            <doc xml:space="preserve">An array of
unsigned integer stream IDs, ending with a 0 ID</doc>
            <array>
              <type name="guint"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AgentClass" c:type="NiceAgentClass" glib:is-gtype-struct-for="Agent">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <bitfield name="AgentOption" version="0.1.15" c:type="NiceAgentOption">
      <doc xml:space="preserve">These are options that can be passed to nice_agent_new_full(). They set
various properties on the agent. Not including them sets the property to
the other value.</doc>
      <member name="regular_nomination" value="1" c:identifier="NICE_AGENT_OPTION_REGULAR_NOMINATION">
        <doc xml:space="preserve">Enables regular nomination, default
 is aggrssive mode (see #NiceNominationMode).</doc>
      </member>
      <member name="reliable" value="2" c:identifier="NICE_AGENT_OPTION_RELIABLE">
        <doc xml:space="preserve">Enables reliable mode, possibly using PseudoTCP, *  see nice_agent_new_reliable().</doc>
      </member>
      <member name="lite_mode" value="4" c:identifier="NICE_AGENT_OPTION_LITE_MODE">
        <doc xml:space="preserve">Enable lite mode</doc>
      </member>
      <member name="ice_trickle" value="8" c:identifier="NICE_AGENT_OPTION_ICE_TRICKLE">
        <doc xml:space="preserve">Enable ICE trickle mode</doc>
      </member>
      <member name="support_renomination" value="16" c:identifier="NICE_AGENT_OPTION_SUPPORT_RENOMINATION">
        <doc xml:space="preserve">Enable renomination triggered by NOMINATION STUN attribute
proposed here: https://tools.ietf.org/html/draft-thatcher-ice-renomination-00</doc>
      </member>
    </bitfield>
    <callback name="AgentRecvFunc" c:type="NiceAgentRecvFunc">
      <doc xml:space="preserve">Callback function when data is received on a component</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="agent" transfer-ownership="none">
          <doc xml:space="preserve">The #NiceAgent Object</doc>
          <type name="Agent" c:type="NiceAgent*"/>
        </parameter>
        <parameter name="stream_id" transfer-ownership="none">
          <doc xml:space="preserve">The id of the stream</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="component_id" transfer-ownership="none">
          <doc xml:space="preserve">The id of the component of the stream
       which received the data</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">The length of the data</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve">The buffer containing the data received</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
          <doc xml:space="preserve">The user data set in nice_agent_attach_recv()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="CANDIDATE_MAX_FOUNDATION" value="33" c:type="NICE_CANDIDATE_MAX_FOUNDATION">
      <doc xml:space="preserve">The maximum size a candidate foundation can have.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CANDIDATE_MAX_LOCAL_ADDRESSES" value="64" c:type="NICE_CANDIDATE_MAX_LOCAL_ADDRESSES">
      <doc xml:space="preserve">The maximum number of local addresses. The constraint is that the
maximum number of local addresses and number of turn servers must
fit on 9 bits, to ensure candidate priority uniqueness. See also
@NICE_CANDIDATE_MAX_TURN_SERVERS. We choose 6 bits for the number of
local addresses, and 3 bits for the number of turn servers.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CANDIDATE_MAX_TURN_SERVERS" value="8" c:type="NICE_CANDIDATE_MAX_TURN_SERVERS">
      <doc xml:space="preserve">The maximum number of turns servers.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Candidate" c:type="NiceCandidate" glib:type-name="NiceCandidate" glib:get-type="nice_candidate_get_type" c:symbol-prefix="candidate">
      <doc xml:space="preserve">A structure to represent an ICE candidate
 &lt;note&gt;
   &lt;para&gt;
   The @priority is an integer as specified in the ICE draft 19. If you are
   using the MSN or the GOOGLE compatibility mode (which are based on ICE
   draft 6, which uses a floating point qvalue as priority), then the @priority
   value will represent the qvalue multiplied by 1000.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
      <field name="type" writable="1">
        <doc xml:space="preserve">The type of candidate</doc>
        <type name="CandidateType" c:type="NiceCandidateType"/>
      </field>
      <field name="transport" writable="1">
        <doc xml:space="preserve">The transport being used for the candidate</doc>
        <type name="CandidateTransport" c:type="NiceCandidateTransport"/>
      </field>
      <field name="addr" writable="1">
        <doc xml:space="preserve">The #NiceAddress of the candidate</doc>
        <type name="Address" c:type="NiceAddress"/>
      </field>
      <field name="base_addr" writable="1">
        <doc xml:space="preserve">The #NiceAddress of the base address used by the candidate</doc>
        <type name="Address" c:type="NiceAddress"/>
      </field>
      <field name="priority" writable="1">
        <doc xml:space="preserve">The priority of the candidate &lt;emphasis&gt; see note &lt;/emphasis&gt;</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="stream_id" writable="1">
        <doc xml:space="preserve">The ID of the stream to which belongs the candidate</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="component_id" writable="1">
        <doc xml:space="preserve">The ID of the component to which belongs the candidate</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="foundation" writable="1">
        <doc xml:space="preserve">The foundation of the candidate</doc>
        <array zero-terminated="0" fixed-size="33">
          <type name="gchar" c:type="gchar"/>
        </array>
      </field>
      <field name="username" writable="1">
        <doc xml:space="preserve">The candidate-specific username to use (overrides the one set
by nice_agent_set_local_credentials() or nice_agent_set_remote_credentials())</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="password" writable="1">
        <doc xml:space="preserve">The candidate-specific password to use (overrides the one set
by nice_agent_set_local_credentials() or nice_agent_set_remote_credentials())</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <constructor name="new" c:identifier="nice_candidate_new">
        <doc xml:space="preserve">Creates a new candidate. Must be freed with nice_candidate_free()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #NiceCandidate</doc>
          <type name="Candidate" c:type="NiceCandidate*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceCandidateType of the candidate to create</doc>
            <type name="CandidateType" c:type="NiceCandidateType"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="nice_candidate_copy">
        <doc xml:space="preserve">Makes a copy of a #NiceCandidate</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #NiceCandidate, a copy of @candidate</doc>
          <type name="Candidate" c:type="NiceCandidate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="candidate" transfer-ownership="none">
            <doc xml:space="preserve">The candidate to copy</doc>
            <type name="Candidate" c:type="const NiceCandidate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal_target" c:identifier="nice_candidate_equal_target" version="0.1.15">
        <doc xml:space="preserve">Verifies that the candidates point to the same place, meaning they have
the same transport and the same address. It ignores all other aspects.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the candidates point to the same place</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="candidate1" transfer-ownership="none">
            <doc xml:space="preserve">A candidate</doc>
            <type name="Candidate" c:type="const NiceCandidate*"/>
          </instance-parameter>
          <parameter name="candidate2" transfer-ownership="none">
            <doc xml:space="preserve">A candidate</doc>
            <type name="Candidate" c:type="const NiceCandidate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="nice_candidate_free">
        <doc xml:space="preserve">Frees a #NiceCandidate</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="candidate" transfer-ownership="none">
            <doc xml:space="preserve">The candidate to free</doc>
            <type name="Candidate" c:type="NiceCandidate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="transport_to_string" c:identifier="nice_candidate_transport_to_string" version="0.1.18">
        <doc xml:space="preserve">Useful for debugging functions, just returns a static string with the
candidate transport.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a static string with the candidate transport</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="transport" transfer-ownership="none">
            <doc xml:space="preserve">a #NiceCandidateTransport</doc>
            <type name="CandidateTransport" c:type="NiceCandidateTransport"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_to_string" c:identifier="nice_candidate_type_to_string" version="0.1.18">
        <doc xml:space="preserve">Useful for debugging functions, just returns a static string with the
candidate type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a static string with the candidate type</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #NiceCandidateType</doc>
            <type name="CandidateType" c:type="NiceCandidateType"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="CandidateTransport" c:type="NiceCandidateTransport">
      <doc xml:space="preserve">An enum representing the type of transport to use</doc>
      <member name="udp" value="0" c:identifier="NICE_CANDIDATE_TRANSPORT_UDP">
        <doc xml:space="preserve">UDP transport</doc>
      </member>
      <member name="tcp_active" value="1" c:identifier="NICE_CANDIDATE_TRANSPORT_TCP_ACTIVE">
        <doc xml:space="preserve">TCP Active transport</doc>
      </member>
      <member name="tcp_passive" value="2" c:identifier="NICE_CANDIDATE_TRANSPORT_TCP_PASSIVE">
        <doc xml:space="preserve">TCP Passive transport</doc>
      </member>
      <member name="tcp_so" value="3" c:identifier="NICE_CANDIDATE_TRANSPORT_TCP_SO">
        <doc xml:space="preserve">TCP Simultaneous-Open transport</doc>
      </member>
    </enumeration>
    <enumeration name="CandidateType" c:type="NiceCandidateType">
      <doc xml:space="preserve">An enum represneting the type of a candidate</doc>
      <member name="host" value="0" c:identifier="NICE_CANDIDATE_TYPE_HOST">
        <doc xml:space="preserve">A host candidate</doc>
      </member>
      <member name="server_reflexive" value="1" c:identifier="NICE_CANDIDATE_TYPE_SERVER_REFLEXIVE">
        <doc xml:space="preserve">A server reflexive candidate</doc>
      </member>
      <member name="peer_reflexive" value="2" c:identifier="NICE_CANDIDATE_TYPE_PEER_REFLEXIVE">
        <doc xml:space="preserve">A peer reflexive candidate</doc>
      </member>
      <member name="relayed" value="3" c:identifier="NICE_CANDIDATE_TYPE_RELAYED">
        <doc xml:space="preserve">A relay candidate</doc>
      </member>
    </enumeration>
    <enumeration name="Compatibility" c:type="NiceCompatibility">
      <doc xml:space="preserve">An enum to specify which compatible specifications the #NiceAgent should use.
Use with nice_agent_new()

&lt;warning&gt;@NICE_COMPATIBILITY_DRAFT19 is deprecated and should not be used
in newly-written code. It is kept for compatibility reasons and
represents the same compatibility as @NICE_COMPATIBILITY_RFC5245 &lt;/warning&gt;
 &lt;note&gt;
   &lt;para&gt;
   If @NICE_COMPATIBILITY_RFC5245 compatibility mode is used for a non-reliable
   agent, then ICE-UDP will be used with higher priority and ICE-TCP will also
   be used when the UDP connectivity fails. If it is used with a reliable agent,
   then ICE-UDP will be used with the TCP-Over-UDP (#PseudoTcpSocket) if ICE-TCP
   fails and ICE-UDP succeeds.
  &lt;/para&gt;
 &lt;/note&gt;</doc>
      <member name="rfc5245" value="0" c:identifier="NICE_COMPATIBILITY_RFC5245">
        <doc xml:space="preserve">Use compatibility with the RFC5245 ICE-UDP specs
and RFC6544 ICE-TCP specs</doc>
      </member>
      <member name="draft19" value="0" c:identifier="NICE_COMPATIBILITY_DRAFT19">
        <doc xml:space="preserve">Use compatibility for ICE Draft 19 specs</doc>
      </member>
      <member name="google" value="1" c:identifier="NICE_COMPATIBILITY_GOOGLE">
        <doc xml:space="preserve">Use compatibility for Google Talk specs</doc>
      </member>
      <member name="msn" value="2" c:identifier="NICE_COMPATIBILITY_MSN">
        <doc xml:space="preserve">Use compatibility for MSN Messenger specs</doc>
      </member>
      <member name="wlm2009" value="3" c:identifier="NICE_COMPATIBILITY_WLM2009">
        <doc xml:space="preserve">Use compatibility with Windows Live Messenger
2009</doc>
      </member>
      <member name="oc2007" value="4" c:identifier="NICE_COMPATIBILITY_OC2007">
        <doc xml:space="preserve">Use compatibility with Microsoft Office Communicator 2007</doc>
      </member>
      <member name="oc2007r2" value="5" c:identifier="NICE_COMPATIBILITY_OC2007R2">
        <doc xml:space="preserve">Use compatibility with Microsoft Office Communicator 2007 R2</doc>
      </member>
      <member name="last" value="5" c:identifier="NICE_COMPATIBILITY_LAST">
        <doc xml:space="preserve">Dummy last compatibility mode</doc>
      </member>
    </enumeration>
    <enumeration name="ComponentState" c:type="NiceComponentState">
      <doc xml:space="preserve">An enum representing the state of a component.
&lt;para&gt; See also: #NiceAgent::component-state-changed &lt;/para&gt;</doc>
      <member name="disconnected" value="0" c:identifier="NICE_COMPONENT_STATE_DISCONNECTED">
        <doc xml:space="preserve">No activity scheduled</doc>
      </member>
      <member name="gathering" value="1" c:identifier="NICE_COMPONENT_STATE_GATHERING">
        <doc xml:space="preserve">Gathering local candidates</doc>
      </member>
      <member name="connecting" value="2" c:identifier="NICE_COMPONENT_STATE_CONNECTING">
        <doc xml:space="preserve">Establishing connectivity</doc>
      </member>
      <member name="connected" value="3" c:identifier="NICE_COMPONENT_STATE_CONNECTED">
        <doc xml:space="preserve">At least one working candidate pair</doc>
      </member>
      <member name="ready" value="4" c:identifier="NICE_COMPONENT_STATE_READY">
        <doc xml:space="preserve">ICE concluded, candidate pair selection
is now final</doc>
      </member>
      <member name="failed" value="5" c:identifier="NICE_COMPONENT_STATE_FAILED">
        <doc xml:space="preserve">Connectivity checks have been completed,
but connectivity was not established</doc>
      </member>
      <member name="last" value="6" c:identifier="NICE_COMPONENT_STATE_LAST">
        <doc xml:space="preserve">Dummy state</doc>
      </member>
    </enumeration>
    <enumeration name="ComponentType" c:type="NiceComponentType">
      <doc xml:space="preserve">Convenience enum representing the type of a component for use as the
component_id for RTP/RTCP usages.
 &lt;example&gt;
   &lt;title&gt;Example of use.&lt;/title&gt;
   &lt;programlisting&gt;
   nice_agent_send (agent, stream_id, NICE_COMPONENT_TYPE_RTP, len, buf);
   &lt;/programlisting&gt;
  &lt;/example&gt;</doc>
      <member name="rtp" value="1" c:identifier="NICE_COMPONENT_TYPE_RTP">
        <doc xml:space="preserve">RTP Component type</doc>
      </member>
      <member name="rtcp" value="2" c:identifier="NICE_COMPONENT_TYPE_RTCP">
        <doc xml:space="preserve">RTCP Component type</doc>
      </member>
    </enumeration>
    <function-macro name="IS_AGENT" c:identifier="NICE_IS_AGENT" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_AGENT_CLASS" c:identifier="NICE_IS_AGENT_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PSEUDO_TCP_SOCKET" c:identifier="IS_PSEUDO_TCP_SOCKET" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PSEUDO_TCP_SOCKET_CLASS" c:identifier="IS_PSEUDO_TCP_SOCKET_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <record name="InputMessage" c:type="NiceInputMessage" version="0.1.5">
      <doc xml:space="preserve">Represents a single message received off the network. For reliable
connections, this is essentially just an array of buffers (specifically,
@from can be ignored). for non-reliable connections, it represents a single
packet as received from the OS.

@n_buffers may be -1 to indicate that @buffers is terminated by a
#GInputVector with a %NULL buffer pointer.

By providing arrays of #NiceInputMessages to functions like
nice_agent_recv_messages(), multiple messages may be received with a single
call, which is more efficient than making multiple calls in a loop. In this
manner, nice_agent_recv_messages() is analogous to recvmmsg(); and
#NiceInputMessage to struct mmsghdr.</doc>
      <field name="buffers" writable="1">
        <doc xml:space="preserve">unowned array of #GInputVector buffers to
store data in for this message</doc>
        <array length="1" zero-terminated="0" c:type="GInputVector*">
          <type name="Gio.InputVector" c:type="GInputVector"/>
        </array>
      </field>
      <field name="n_buffers" writable="1">
        <doc xml:space="preserve">number of #GInputVectors in @buffers, or -1 to indicate @buffers
is %NULL-terminated</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="from" writable="1">
        <doc xml:space="preserve">return location to store the address of the peer who
transmitted the message, or %NULL</doc>
        <type name="Address" c:type="NiceAddress*"/>
      </field>
      <field name="length" writable="1">
        <doc xml:space="preserve">total number of valid bytes contiguously stored in @buffers</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
    </record>
    <enumeration name="NominationMode" version="0.1.15" c:type="NiceNominationMode">
      <doc xml:space="preserve">An enum to specity the kind of nomination mode to use by
the agent, as described in RFC 5245. Two modes exists,
regular and aggressive. They differ by the way the controlling
agent chooses to put the USE-CANDIDATE attribute in its STUN
messages. The aggressive mode is supposed to nominate a pair
faster, than the regular mode, potentially causing the nominated
pair to change until the connection check completes.</doc>
      <member name="regular" value="0" c:identifier="NICE_NOMINATION_MODE_REGULAR">
        <doc xml:space="preserve">Regular nomination mode</doc>
      </member>
      <member name="aggressive" value="1" c:identifier="NICE_NOMINATION_MODE_AGGRESSIVE">
        <doc xml:space="preserve">Aggressive nomination mode</doc>
      </member>
    </enumeration>
    <record name="OutputMessage" c:type="NiceOutputMessage" version="0.1.5">
      <doc xml:space="preserve">Represents a single message to transmit on the network. For
reliable connections, this is essentially just an array of
buffer. for non-reliable connections, it represents a single packet
to send to the OS.

@n_buffers may be -1 to indicate that @buffers is terminated by a
#GOutputVector with a %NULL buffer pointer.

By providing arrays of #NiceOutputMessages to functions like
nice_agent_send_messages_nonblocking(), multiple messages may be transmitted
with a single call, which is more efficient than making multiple calls in a
loop. In this manner, nice_agent_send_messages_nonblocking() is analogous to
sendmmsg(); and #NiceOutputMessage to struct mmsghdr.</doc>
      <field name="buffers" writable="1">
        <doc xml:space="preserve">unowned array of #GOutputVector buffers
which contain data to transmit for this message</doc>
        <array length="1" zero-terminated="0" c:type="GOutputVector*">
          <type name="Gio.OutputVector" c:type="GOutputVector"/>
        </array>
      </field>
      <field name="n_buffers" writable="1">
        <doc xml:space="preserve">number of #GOutputVectors in @buffers, or -1 to indicate @buffers
is %NULL-terminated</doc>
        <type name="gint" c:type="gint"/>
      </field>
    </record>
    <function-macro name="PSEUDOTCP_SOCKET_GET_CLASS" c:identifier="PSEUDOTCP_SOCKET_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PSEUDO_TCP_SOCKET" c:identifier="PSEUDO_TCP_SOCKET" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PSEUDO_TCP_SOCKET_CLASS" c:identifier="PSEUDO_TCP_SOCKET_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <enumeration name="ProxyType" version="0.0.4" c:type="NiceProxyType">
      <doc xml:space="preserve">An enum to specify which proxy type to use for relaying.
Note that the proxies will only be used with TCP TURN relaying.
&lt;para&gt; See also: #NiceAgent:proxy-type &lt;/para&gt;</doc>
      <member name="none" value="0" c:identifier="NICE_PROXY_TYPE_NONE">
        <doc xml:space="preserve">Do not use a proxy</doc>
      </member>
      <member name="socks5" value="1" c:identifier="NICE_PROXY_TYPE_SOCKS5">
        <doc xml:space="preserve">Use a SOCKS5 proxy</doc>
      </member>
      <member name="http" value="2" c:identifier="NICE_PROXY_TYPE_HTTP">
        <doc xml:space="preserve">Use an HTTP proxy</doc>
      </member>
      <member name="last" value="2" c:identifier="NICE_PROXY_TYPE_LAST">
        <doc xml:space="preserve">Dummy last proxy type</doc>
      </member>
    </enumeration>
    <record name="PseudoTcpCallbacks" c:type="PseudoTcpCallbacks" version="0.0.11">
      <doc xml:space="preserve">A structure containing callbacks functions that will be called by the
#PseudoTcpSocket when some events happen.
&lt;para&gt; See also: #PseudoTcpWriteResult &lt;/para&gt;</doc>
      <field name="user_data" writable="1">
        <doc xml:space="preserve">A user defined pointer to be passed to the callbacks</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="PseudoTcpOpened">
        <callback name="PseudoTcpOpened">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="tcp" transfer-ownership="none">
              <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="PseudoTcpReadable">
        <callback name="PseudoTcpReadable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="tcp" transfer-ownership="none">
              <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="PseudoTcpWritable">
        <callback name="PseudoTcpWritable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="tcp" transfer-ownership="none">
              <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="PseudoTcpClosed">
        <callback name="PseudoTcpClosed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="tcp" transfer-ownership="none">
              <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="guint32" c:type="guint32"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="WritePacket">
        <callback name="WritePacket">
          <return-value transfer-ownership="none">
            <type name="PseudoTcpWriteResult" c:type="PseudoTcpWriteResult"/>
          </return-value>
          <parameters>
            <parameter name="tcp" transfer-ownership="none">
              <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="len" transfer-ownership="none">
              <type name="guint32" c:type="guint32"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="PseudoTcpDebugLevel" version="0.0.11" c:type="PseudoTcpDebugLevel">
      <doc xml:space="preserve">Valid values of debug levels to be set.</doc>
      <member name="none" value="0" c:identifier="PSEUDO_TCP_DEBUG_NONE">
        <doc xml:space="preserve">Disable debug messages</doc>
      </member>
      <member name="normal" value="1" c:identifier="PSEUDO_TCP_DEBUG_NORMAL">
        <doc xml:space="preserve">Enable basic debug messages</doc>
      </member>
      <member name="verbose" value="2" c:identifier="PSEUDO_TCP_DEBUG_VERBOSE">
        <doc xml:space="preserve">Enable verbose debug messages</doc>
      </member>
    </enumeration>
    <enumeration name="PseudoTcpShutdown" version="0.1.8" c:type="PseudoTcpShutdown">
      <doc xml:space="preserve">Options for which parts of a connection to shut down when calling
pseudo_tcp_socket_shutdown(). These correspond to the values passed to POSIX
shutdown().</doc>
      <member name="rd" value="0" c:identifier="PSEUDO_TCP_SHUTDOWN_RD">
        <doc xml:space="preserve">Shut down the local reader only</doc>
      </member>
      <member name="wr" value="1" c:identifier="PSEUDO_TCP_SHUTDOWN_WR">
        <doc xml:space="preserve">Shut down the local writer only</doc>
      </member>
      <member name="rdwr" value="2" c:identifier="PSEUDO_TCP_SHUTDOWN_RDWR">
        <doc xml:space="preserve">Shut down both reading and writing</doc>
      </member>
    </enumeration>
    <class name="PseudoTcpSocket" c:symbol-prefix="pseudo_tcp_socket" c:type="PseudoTcpSocket" version="0.0.11" parent="GObject.Object" glib:type-name="PseudoTcpSocket" glib:get-type="pseudo_tcp_socket_get_type" glib:type-struct="PseudoTcpSocketClass">
      <doc xml:space="preserve">The #PseudoTcpSocket is the GObject implementing the Pseudo TCP Socket</doc>
      <constructor name="new" c:identifier="pseudo_tcp_socket_new" version="0.0.11">
        <doc xml:space="preserve">Creates a new #PseudoTcpSocket for the specified conversation

 &lt;note&gt;
   &lt;para&gt;
     The @callbacks must be non-NULL, in order to get notified of packets the
     socket needs to send.
   &lt;/para&gt;
   &lt;para&gt;
     If the @callbacks structure was dynamicly allocated, it can be freed
     after the call @pseudo_tcp_socket_new
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new #PseudoTcpSocket object, %NULL on error</doc>
          <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
        </return-value>
        <parameters>
          <parameter name="conversation" transfer-ownership="none">
            <doc xml:space="preserve">The conversation id for the socket.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="callbacks" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to the #PseudoTcpCallbacks structure for getting
notified of the #PseudoTcpSocket events.</doc>
            <type name="PseudoTcpCallbacks" c:type="PseudoTcpCallbacks*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="can_send" c:identifier="pseudo_tcp_socket_can_send" version="0.1.5">
        <doc xml:space="preserve">Returns if there is space in the send buffer to send any data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if data can be sent, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="close" c:identifier="pseudo_tcp_socket_close" version="0.0.11">
        <doc xml:space="preserve">Close the socket for sending. If @force is set to %FALSE, the socket will
finish sending pending data before closing. If it is set to %TRUE, the socket
will discard pending data and close the connection immediately (sending a TCP
RST segment).

The socket will be closed in both directions &#x2013; sending and receiving &#x2013; and
any pending received data must be read before calling this function, by
calling pseudo_tcp_socket_recv() until it blocks. If any pending data is in
the receive buffer when pseudo_tcp_socket_close() is called, a TCP RST
segment will be sent to the peer to notify it of the data loss.

 &lt;note&gt;
   &lt;para&gt;
     The %PseudoTcpCallbacks:PseudoTcpClosed callback will not be called once
     the socket gets closed. It is only used for aborted connection.
     Instead, the socket gets closed when the pseudo_tcp_socket_get_next_clock()
     function returns FALSE.
   &lt;/para&gt;
 &lt;/note&gt;

&lt;para&gt; See also: pseudo_tcp_socket_get_next_clock() &lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="force" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to close the socket forcefully, %FALSE to close it gracefully</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect" c:identifier="pseudo_tcp_socket_connect" version="0.0.11">
        <doc xml:space="preserve">Connects the #PseudoTcpSocket to the peer with the same conversation id.
The connection will only be successful after the
%PseudoTcpCallbacks:PseudoTcpOpened callback is called</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure (not in %TCP_LISTEN state)
&lt;para&gt; See also: pseudo_tcp_socket_get_error() &lt;/para&gt;</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_available_bytes" c:identifier="pseudo_tcp_socket_get_available_bytes" version="0.1.5">
        <doc xml:space="preserve">Gets the number of bytes of data in the buffer that can be read without
receiving more packets from the network.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes or -1 if the connection is not established</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_available_send_space" c:identifier="pseudo_tcp_socket_get_available_send_space" version="0.1.5">
        <doc xml:space="preserve">Gets the number of bytes of space available in the transmission buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes, or 0 if the connection is not established.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_error" c:identifier="pseudo_tcp_socket_get_error" version="0.0.11">
        <doc xml:space="preserve">Return the last encountered error.

 &lt;note&gt;
   &lt;para&gt;
     The return value can be :
     &lt;para&gt;
       EINVAL (for pseudo_tcp_socket_connect()).
     &lt;/para&gt;
     &lt;para&gt;
       EWOULDBLOCK or ENOTCONN (for pseudo_tcp_socket_recv() and
       pseudo_tcp_socket_send()).
     &lt;/para&gt;
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The error code
&lt;para&gt; See also: pseudo_tcp_socket_connect() &lt;/para&gt;
&lt;para&gt; See also: pseudo_tcp_socket_recv() &lt;/para&gt;
&lt;para&gt; See also: pseudo_tcp_socket_send() &lt;/para&gt;</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_next_clock" c:identifier="pseudo_tcp_socket_get_next_clock" version="0.0.11">
        <doc xml:space="preserve">Call this to determine the timeout needed before the next time call
to pseudo_tcp_socket_notify_clock() should be made.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @timeout was filled, %FALSE if the socket is closed and
ready to be destroyed.

&lt;para&gt; See also: pseudo_tcp_socket_notify_clock() &lt;/para&gt;</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to be filled with the new timeout.</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_closed" c:identifier="pseudo_tcp_socket_is_closed" version="0.1.8">
        <doc xml:space="preserve">Gets whether the socket is closed, with the shutdown handshake completed,
and both peers no longer able to read or write data to the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the socket is closed in both directions, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_closed_remotely" c:identifier="pseudo_tcp_socket_is_closed_remotely" version="0.1.8">
        <doc xml:space="preserve">Gets whether the socket has been closed on the remote peer&#x2019;s side of the
connection (i.e. whether pseudo_tcp_socket_close() has been called there).
This is guaranteed to return %TRUE if pseudo_tcp_socket_is_closed() returns
%TRUE. It will not return %TRUE after pseudo_tcp_socket_close() is called
until a FIN segment is received from the remote peer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the remote peer has closed its side of the connection,
%FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="notify_clock" c:identifier="pseudo_tcp_socket_notify_clock" version="0.0.11">
        <doc xml:space="preserve">Start the processing of receiving data, pending data or syn/acks.
Call this based on timeout value returned by
pseudo_tcp_socket_get_next_clock().
It's ok to call this too frequently.

&lt;para&gt; See also: pseudo_tcp_socket_get_next_clock() &lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="notify_message" c:identifier="pseudo_tcp_socket_notify_message" version="0.1.5">
        <doc xml:space="preserve">Notify the #PseudoTcpSocket that a new message has arrived, and enqueue the
data in its buffers to the #PseudoTcpSocket&#x2019;s receive buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the packet was processed successfully, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #NiceInputMessage containing the received data.</doc>
            <type name="InputMessage" c:type="NiceInputMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="notify_mtu" c:identifier="pseudo_tcp_socket_notify_mtu" version="0.0.11">
        <doc xml:space="preserve">Set the MTU of the socket</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="mtu" transfer-ownership="none">
            <doc xml:space="preserve">The new MTU of the socket</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="notify_packet" c:identifier="pseudo_tcp_socket_notify_packet" version="0.0.11">
        <doc xml:space="preserve">Notify the #PseudoTcpSocket when a new packet arrives</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the packet was processed successfully, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The buffer containing the received data</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">The length of @buffer</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="recv" c:identifier="pseudo_tcp_socket_recv" version="0.0.11">
        <doc xml:space="preserve">Receive data from the socket.

 &lt;note&gt;
   &lt;para&gt;
     Only call this on the %PseudoTcpCallbacks:PseudoTcpReadable callback.
   &lt;/para&gt;
   &lt;para&gt;
     This function should be called in a loop. If this function does not
     return -1 with EWOULDBLOCK as the error, the
     %PseudoTcpCallbacks:PseudoTcpReadable callback will not be called again.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes received or -1 in case of error
&lt;para&gt; See also: pseudo_tcp_socket_get_error() &lt;/para&gt;</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The buffer to fill with received data</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">The length of @buffer</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="send" c:identifier="pseudo_tcp_socket_send" version="0.0.11">
        <doc xml:space="preserve">Send data on the socket.

 &lt;note&gt;
   &lt;para&gt;
     If this function return -1 with EWOULDBLOCK as the error, or if the return
     value is lower than @len, then the %PseudoTcpCallbacks:PseudoTcpWritable
     callback will be called when the socket will become writable.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes sent or -1 in case of error
&lt;para&gt; See also: pseudo_tcp_socket_get_error() &lt;/para&gt;</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The buffer with data to send</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">The length of @buffer</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_time" c:identifier="pseudo_tcp_socket_set_time" version="0.1.8">
        <doc xml:space="preserve">Sets the current monotonic time to be used by the TCP socket when calculating
timeouts and expiry times. If this function is not called, or is called with
@current_time as zero, g_get_monotonic_time() will be used. Otherwise, the
specified @current_time will be used until it is updated by calling this
function again.

This function is intended for testing only, and should not be used in
production code.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="current_time" transfer-ownership="none">
            <doc xml:space="preserve">Current monotonic time, in milliseconds; or zero to use the
system monotonic clock.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="shutdown" c:identifier="pseudo_tcp_socket_shutdown" version="0.1.8">
        <doc xml:space="preserve">Shut down sending, receiving, or both on the socket, depending on the value
of @how. The behaviour of pseudo_tcp_socket_send() and
pseudo_tcp_socket_recv() will immediately change after this function returns
(depending on the value of @how), though the socket may continue to process
network traffic in the background even if sending or receiving data is
forbidden.

This is equivalent to the POSIX shutdown() function. Setting @how to
%PSEUDO_TCP_SHUTDOWN_RDWR is equivalent to calling pseudo_tcp_socket_close().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="how" transfer-ownership="none">
            <doc xml:space="preserve">The directions of the connection to shut down.</doc>
            <type name="PseudoTcpShutdown" c:type="PseudoTcpShutdown"/>
          </parameter>
        </parameters>
      </method>
      <property name="ack-delay" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="callbacks" writable="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="conversation" writable="1" construct-only="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="no-delay" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="rcv-buf" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="snd-buf" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="state" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="support-fin-ack" version="0.1.8" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether to support the FIN&#x2013;ACK extension to the pseudo-TCP protocol for
this socket. The extension is only compatible with other libnice pseudo-TCP
stacks, and not with Jingle pseudo-TCP stacks. If enabled, support is
negotiatied on connection setup, so it is safe for a #PseudoTcpSocket with
support enabled to be used with one with it disabled, or with a Jingle
pseudo-TCP socket which doesn&#x2019;t support it at all.

Support is enabled by default.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
    </class>
    <record name="PseudoTcpSocketClass" c:type="PseudoTcpSocketClass" disguised="1" glib:is-gtype-struct-for="PseudoTcpSocket"/>
    <enumeration name="PseudoTcpState" version="0.0.11" c:type="PseudoTcpState">
      <doc xml:space="preserve">An enum representing the state of the #PseudoTcpSocket. These states
correspond to the TCP states in RFC 793.
&lt;para&gt; See also: #PseudoTcpSocket:state &lt;/para&gt;</doc>
      <member name="listen" value="0" c:identifier="PSEUDO_TCP_LISTEN">
        <doc xml:space="preserve">The socket's initial state. The socket isn't connected and is
listening for an incoming connection</doc>
      </member>
      <member name="syn_sent" value="1" c:identifier="PSEUDO_TCP_SYN_SENT">
        <doc xml:space="preserve">The socket has sent a connection request (SYN) packet and is
waiting for an answer</doc>
      </member>
      <member name="syn_received" value="2" c:identifier="PSEUDO_TCP_SYN_RECEIVED">
        <doc xml:space="preserve">The socket has received a connection request (SYN) packet.</doc>
      </member>
      <member name="established" value="3" c:identifier="PSEUDO_TCP_ESTABLISHED">
        <doc xml:space="preserve">The socket is connected</doc>
      </member>
      <member name="closed" value="4" c:identifier="PSEUDO_TCP_CLOSED">
        <doc xml:space="preserve">The socket has been closed</doc>
      </member>
      <member name="fin_wait_1" value="5" c:identifier="PSEUDO_TCP_FIN_WAIT_1">
        <doc xml:space="preserve">The socket has been closed locally but not remotely
(Since: 0.1.8)</doc>
      </member>
      <member name="fin_wait_2" value="6" c:identifier="PSEUDO_TCP_FIN_WAIT_2">
        <doc xml:space="preserve">The socket has been closed locally but not remotely
(Since: 0.1.8)</doc>
      </member>
      <member name="closing" value="7" c:identifier="PSEUDO_TCP_CLOSING">
        <doc xml:space="preserve">The socket has been closed locally and remotely
(Since: 0.1.8)</doc>
      </member>
      <member name="time_wait" value="8" c:identifier="PSEUDO_TCP_TIME_WAIT">
        <doc xml:space="preserve">The socket has been closed locally and remotely
(Since: 0.1.8)</doc>
      </member>
      <member name="close_wait" value="9" c:identifier="PSEUDO_TCP_CLOSE_WAIT">
        <doc xml:space="preserve">The socket has been closed remotely but not locally
(Since: 0.1.8)</doc>
      </member>
      <member name="last_ack" value="10" c:identifier="PSEUDO_TCP_LAST_ACK">
        <doc xml:space="preserve">The socket has been closed locally and remotely
(Since: 0.1.8)</doc>
      </member>
    </enumeration>
    <enumeration name="PseudoTcpWriteResult" version="0.0.11" c:type="PseudoTcpWriteResult">
      <doc xml:space="preserve">An enum representing the result value of the write operation requested by
the #PseudoTcpSocket.
&lt;para&gt; See also: %PseudoTcpCallbacks:WritePacket &lt;/para&gt;</doc>
      <member name="success" value="0" c:identifier="WR_SUCCESS">
        <doc xml:space="preserve">The write operation was successful</doc>
      </member>
      <member name="too_large" value="1" c:identifier="WR_TOO_LARGE">
        <doc xml:space="preserve">The socket type requires that message be sent atomically
and the size of the message to be sent made this impossible.</doc>
      </member>
      <member name="fail" value="2" c:identifier="WR_FAIL">
        <doc xml:space="preserve">There was an error sending the message</doc>
      </member>
    </enumeration>
    <enumeration name="RelayType" c:type="NiceRelayType">
      <doc xml:space="preserve">An enum representing the type of relay to use</doc>
      <member name="udp" value="0" c:identifier="NICE_RELAY_TYPE_TURN_UDP">
        <doc xml:space="preserve">A TURN relay using UDP</doc>
      </member>
      <member name="tcp" value="1" c:identifier="NICE_RELAY_TYPE_TURN_TCP">
        <doc xml:space="preserve">A TURN relay using TCP</doc>
      </member>
      <member name="tls" value="2" c:identifier="NICE_RELAY_TYPE_TURN_TLS">
        <doc xml:space="preserve">A TURN relay using TLS over TCP</doc>
      </member>
    </enumeration>
    <docsection name="address">
      <doc xml:space="preserve">The #NiceAddress structure will allow you to easily set/get and modify an IPv4
or IPv6 address in order to communicate with the #NiceAgent.</doc>
    </docsection>
    <docsection name="agent">
      <doc xml:space="preserve">The #NiceAgent is your main object when using libnice.
It is the agent that will take care of everything relating to ICE.
It will take care of discovering your local candidates and do
 connectivity checks to create a stream of data between you and your peer.

A #NiceAgent must always be used with a #GMainLoop running the #GMainContext
passed into nice_agent_new() (or nice_agent_new_reliable()). Without the
#GMainContext being iterated, the agent&#x2019;s timers will not fire, etc.

Streams and their components are referenced by integer IDs (with respect to a
given #NiceAgent). These IDs are guaranteed to be positive (i.e. non-zero)
for valid streams/components.

To complete the ICE connectivity checks, the user must either register
an I/O callback (with nice_agent_attach_recv()) or call nice_agent_recv_messages()
in a loop on a dedicated thread.
Technically, #NiceAgent does not poll the streams on its own, since
user data could arrive at any time; to receive STUN packets
required for establishing ICE connectivity, it is backpiggying
on the facility chosen by the user. #NiceAgent will handle all STUN
packets internally; they're never actually passed to the I/O callback
or returned from nice_agent_recv_messages() and related functions.

Each stream can receive data in one of two ways: using
nice_agent_attach_recv() or nice_agent_recv_messages() (and the derived
#NiceInputStream and #NiceIOStream classes accessible using
nice_agent_get_io_stream()). nice_agent_attach_recv() is non-blocking: it
takes a user-provided callback function and attaches the stream&#x2019;s socket to
the provided #GMainContext, invoking the callback in that context for every
packet received. nice_agent_recv_messages() instead blocks on receiving a
packet, and writes it directly into a user-provided buffer. This reduces the
number of callback invokations and (potentially) buffer copies required to
receive packets. nice_agent_recv_messages() (or #NiceInputStream) is designed
to be used in a blocking loop in a separate thread.

&lt;example&gt;
  &lt;title&gt;Simple example on how to use libnice&lt;/title&gt;
  &lt;programlisting&gt;
  guint stream_id;
  gchar buffer[] = "hello world!";
  gchar *ufrag = NULL, *pwd = NULL;
  gchar *remote_ufrag, *remote_pwd;
  GSList *lcands = NULL;

  // Create a nice agent, passing in the global default GMainContext.
  NiceAgent *agent = nice_agent_new (NULL, NICE_COMPATIBILITY_RFC5245);
  spawn_thread_to_run_main_loop (g_main_loop_new (NULL, FALSE));

  // Connect the signals
  g_signal_connect (G_OBJECT (agent), "candidate-gathering-done",
                    G_CALLBACK (cb_candidate_gathering_done), NULL);
  g_signal_connect (G_OBJECT (agent), "component-state-changed",
                    G_CALLBACK (cb_component_state_changed), NULL);
  g_signal_connect (G_OBJECT (agent), "new-selected-pair",
                    G_CALLBACK (cb_new_selected_pair), NULL);

  // Create a new stream with one component and start gathering candidates
  stream_id = nice_agent_add_stream (agent, 1);
  nice_agent_gather_candidates (agent, stream_id);

  // Attach I/O callback the component to ensure that:
  // 1) agent gets its STUN packets (not delivered to cb_nice_recv)
  // 2) you get your own data
  nice_agent_attach_recv (agent, stream_id, 1, NULL,
                         cb_nice_recv, NULL);

  // ... Wait until the signal candidate-gathering-done is fired ...
  lcands = nice_agent_get_local_candidates(agent, stream_id, 1);

  nice_agent_get_local_credentials(agent, stream_id, &amp;ufrag, &amp;pwd);

  // ... Send local candidates and credentials to the peer

  // Set the peer's remote credentials and remote candidates
  nice_agent_set_remote_credentials (agent, stream_id, remote_ufrag, remote_pwd);
  nice_agent_set_remote_candidates (agent, stream_id, 1, rcands);

  // ... Wait until the signal new-selected-pair is fired ...
  // Send our message!
  nice_agent_send (agent, stream_id, 1, sizeof(buffer), buffer);

  // Anything received will be received through the cb_nice_recv callback.
  // You must be running a GMainLoop on the global default GMainContext in
  // another thread for this to work.

  // Destroy the object
  g_object_unref(agent);

  &lt;/programlisting&gt;
&lt;/example&gt;

Refer to the examples in the examples/ subdirectory of the libnice source for
more complete examples.</doc>
    </docsection>
    <docsection name="candidate">
      <doc xml:space="preserve">A representation of an ICE candidate. Make sure you read the ICE drafts[1] to
understand correctly the concept of ICE candidates.

[1] http://tools.ietf.org/wg/mmusic/draft-ietf-mmusic-ice/</doc>
    </docsection>
    <function name="candidate_transport_to_string" c:identifier="nice_candidate_transport_to_string" moved-to="Candidate.transport_to_string" version="0.1.18">
      <doc xml:space="preserve">Useful for debugging functions, just returns a static string with the
candidate transport.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a static string with the candidate transport</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="transport" transfer-ownership="none">
          <doc xml:space="preserve">a #NiceCandidateTransport</doc>
          <type name="CandidateTransport" c:type="NiceCandidateTransport"/>
        </parameter>
      </parameters>
    </function>
    <function name="candidate_type_to_string" c:identifier="nice_candidate_type_to_string" moved-to="Candidate.type_to_string" version="0.1.18">
      <doc xml:space="preserve">Useful for debugging functions, just returns a static string with the
candidate type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a static string with the candidate type</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #NiceCandidateType</doc>
          <type name="CandidateType" c:type="NiceCandidateType"/>
        </parameter>
      </parameters>
    </function>
    <function name="component_state_to_string" c:identifier="nice_component_state_to_string" version="0.1.6">
      <doc xml:space="preserve">Returns a string representation of the state, generally to use in debug
messages.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a string representation of @state</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="state" transfer-ownership="none">
          <doc xml:space="preserve">a #NiceComponentState</doc>
          <type name="ComponentState" c:type="NiceComponentState"/>
        </parameter>
      </parameters>
    </function>
    <docsection name="debug">
      <doc xml:space="preserve">&lt;para&gt;Libnice can output a lot of information when debug messages are enabled.
This can significantly help track down problems and/or understand what
it's doing.&lt;/para&gt;

&lt;para&gt;You can enable/disable the debug messages by calling nice_debug_enable()
or nice_debug_disable() and choosing whether you want only ICE debug messages
or also stun debug messages.&lt;/para&gt;

&lt;para&gt;By default, the debug messages are disabled, unless the environment
variable NICE_DEBUG is set, in which case, it must contain a comma separated
list of flags specifying which debug to enable.&lt;/para&gt;
&lt;para&gt; The currently available flags are "nice", "stun", "pseudotcp",
"pseudotcp-verbose" or "all" to enable all debug messages.&lt;/para&gt;
&lt;para&gt; If the 'pseudotcp' flag is enabled, then 'pseudotcp-verbose' gets
automatically disabled. This is to allow the use of the 'all' flag without
having verbose messages from pseudotcp. You can enable verbose debug messages
from the pseudotcp layer by specifying 'pseudotcp-verbose' without the
'pseudotcp' flag.&lt;/para&gt;


&lt;para&gt;This API is unstable and is subject to change at any time...
More flags are to come and a better API to enable/disable each flag
should be added.&lt;/para&gt;</doc>
    </docsection>
    <function name="debug_disable" c:identifier="nice_debug_disable">
      <doc xml:space="preserve">Disables libnice debug output to the terminal</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="with_stun" transfer-ownership="none">
          <doc xml:space="preserve">Also disable stun debugging messages</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_enable" c:identifier="nice_debug_enable">
      <doc xml:space="preserve">Enables libnice debug output to the terminal. Note that the
`G_MESSAGES_DEBUG` and `NICE_DEBUG` environment variables must be set to the
set of logging domains to print, in order for any output to be printed. Set
them to `all` to print all debugging messages, or any of the following
domains:
- `libnice-stun`
- `libnice-tests`
- `libnice-socket`
- `libnice`
- `libnice-pseudotcp`
- `libnice-pseudotcp-verbose`</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="with_stun" transfer-ownership="none">
          <doc xml:space="preserve">Also enable STUN debugging messages</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <docsection name="interfaces">
      <doc xml:space="preserve">These utility functions allow the discovery of local network interfaces
in a portable manner, they also allow finding the local ip addresses or
the address allocated to a network interface.</doc>
    </docsection>
    <function name="interfaces_get_ip_for_interface" c:identifier="nice_interfaces_get_ip_for_interface">
      <doc xml:space="preserve">Retrieves the IP address of an interface by its name. If this fails, %NULL
is returned.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a newly-allocated string with the IP
address</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:space="preserve">name of local interface</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="interfaces_get_local_interfaces" c:identifier="nice_interfaces_get_local_interfaces">
      <doc xml:space="preserve">Get the list of local interfaces</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated #GList of
strings. The caller must free it.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="utf8"/>
        </type>
      </return-value>
    </function>
    <function name="interfaces_get_local_ips" c:identifier="nice_interfaces_get_local_ips">
      <doc xml:space="preserve">Get a list of local ipv4 interface addresses</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated #GList of
strings. The caller must free it.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="include_loopback" transfer-ownership="none">
          <doc xml:space="preserve">Include any loopback devices</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="pseudo_tcp_set_debug_level" c:identifier="pseudo_tcp_set_debug_level" version="0.0.11">
      <doc xml:space="preserve">Sets the debug level to enable/disable normal/verbose debug messages.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="level" transfer-ownership="none">
          <doc xml:space="preserve">The level of debug to set</doc>
          <type name="PseudoTcpDebugLevel" c:type="PseudoTcpDebugLevel"/>
        </parameter>
      </parameters>
    </function>
    <docsection name="pseudotcp">
      <doc xml:space="preserve">The #PseudoTcpSocket is an object implementing a Pseudo Tcp Socket for use
over UDP.
The socket will implement a subset of the TCP stack to allow for a reliable
transport over non-reliable sockets (such as UDP).

See the file tests/test-pseudotcp.c in the source package for an example
of how to use the object.</doc>
    </docsection>
  </namespace>
</repository>
