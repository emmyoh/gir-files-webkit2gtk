<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="json-glib-1.0"/>
  <c:include name="json-glib/json-glib.h"/>
  <namespace name="Json" version="1.0" shared-library="libjson-glib-1.0.so.0" c:identifier-prefixes="Json" c:symbol-prefixes="json">
    <record name="Array" c:type="JsonArray" glib:type-name="JsonArray" glib:get-type="json_array_get_type" c:symbol-prefix="array">
      <doc xml:space="preserve">`JsonArray` is the representation of the array type inside JSON.

A `JsonArray` contains [struct@Json.Node] elements, which may contain
fundamental types, other arrays or objects.

Since arrays can be arbitrarily big, copying them can be expensive; for
this reason, they are reference counted. You can control the lifetime of
a `JsonArray` using [method@Json.Array.ref] and [method@Json.Array.unref].

To append an element, use [method@Json.Array.add_element].

To extract an element at a given index, use [method@Json.Array.get_element].

To retrieve the entire array in list form, use [method@Json.Array.get_elements].

To retrieve the length of the array, use [method@Json.Array.get_length].</doc>
      <constructor name="new" c:identifier="json_array_new">
        <doc xml:space="preserve">Creates a new array.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created array</doc>
          <type name="Array" c:type="JsonArray*"/>
        </return-value>
      </constructor>
      <constructor name="sized_new" c:identifier="json_array_sized_new">
        <doc xml:space="preserve">Creates a new array with `n_elements` slots already allocated.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created array</doc>
          <type name="Array" c:type="JsonArray*"/>
        </return-value>
        <parameters>
          <parameter name="n_elements" transfer-ownership="none">
            <doc xml:space="preserve">number of slots to pre-allocate</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_array_element" c:identifier="json_array_add_array_element" version="0.8">
        <doc xml:space="preserve">Conveniently adds an array element into an array.

If `value` is `NULL`, a `null` element will be added instead.

See also: [method@Json.Array.add_element], [method@Json.Node.take_array]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the array to add</doc>
            <type name="Array" c:type="JsonArray*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_boolean_element" c:identifier="json_array_add_boolean_element" version="0.8">
        <doc xml:space="preserve">Conveniently adds the given boolean value into an array.

See also: [method@Json.Array.add_element], [method@Json.Node.set_boolean]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the boolean value to add</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_double_element" c:identifier="json_array_add_double_element" version="0.8">
        <doc xml:space="preserve">Conveniently adds the given floating point value into an array.

See also: [method@Json.Array.add_element], [method@Json.Node.set_double]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the floating point value to add</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_element" c:identifier="json_array_add_element">
        <doc xml:space="preserve">Appends the given `node` inside an array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="node" transfer-ownership="full">
            <doc xml:space="preserve">the element to add</doc>
            <type name="Node" c:type="JsonNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_int_element" c:identifier="json_array_add_int_element" version="0.8">
        <doc xml:space="preserve">Conveniently adds the given integer value into an array.

See also: [method@Json.Array.add_element], [method@Json.Node.set_int]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the integer value to add</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_null_element" c:identifier="json_array_add_null_element" version="0.8">
        <doc xml:space="preserve">Conveniently adds a `null` element into an array

See also: [method@Json.Array.add_element], `JSON_NODE_NULL`</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="add_object_element" c:identifier="json_array_add_object_element" version="0.8">
        <doc xml:space="preserve">Conveniently adds an object into an array.

If `value` is `NULL`, a `null` element will be added instead.

See also: [method@Json.Array.add_element], [method@Json.Node.take_object]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the object to add</doc>
            <type name="Object" c:type="JsonObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_string_element" c:identifier="json_array_add_string_element" version="0.8">
        <doc xml:space="preserve">Conveniently adds the given string value into an array.

See also: [method@Json.Array.add_element], [method@Json.Node.set_string]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the string value to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_element" c:identifier="json_array_dup_element" version="0.6">
        <doc xml:space="preserve">Retrieves a copy of the element at the given position in the array.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of the element at the given position</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the element to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="json_array_equal" version="1.2">
        <doc xml:space="preserve">Check whether two arrays are equal.

Equality is defined as:

 - the array have the same number of elements
 - the values of elements in corresponding positions are equal</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the arrays are equal, and `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">another JSON array</doc>
            <type name="Array" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_element" c:identifier="json_array_foreach_element" version="0.8">
        <doc xml:space="preserve">Iterates over all elements of an array, and calls a function on
each one of them.

It is safe to change the value of an element of the array while
iterating over it, but it is not safe to add or remove elements
from the array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the function to be called on each element</doc>
            <type name="ArrayForeach" c:type="JsonArrayForeach"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to be passed to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_array_element" c:identifier="json_array_get_array_element" version="0.8">
        <doc xml:space="preserve">Conveniently retrieves the array at the given position inside an array.

See also: [method@Json.Array.get_element], [method@Json.Node.get_array]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the array</doc>
          <type name="Array" c:type="JsonArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the element to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_boolean_element" c:identifier="json_array_get_boolean_element" version="0.8">
        <doc xml:space="preserve">Conveniently retrieves the boolean value of the element at the given
position inside an array.

See also: [method@Json.Array.get_element], [method@Json.Node.get_boolean]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the boolean value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the element to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double_element" c:identifier="json_array_get_double_element" version="0.8">
        <doc xml:space="preserve">Conveniently retrieves the floating point value of the element at
the given position inside an array.

See also: [method@Json.Array.get_element], [method@Json.Node.get_double]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the floating point value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the element to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_element" c:identifier="json_array_get_element">
        <doc xml:space="preserve">Retrieves the element at the given position in the array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the element at the given position</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the element to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_elements" c:identifier="json_array_get_elements">
        <doc xml:space="preserve">Retrieves all the elements of an array as a list of nodes.</doc>
        <return-value transfer-ownership="container" nullable="1">
          <doc xml:space="preserve">the elements
  of the array</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Node"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_int_element" c:identifier="json_array_get_int_element" version="0.8">
        <doc xml:space="preserve">Conveniently retrieves the integer value of the element at the given
position inside an array.

See also: [method@Json.Array.get_element], [method@Json.Node.get_int]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the integer value</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the element to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="json_array_get_length">
        <doc xml:space="preserve">Retrieves the length of the given array</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the array</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_null_element" c:identifier="json_array_get_null_element" version="0.8">
        <doc xml:space="preserve">Conveniently checks whether the element at the given position inside the
array contains a `null` value.

See also: [method@Json.Array.get_element], [method@Json.Node.is_null]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the element is `null`</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the element to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_object_element" c:identifier="json_array_get_object_element" version="0.8">
        <doc xml:space="preserve">Conveniently retrieves the object at the given position inside an array.

See also: [method@Json.Array.get_element], [method@Json.Node.get_object]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the object</doc>
          <type name="Object" c:type="JsonObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the element to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_string_element" c:identifier="json_array_get_string_element" version="0.8">
        <doc xml:space="preserve">Conveniently retrieves the string value of the element at the given
position inside an array.

See also: [method@Json.Array.get_element], [method@Json.Node.get_string]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the string value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the element to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="json_array_hash" version="1.2">
        <doc xml:space="preserve">Calculates a hash value for the given `key`.

The hash is calculated over the array and all its elements, recursively.

If the array is immutable, this is a fast operation; otherwise, it scales
proportionally with the length of the array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">hash value for the key</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array to hash</doc>
            <type name="Array" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_immutable" c:identifier="json_array_is_immutable" version="1.2">
        <doc xml:space="preserve">Check whether the given `array` has been marked as immutable by calling
[method@Json.Array.seal] on it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the array is immutable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="json_array_ref">
        <doc xml:space="preserve">Acquires a reference on the given array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the passed array, with the reference count
  increased by one</doc>
          <type name="Array" c:type="JsonArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">the array to reference</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_element" c:identifier="json_array_remove_element">
        <doc xml:space="preserve">Removes the element at the given position inside an array.

This function will release the reference held on the element.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the position of the element to be removed</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="seal" c:identifier="json_array_seal" version="1.2">
        <doc xml:space="preserve">Seals the given array, making it immutable to further changes.

This function will recursively seal all elements in the array too.

If the `array` is already immutable, this is a no-op.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">the array to seal</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="json_array_unref">
        <doc xml:space="preserve">Releases a reference on the given array.

If the reference count reaches zero, the array is destroyed and all
its allocated resources are freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">the array to unreference</doc>
            <type name="Array" c:type="JsonArray*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="ArrayForeach" c:type="JsonArrayForeach" version="0.8">
      <doc xml:space="preserve">The function to be passed to [method@Json.Array.foreach_element].

You should not add or remove elements to and from @array within
this function.

It is safe to change the value of @element_node.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">the iterated JSON array</doc>
          <type name="Array" c:type="JsonArray*"/>
        </parameter>
        <parameter name="index_" transfer-ownership="none">
          <doc xml:space="preserve">the index of the element</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="element_node" transfer-ownership="none">
          <doc xml:space="preserve">the value of the element at the given @index_</doc>
          <type name="Node" c:type="JsonNode*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">data passed to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="BUILDER" c:identifier="JSON_BUILDER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BUILDER_CLASS" c:identifier="JSON_BUILDER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BUILDER_GET_CLASS" c:identifier="JSON_BUILDER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <callback name="BoxedDeserializeFunc" c:type="JsonBoxedDeserializeFunc" version="0.10">
      <doc xml:space="preserve">Deserializes the contents of the passed `JsonNode` into a `GBoxed`, for instance:

```c
static gpointer
my_point_deserialize (JsonNode *node)
{
  double x = 0.0, y = 0.0;

  if (JSON_NODE_HOLDS_ARRAY (node))
    {
      JsonArray *array = json_node_get_array (node);

      if (json_array_get_length (array) == 2)
        {
          x = json_array_get_double_element (array, 0);
          y = json_array_get_double_element (array, 1);
        }
    }
  else if (JSON_NODE_HOLDS_OBJECT (node))
    {
      JsonObject *obj = json_node_get_object (node);

      x = json_object_get_double_member_with_default (obj, "x", 0.0);
      y = json_object_get_double_member_with_default (obj, "y", 0.0);
    }

  // my_point_new() is defined elsewhere
  return my_point_new (x, y);
}
```</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the newly created boxed structure</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a node tree representing a boxed data</doc>
          <type name="Node" c:type="JsonNode*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BoxedSerializeFunc" c:type="JsonBoxedSerializeFunc" version="0.10">
      <doc xml:space="preserve">Serializes the passed `GBoxed` and stores it inside a `JsonNode`, for instance:

```c
static JsonNode *
my_point_serialize (gconstpointer boxed)
{
  const MyPoint *point = boxed;

  g_autoptr(JsonBuilder) builder = json_builder_new ();

  json_builder_begin_object (builder);
  json_builder_set_member_name (builder, "x");
  json_builder_add_double_value (builder, point-&gt;x);
  json_builder_set_member_name (builder, "y");
  json_builder_add_double_value (builder, point-&gt;y);
  json_builder_end_object (builder);

  return json_builder_get_root (builder);
}
```</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly created JSON node tree representing the boxed data</doc>
        <type name="Node" c:type="JsonNode*"/>
      </return-value>
      <parameters>
        <parameter name="boxed" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a boxed data structure</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Builder" c:symbol-prefix="builder" c:type="JsonBuilder" parent="GObject.Object" glib:type-name="JsonBuilder" glib:get-type="json_builder_get_type" glib:type-struct="BuilderClass">
      <doc xml:space="preserve">`JsonBuilder` provides an object for generating a JSON tree.

The root of the JSON tree can be either a [struct@Json.Object] or a [struct@Json.Array].
Thus the first call must necessarily be either
[method@Json.Builder.begin_object] or [method@Json.Builder.begin_array].

For convenience to language bindings, most `JsonBuilder` method return the
instance, making it easy to chain function calls.

## Using `JsonBuilder`

```c
g_autoptr(JsonBuilder) builder = json_builder_new ();

json_builder_begin_object (builder);

json_builder_set_member_name (builder, "url");
json_builder_add_string_value (builder, "http://www.gnome.org/img/flash/two-thirty.png");

json_builder_set_member_name (builder, "size");
json_builder_begin_array (builder);
json_builder_add_int_value (builder, 652);
json_builder_add_int_value (builder, 242);
json_builder_end_array (builder);

json_builder_end_object (builder);

g_autoptr(JsonNode) root = json_builder_get_root (builder);

g_autoptr(JsonGenerator) gen = json_generator_new ();
json_generator_set_root (gen, root);
g_autofree char *str = json_generator_to_data (gen, NULL);

// str now contains the following JSON data
// { "url" : "http://www.gnome.org/img/flash/two-thirty.png", "size" : [ 652, 242 ] }
```</doc>
      <constructor name="new" c:identifier="json_builder_new">
        <doc xml:space="preserve">Creates a new `JsonBuilder`.

You can use this object to generate a JSON tree and obtain the root node.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created builder instance</doc>
          <type name="Builder" c:type="JsonBuilder*"/>
        </return-value>
      </constructor>
      <constructor name="new_immutable" c:identifier="json_builder_new_immutable" version="1.2">
        <doc xml:space="preserve">Creates a new, immutable `JsonBuilder` instance.

It is equivalent to setting the [property@Json.Builder:immutable] property
set to `TRUE` at construction time.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly create builder instance</doc>
          <type name="Builder" c:type="JsonBuilder*"/>
        </return-value>
      </constructor>
      <method name="add_boolean_value" c:identifier="json_builder_add_boolean_value">
        <doc xml:space="preserve">Adds a boolean value to the currently open object member or array.

If called after [method@Json.Builder.set_member_name], sets the given value
as the value of the current member in the open object; otherwise, the value
is appended to the elements of the open array.

See also: [method@Json.Builder.add_value]</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the builder instance</doc>
          <type name="Builder" c:type="JsonBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a builder</doc>
            <type name="Builder" c:type="JsonBuilder*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value of the member or element</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_double_value" c:identifier="json_builder_add_double_value">
        <doc xml:space="preserve">Adds a floating point value to the currently open object member or array.

If called after [method@Json.Builder.set_member_name], sets the given value
as the value of the current member in the open object; otherwise, the value
is appended to the elements of the open array.

See also: [method@Json.Builder.add_value]</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the builder instance</doc>
          <type name="Builder" c:type="JsonBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a builder</doc>
            <type name="Builder" c:type="JsonBuilder*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value of the member or element</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_int_value" c:identifier="json_builder_add_int_value">
        <doc xml:space="preserve">Adds an integer value to the currently open object member or array.

If called after [method@Json.Builder.set_member_name], sets the given value
as the value of the current member in the open object; otherwise, the value
is appended to the elements of the open array.

See also: [method@Json.Builder.add_value]</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the builder instance</doc>
          <type name="Builder" c:type="JsonBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a builder</doc>
            <type name="Builder" c:type="JsonBuilder*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value of the member or element</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_null_value" c:identifier="json_builder_add_null_value">
        <doc xml:space="preserve">Adds a null value to the currently open object member or array.

If called after [method@Json.Builder.set_member_name], sets the given value
as the value of the current member in the open object; otherwise, the value
is appended to the elements of the open array.

See also: [method@Json.Builder.add_value]</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the builder instance</doc>
          <type name="Builder" c:type="JsonBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a builder</doc>
            <type name="Builder" c:type="JsonBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="add_string_value" c:identifier="json_builder_add_string_value">
        <doc xml:space="preserve">Adds a boolean value to the currently open object member or array.

If called after [method@Json.Builder.set_member_name], sets the given value
as the value of the current member in the open object; otherwise, the value
is appended to the elements of the open array.

See also: [method@Json.Builder.add_value]</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the builder instance</doc>
          <type name="Builder" c:type="JsonBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a builder</doc>
            <type name="Builder" c:type="JsonBuilder*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value of the member or element</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_value" c:identifier="json_builder_add_value">
        <doc xml:space="preserve">Adds a value to the currently open object member or array.

If called after [method@Json.Builder.set_member_name], sets the given node
as the value of the current member in the open object; otherwise, the node
is appended to the elements of the open array.

The builder will take ownership of the node.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the builder instance</doc>
          <type name="Builder" c:type="JsonBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a builder</doc>
            <type name="Builder" c:type="JsonBuilder*"/>
          </instance-parameter>
          <parameter name="node" transfer-ownership="full">
            <doc xml:space="preserve">the value of the member or element</doc>
            <type name="Node" c:type="JsonNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="begin_array" c:identifier="json_builder_begin_array">
        <doc xml:space="preserve">Opens an array inside the given builder.

You can add a new element to the array by using [method@Json.Builder.add_value].

Once you added all elements to the array, you must call
[method@Json.Builder.end_array] to close the array.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the builder instance</doc>
          <type name="Builder" c:type="JsonBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a builder</doc>
            <type name="Builder" c:type="JsonBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="begin_object" c:identifier="json_builder_begin_object">
        <doc xml:space="preserve">Opens an object inside the given builder.

You can add a new member to the object by using [method@Json.Builder.set_member_name],
followed by [method@Json.Builder.add_value].

Once you added all members to the object, you must call [method@Json.Builder.end_object]
to close the object.

If the builder is in an inconsistent state, this function will return `NULL`.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the builder instance</doc>
          <type name="Builder" c:type="JsonBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a builder</doc>
            <type name="Builder" c:type="JsonBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="end_array" c:identifier="json_builder_end_array">
        <doc xml:space="preserve">Closes the array inside the given builder that was opened by the most
recent call to [method@Json.Builder.begin_array].

This function cannot be called after [method@Json.Builder.set_member_name].</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the builder instance</doc>
          <type name="Builder" c:type="JsonBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a builder</doc>
            <type name="Builder" c:type="JsonBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="end_object" c:identifier="json_builder_end_object">
        <doc xml:space="preserve">Closes the object inside the given builder that was opened by the most
recent call to [method@Json.Builder.begin_object].

This function cannot be called after [method@Json.Builder.set_member_name].</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the builder instance</doc>
          <type name="Builder" c:type="JsonBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a builder</doc>
            <type name="Builder" c:type="JsonBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_root" c:identifier="json_builder_get_root">
        <doc xml:space="preserve">Returns the root of the currently constructed tree.

if the build is incomplete (ie: if there are any opened objects, or any
open object members and array elements) then this function will return
`NULL`.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the root node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a builder</doc>
            <type name="Builder" c:type="JsonBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="json_builder_reset">
        <doc xml:space="preserve">Resets the state of the builder back to its initial state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a builder</doc>
            <type name="Builder" c:type="JsonBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_member_name" c:identifier="json_builder_set_member_name">
        <doc xml:space="preserve">Sets the name of the member in an object.

This function must be followed by of these functions:

 - [method@Json.Builder.add_value], to add a scalar value to the member
 - [method@Json.Builder.begin_object], to add an object to the member
 - [method@Json.Builder.begin_array], to add an array to the member

This function can only be called within an open object.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the builder instance</doc>
          <type name="Builder" c:type="JsonBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a builder</doc>
            <type name="Builder" c:type="JsonBuilder*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="immutable" version="1.2" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the tree should be immutable when created.

Making the output immutable on creation avoids the expense
of traversing it to make it immutable later.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BuilderPrivate" c:type="JsonBuilderPrivate*"/>
      </field>
    </class>
    <record name="BuilderClass" c:type="JsonBuilderClass" glib:is-gtype-struct-for="Builder">
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_json_reserved1" introspectable="0">
        <callback name="_json_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_reserved2" introspectable="0">
        <callback name="_json_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="BuilderPrivate" c:type="JsonBuilderPrivate" disguised="1"/>
    <function-macro name="CHECK_VERSION" c:identifier="JSON_CHECK_VERSION" introspectable="0">
      <doc xml:space="preserve">Compile-time version checking. Evaluates to `TRUE` if the version
of JSON-GLib is greater than the required one.</doc>
      <parameters>
        <parameter name="major">
          <doc xml:space="preserve">required major version</doc>
        </parameter>
        <parameter name="minor">
          <doc xml:space="preserve">required minor version</doc>
        </parameter>
        <parameter name="micro">
          <doc xml:space="preserve">required micro version</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_FOR" c:identifier="JSON_DEPRECATED_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_0_FOR" c:identifier="JSON_DEPRECATED_IN_1_0_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_2_FOR" c:identifier="JSON_DEPRECATED_IN_1_2_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_4_FOR" c:identifier="JSON_DEPRECATED_IN_1_4_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_6_FOR" c:identifier="JSON_DEPRECATED_IN_1_6_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ENCODE_VERSION" c:identifier="JSON_ENCODE_VERSION" introspectable="0">
      <doc xml:space="preserve">Encodes a JSON-GLib version in an hexadecimal number, useful for
integer comparisons.</doc>
      <parameters>
        <parameter name="major">
          <doc xml:space="preserve">the major version to encode</doc>
        </parameter>
        <parameter name="minor">
          <doc xml:space="preserve">the minor version to encode</doc>
        </parameter>
        <parameter name="micro">
          <doc xml:space="preserve">the micro version to encode</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GENERATOR" c:identifier="JSON_GENERATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GENERATOR_CLASS" c:identifier="JSON_GENERATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GENERATOR_GET_CLASS" c:identifier="JSON_GENERATOR_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Generator" c:symbol-prefix="generator" c:type="JsonGenerator" parent="GObject.Object" glib:type-name="JsonGenerator" glib:get-type="json_generator_get_type" glib:type-struct="GeneratorClass">
      <doc xml:space="preserve">`JsonGenerator` provides an object for generating a JSON data stream
from a tree of [struct@Json.Node] instances, and put it into a buffer
or a file.</doc>
      <constructor name="new" c:identifier="json_generator_new">
        <doc xml:space="preserve">Creates a new `JsonGenerator`.

You can use this object to generate a JSON data stream starting from a
data object model composed by [struct@Json.Node]s.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created generator instance</doc>
          <type name="Generator" c:type="JsonGenerator*"/>
        </return-value>
      </constructor>
      <method name="get_indent" c:identifier="json_generator_get_indent" glib:get-property="indent" version="0.14">
        <attribute name="org.gtk.Method.get_property" value="indent"/>
        <doc xml:space="preserve">Retrieves the value set using [method@Json.Generator.set_indent].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of repetitions per indentation level</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="generator" transfer-ownership="none">
            <doc xml:space="preserve">a generator</doc>
            <type name="Generator" c:type="JsonGenerator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_indent_char" c:identifier="json_generator_get_indent_char" glib:get-property="indent-char" version="0.14">
        <attribute name="org.gtk.Method.get_property" value="indent-char"/>
        <doc xml:space="preserve">Retrieves the value set using [method@Json.Generator.set_indent_char].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the character to be used when indenting</doc>
          <type name="gunichar" c:type="gunichar"/>
        </return-value>
        <parameters>
          <instance-parameter name="generator" transfer-ownership="none">
            <doc xml:space="preserve">a generator</doc>
            <type name="Generator" c:type="JsonGenerator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pretty" c:identifier="json_generator_get_pretty" glib:get-property="pretty" version="0.14">
        <attribute name="org.gtk.Method.get_property" value="pretty"/>
        <doc xml:space="preserve">Retrieves the value set using [method@Json.Generator.set_pretty].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the generated JSON should be pretty-printed, and
  `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="generator" transfer-ownership="none">
            <doc xml:space="preserve">a generator</doc>
            <type name="Generator" c:type="JsonGenerator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_root" c:identifier="json_generator_get_root" glib:get-property="root" version="0.14">
        <attribute name="org.gtk.Method.get_property" value="root"/>
        <doc xml:space="preserve">Retrieves a pointer to the root node set using
[method@Json.Generator.set_root].</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the root node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="generator" transfer-ownership="none">
            <doc xml:space="preserve">a generator</doc>
            <type name="Generator" c:type="JsonGenerator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_indent" c:identifier="json_generator_set_indent" glib:set-property="indent" version="0.14">
        <attribute name="org.gtk.Method.set_property" value="indent"/>
        <doc xml:space="preserve">Sets the number of repetitions for each indentation level.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="generator" transfer-ownership="none">
            <doc xml:space="preserve">a generator</doc>
            <type name="Generator" c:type="JsonGenerator*"/>
          </instance-parameter>
          <parameter name="indent_level" transfer-ownership="none">
            <doc xml:space="preserve">the number of repetitions of the indentation character
  that should be applied when pretty printing</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_indent_char" c:identifier="json_generator_set_indent_char" glib:set-property="indent-char" version="0.14">
        <attribute name="org.gtk.Method.set_property" value="indent-char"/>
        <doc xml:space="preserve">Sets the character to be used when indenting.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="generator" transfer-ownership="none">
            <doc xml:space="preserve">a generator</doc>
            <type name="Generator" c:type="JsonGenerator*"/>
          </instance-parameter>
          <parameter name="indent_char" transfer-ownership="none">
            <doc xml:space="preserve">a Unicode character to be used when indenting</doc>
            <type name="gunichar" c:type="gunichar"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pretty" c:identifier="json_generator_set_pretty" glib:set-property="pretty" version="0.14">
        <attribute name="org.gtk.Method.set_property" value="pretty"/>
        <doc xml:space="preserve">Sets whether the generated JSON should be pretty printed.

Pretty printing will use indentation character specified in the
[property@Json.Generator:indent-char] property and the spacing
specified in the [property@Json.Generator:indent] property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="generator" transfer-ownership="none">
            <doc xml:space="preserve">a generator</doc>
            <type name="Generator" c:type="JsonGenerator*"/>
          </instance-parameter>
          <parameter name="is_pretty" transfer-ownership="none">
            <doc xml:space="preserve">whether the generated string should be pretty printed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_root" c:identifier="json_generator_set_root" glib:set-property="root">
        <attribute name="org.gtk.Method.set_property" value="root"/>
        <doc xml:space="preserve">Sets the root of the JSON data stream to be serialized by
the given generator.

The passed `node` is copied by the generator object, so it can be
safely freed after calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="generator" transfer-ownership="none">
            <doc xml:space="preserve">a generator</doc>
            <type name="Generator" c:type="JsonGenerator*"/>
          </instance-parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the root node</doc>
            <type name="Node" c:type="JsonNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_data" c:identifier="json_generator_to_data">
        <doc xml:space="preserve">Generates a JSON data stream from @generator and returns it as a
buffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string holding a JSON data stream</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="generator" transfer-ownership="none">
            <doc xml:space="preserve">a generator</doc>
            <type name="Generator" c:type="JsonGenerator*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the length of the returned
  buffer</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_file" c:identifier="json_generator_to_file" throws="1">
        <doc xml:space="preserve">Creates a JSON data stream and puts it inside `filename`, overwriting
the file's current contents.

This operation is atomic, in the sense that the data is written to a
temporary file which is then renamed to the given `filename`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if saving was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="generator" transfer-ownership="none">
            <doc xml:space="preserve">a generator</doc>
            <type name="Generator" c:type="JsonGenerator*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the path to the target file</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_gstring" c:identifier="json_generator_to_gstring" version="1.4">
        <doc xml:space="preserve">Generates a JSON data stream and appends it to the string buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the passed string, updated with
  the generated JSON data</doc>
          <type name="GLib.String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="generator" transfer-ownership="none">
            <doc xml:space="preserve">a generator</doc>
            <type name="Generator" c:type="JsonGenerator*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a string buffer</doc>
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_stream" c:identifier="json_generator_to_stream" version="0.12" throws="1">
        <doc xml:space="preserve">Outputs JSON data and writes it (synchronously) to the given stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the write operation was successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="generator" transfer-ownership="none">
            <doc xml:space="preserve">a generator</doc>
            <type name="Generator" c:type="JsonGenerator*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">the output stream used to write the JSON data</doc>
            <type name="Gio.OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a `GCancellable`</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <property name="indent" writable="1" transfer-ownership="none" setter="set_indent" getter="get_indent">
        <attribute name="org.gtk.Property.get" value="json_generator_get_indent"/>
        <attribute name="org.gtk.Property.set" value="json_generator_set_indent"/>
        <doc xml:space="preserve">Number of spaces to be used to indent when pretty printing.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="indent-char" version="0.6" writable="1" transfer-ownership="none" setter="set_indent_char" getter="get_indent_char">
        <attribute name="org.gtk.Property.get" value="json_generator_get_indent_char"/>
        <attribute name="org.gtk.Property.set" value="json_generator_set_indent_char"/>
        <doc xml:space="preserve">The character that should be used when indenting in pretty print.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="pretty" writable="1" transfer-ownership="none" setter="set_pretty" getter="get_pretty">
        <attribute name="org.gtk.Property.get" value="json_generator_get_pretty"/>
        <attribute name="org.gtk.Property.set" value="json_generator_set_pretty"/>
        <doc xml:space="preserve">Whether the output should be "pretty-printed", with indentation and
newlines.

The indentation level can be controlled by using the
[property@Json.Generator:indent] property.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="root" version="0.4" writable="1" transfer-ownership="none" setter="set_root" getter="get_root">
        <attribute name="org.gtk.Property.get" value="json_generator_get_root"/>
        <attribute name="org.gtk.Property.set" value="json_generator_set_root"/>
        <doc xml:space="preserve">The root node to be used when constructing a JSON data
stream.</doc>
        <type name="Node"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GeneratorPrivate" c:type="JsonGeneratorPrivate*"/>
      </field>
    </class>
    <record name="GeneratorClass" c:type="JsonGeneratorClass" glib:is-gtype-struct-for="Generator">
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_json_reserved1" introspectable="0">
        <callback name="_json_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_reserved2" introspectable="0">
        <callback name="_json_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_reserved3" introspectable="0">
        <callback name="_json_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_reserved4" introspectable="0">
        <callback name="_json_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="GeneratorPrivate" c:type="JsonGeneratorPrivate" disguised="1"/>
    <function-macro name="IS_BUILDER" c:identifier="JSON_IS_BUILDER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BUILDER_CLASS" c:identifier="JSON_IS_BUILDER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GENERATOR" c:identifier="JSON_IS_GENERATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GENERATOR_CLASS" c:identifier="JSON_IS_GENERATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARSER" c:identifier="JSON_IS_PARSER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARSER_CLASS" c:identifier="JSON_IS_PARSER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PATH" c:identifier="JSON_IS_PATH" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_READER" c:identifier="JSON_IS_READER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_READER_CLASS" c:identifier="JSON_IS_READER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SERIALIZABLE" c:identifier="JSON_IS_SERIALIZABLE" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="MAJOR_VERSION" value="1" c:type="JSON_MAJOR_VERSION">
      <doc xml:space="preserve">Json major version component (e.g. 1 if `JSON_VERSION` is "1.2.3")</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MICRO_VERSION" value="7" c:type="JSON_MICRO_VERSION">
      <doc xml:space="preserve">Json micro version component (e.g. 3 if `JSON_VERSION` is "1.2.3")</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MINOR_VERSION" value="6" c:type="JSON_MINOR_VERSION">
      <doc xml:space="preserve">Json minor version component (e.g. 2 if `JSON_VERSION` is "1.2.3")</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="NODE_HOLDS" c:identifier="JSON_NODE_HOLDS" version="0.10" introspectable="0">
      <doc xml:space="preserve">Evaluates to `TRUE` if the node holds the given type.</doc>
      <parameters>
        <parameter name="node">
          <doc xml:space="preserve">the [struct@Json.Node] to check</doc>
        </parameter>
        <parameter name="t">
          <doc xml:space="preserve">the desired [enum@Json.NodeType]</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="NODE_HOLDS_ARRAY" c:identifier="JSON_NODE_HOLDS_ARRAY" version="0.10" introspectable="0">
      <doc xml:space="preserve">Evaluates to `TRUE` if the node holds a JSON array.</doc>
      <parameters>
        <parameter name="node">
          <doc xml:space="preserve">the [struct@Json.Node] to check</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="NODE_HOLDS_NULL" c:identifier="JSON_NODE_HOLDS_NULL" version="0.10" introspectable="0">
      <doc xml:space="preserve">Evaluates to `TRUE` if the node holds `null`.</doc>
      <parameters>
        <parameter name="node">
          <doc xml:space="preserve">the [struct@Json.Node] to check</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="NODE_HOLDS_OBJECT" c:identifier="JSON_NODE_HOLDS_OBJECT" version="0.10" introspectable="0">
      <doc xml:space="preserve">Evaluates to `TRUE` if the node holds a JSON object.</doc>
      <parameters>
        <parameter name="node">
          <doc xml:space="preserve">the [struct@Json.Node] to check</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="NODE_HOLDS_VALUE" c:identifier="JSON_NODE_HOLDS_VALUE" version="0.10" introspectable="0">
      <doc xml:space="preserve">Evaluates to `TRUE` if the node holds a scalar value.</doc>
      <parameters>
        <parameter name="node">
          <doc xml:space="preserve">the [struct@Json.Node] to check</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="NODE_TYPE" c:identifier="JSON_NODE_TYPE" introspectable="0">
      <doc xml:space="preserve">Evaluates to the [enum@Json.NodeType] value contained by the node.</doc>
      <parameters>
        <parameter name="node">
          <doc xml:space="preserve">the [struct@Json.Node] to check</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="Node" c:type="JsonNode" glib:type-name="JsonNode" glib:get-type="json_node_get_type" c:symbol-prefix="node">
      <doc xml:space="preserve">A generic container of JSON data types.

`JsonNode` can contain fundamental types (integers, booleans, floating point
numbers, strings) and complex types (arrays and objects).

When parsing a JSON data stream you extract the root node and walk
the node tree by retrieving the type of data contained inside the
node with the `JSON_NODE_TYPE` macro. If the node contains a fundamental
type you can retrieve a copy of the `GValue` holding it with the
[method@Json.Node.get_value] function, and then use the `GValue` API to extract
the data; if the node contains a complex type you can retrieve the
[struct@Json.Object] or the [struct@Json.Array] using [method@Json.Node.get_object]
or [method@Json.Node.get_array] respectively, and then retrieve the nodes
they contain.

A `JsonNode` may be marked as immutable using [method@Json.Node.seal]. This
marks the node and all its descendents as read-only, and means that
subsequent calls to setter functions (such as [method@Json.Node.set_array])
on them will abort as a programmer error. By marking a node tree as
immutable, it may be referenced in multiple places and its hash value cached
for fast lookups, without the possibility of a value deep within the tree
changing and affecting hash values. Immutable nodes may be passed to
functions which retain a reference to them without needing to take a copy.

A `JsonNode` supports two types of memory management: `malloc`/`free`
semantics, and reference counting semantics. The two may be mixed to a
limited extent: nodes may be allocated (which gives them a reference count
of 1), referenced one or more times, unreferenced exactly that number of
times (using [method@Json.Node.unref]), then either unreferenced exactly
once more or freed (using [method@Json.Node.free]) to destroy them.
The [method@Json.Node.free] function must not be used when a node might
have a reference count not equal to 1. To this end, JSON-GLib uses
[method@Json.Node.copy] and [method@Json.Node.unref] internally.</doc>
      <constructor name="alloc" c:identifier="json_node_alloc" version="0.16">
        <doc xml:space="preserve">Allocates a new, uninitialized node.

Use [method@Json.Node.init] and its variants to initialize the returned value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
      </constructor>
      <constructor name="new" c:identifier="json_node_new">
        <doc xml:space="preserve">Creates a new node holding the given @type.

This is a convenience function for [ctor@Json.Node.alloc] and
[method@Json.Node.init], and it's the equivalent of:

```c
   json_node_init (json_node_alloc (), type);
```</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of the node to create</doc>
            <type name="NodeType" c:type="JsonNodeType"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="json_node_copy">
        <doc xml:space="preserve">Copies @node.

If the node contains complex data types, their reference
counts are increased, regardless of whether the node is mutable or
immutable.

The copy will be immutable if, and only if, @node is immutable. However,
there should be no need to copy an immutable node.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the copied of the given node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to copy</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_array" c:identifier="json_node_dup_array">
        <doc xml:space="preserve">Retrieves the JSON array inside @node.

The reference count of the returned array is increased.

It is a programmer error to call this on a node which doesn&#x2019;t hold an
array value. Use `JSON_NODE_HOLDS_ARRAY` first.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the JSON array with its reference
  count increased.</doc>
          <type name="Array" c:type="JsonArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node holding an array</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_object" c:identifier="json_node_dup_object">
        <doc xml:space="preserve">Retrieves the object inside @node.

The reference count of the returned object is increased.

It is a programmer error to call this on a node which doesn&#x2019;t hold an
object value. Use `JSON_NODE_HOLDS_OBJECT` first.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the JSON object</doc>
          <type name="Object" c:type="JsonObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node holding a JSON object</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_string" c:identifier="json_node_dup_string">
        <doc xml:space="preserve">Gets a copy of the string value stored inside a node.

If the node does not hold a string value, `NULL` is returned.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a copy of the string
  inside the node</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node holding a string</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="json_node_equal" version="1.2">
        <doc xml:space="preserve">Check whether @a and @b are equal node, meaning they have the same
type and same values (checked recursively).

Note that integer values are compared numerically, ignoring type, so a
double value 4.0 is equal to the integer value 4.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if @a and @b are equal; `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a JSON node</doc>
            <type name="Node" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">another JSON node</doc>
            <type name="Node" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="json_node_free">
        <doc xml:space="preserve">Frees the resources allocated by the node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to free</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_array" c:identifier="json_node_get_array">
        <doc xml:space="preserve">Retrieves the JSON array stored inside a node.

It is a programmer error to call this on a node which doesn&#x2019;t hold an
array value. Use `JSON_NODE_HOLDS_ARRAY` first.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the JSON array</doc>
          <type name="Array" c:type="JsonArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node holding an array</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_boolean" c:identifier="json_node_get_boolean">
        <doc xml:space="preserve">Gets the boolean value stored inside a node.

If the node holds an integer or double value which is zero, `FALSE` is
returned; otherwise `TRUE` is returned.

If the node holds a `JSON_NODE_NULL` value or a value of another
non-boolean type, `FALSE` is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a boolean value.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node holding a boolean value</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="json_node_get_double">
        <doc xml:space="preserve">Gets the double value stored inside a node.

If the node holds an integer value, it is returned as a double.

If the node holds a `FALSE` boolean value, `0.0` is returned; otherwise
a non-zero double is returned.

If the node holds a `JSON_NODE_NULL` value or a value of another
non-double type, `0.0` is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a double value.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node holding a floating point value</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_int" c:identifier="json_node_get_int">
        <doc xml:space="preserve">Gets the integer value stored inside a node.

If the node holds a double value, its integer component is returned.

If the node holds a `FALSE` boolean value, `0` is returned; otherwise,
a non-zero integer is returned.

If the node holds a `JSON_NODE_NULL` value or a value of another
non-integer type, `0` is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an integer value.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node holding an integer</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_node_type" c:identifier="json_node_get_node_type" version="0.8">
        <doc xml:space="preserve">Retrieves the type of a @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of the node</doc>
          <type name="NodeType" c:type="JsonNodeType"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to check</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_object" c:identifier="json_node_get_object">
        <doc xml:space="preserve">Retrieves the object stored inside a node.

It is a programmer error to call this on a node which doesn&#x2019;t hold an
object value. Use `JSON_NODE_HOLDS_OBJECT` first.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the JSON object</doc>
          <type name="Object" c:type="JsonObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node holding a JSON object</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent" c:identifier="json_node_get_parent">
        <doc xml:space="preserve">Retrieves the parent node of the given @node.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the parent node, or `NULL` if @node
  is the root node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to query</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="json_node_get_string">
        <doc xml:space="preserve">Gets the string value stored inside a node.

If the node does not hold a string value, `NULL` is returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a string value.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node holding a string</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="json_node_get_value">
        <doc xml:space="preserve">Retrieves a value from a node and copies into @value.

When done using it, call `g_value_unset()` on the `GValue` to free the
associated resources.

It is a programmer error to call this on a node which doesn&#x2019;t hold a scalar
value. Use `JSON_NODE_HOLDS_VALUE` first.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="value" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for an uninitialized value</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value_type" c:identifier="json_node_get_value_type" version="0.4">
        <doc xml:space="preserve">Returns the `GType` of the payload of the node.

For `JSON_NODE_NULL` nodes, the returned type is `G_TYPE_INVALID`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type for the payload</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to check</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="json_node_hash" version="1.2">
        <doc xml:space="preserve">Calculate a hash value for the given @key.

The hash is calculated over the node and its value, recursively. If the node
is immutable, this is a fast operation; otherwise, it scales proportionally
with the size of the node&#x2019;s value (for example, with the number of members
in the JSON object if this node contains an object).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">hash value for @key</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a JSON node to hash</doc>
            <type name="Node" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="json_node_init" version="0.16">
        <doc xml:space="preserve">Initializes a @node to a specific @type.

If the node has already been initialized once, it will be reset to
the given type, and any data contained will be cleared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to initialize</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of JSON node to initialize @node to</doc>
            <type name="NodeType" c:type="JsonNodeType"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_array" c:identifier="json_node_init_array" version="0.16">
        <doc xml:space="preserve">Initializes @node to `JSON_NODE_ARRAY` and sets @array into it.

This function will take a reference on @array.

If the node has already been initialized once, it will be reset to
the given type, and any data contained will be cleared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to initialize</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the JSON array to initialize @node with, or `NULL`</doc>
            <type name="Array" c:type="JsonArray*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_boolean" c:identifier="json_node_init_boolean" version="0.16">
        <doc xml:space="preserve">Initializes @node to `JSON_NODE_VALUE` and sets @value into it.

If the node has already been initialized once, it will be reset to
the given type, and any data contained will be cleared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to initialize</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a boolean value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_double" c:identifier="json_node_init_double" version="0.16">
        <doc xml:space="preserve">Initializes @node to `JSON_NODE_VALUE` and sets @value into it.

If the node has already been initialized once, it will be reset to
the given type, and any data contained will be cleared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to initialize</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a floating point value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_int" c:identifier="json_node_init_int" version="0.16">
        <doc xml:space="preserve">Initializes @node to `JSON_NODE_VALUE` and sets @value into it.

If the node has already been initialized once, it will be reset to
the given type, and any data contained will be cleared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to initialize</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an integer</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_null" c:identifier="json_node_init_null" version="0.16">
        <doc xml:space="preserve">Initializes @node to `JSON_NODE_NULL`.

If the node has already been initialized once, it will be reset to
the given type, and any data contained will be cleared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to initialize</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_object" c:identifier="json_node_init_object" version="0.16">
        <doc xml:space="preserve">Initializes @node to `JSON_NODE_OBJECT` and sets @object into it.

This function will take a reference on @object.

If the node has already been initialized once, it will be reset to
the given type, and any data contained will be cleared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to initialize</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the JSON object to initialize @node with, or `NULL`</doc>
            <type name="Object" c:type="JsonObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_string" c:identifier="json_node_init_string" version="0.16">
        <doc xml:space="preserve">Initializes @node to `JSON_NODE_VALUE` and sets @value into it.

If the node has already been initialized once, it will be reset to
the given type, and any data contained will be cleared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to initialize</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_immutable" c:identifier="json_node_is_immutable" version="1.2">
        <doc xml:space="preserve">Check whether the given @node has been marked as immutable by calling
[method@Json.Node.seal] on it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the @node is immutable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to check</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_null" c:identifier="json_node_is_null" version="0.8">
        <doc xml:space="preserve">Checks whether @node is a `JSON_NODE_NULL`.

A `JSON_NODE_NULL` node is not the same as a `NULL` node; a `JSON_NODE_NULL`
represents a literal `null` value in the JSON tree.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the node is null</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to check</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="json_node_ref" version="1.2">
        <doc xml:space="preserve">Increments the reference count of @node.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a pointer to @node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to reference</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="seal" c:identifier="json_node_seal" version="1.2">
        <doc xml:space="preserve">Seals the given node, making it immutable to further changes.

In order to be sealed, the @node must have a type and value set. The value
will be recursively sealed &#x2014; if the node holds an object, that JSON object
will be sealed, etc.

If the `node` is already immutable, this is a no-op.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to seal</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_array" c:identifier="json_node_set_array">
        <doc xml:space="preserve">Sets @array inside @node.

The reference count of @array is increased.

It is a programmer error to call this on a node which doesn&#x2019;t hold an
array value. Use `JSON_NODE_HOLDS_ARRAY` first.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node initialized to `JSON_NODE_ARRAY`</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_boolean" c:identifier="json_node_set_boolean">
        <doc xml:space="preserve">Sets @value as the boolean content of the @node, replacing any existing
content.

It is an error to call this on an immutable node, or on a node which is not
a value node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node initialized to `JSON_NODE_VALUE`</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a boolean value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_double" c:identifier="json_node_set_double">
        <doc xml:space="preserve">Sets @value as the double content of the @node, replacing any existing
content.

It is an error to call this on an immutable node, or on a node which is not
a value node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node initialized to `JSON_NODE_VALUE`</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a double value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int" c:identifier="json_node_set_int">
        <doc xml:space="preserve">Sets @value as the integer content of the @node, replacing any existing
content.

It is an error to call this on an immutable node, or on a node which is not
a value node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node initialized to `JSON_NODE_VALUE`</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an integer value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_object" c:identifier="json_node_set_object">
        <doc xml:space="preserve">Sets @objects inside @node.

The reference count of @object is increased.

If @object is `NULL`, the node&#x2019;s existing object is cleared.

It is an error to call this on an immutable node, or on a node which is not
an object node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node initialized to `JSON_NODE_OBJECT`</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_parent" c:identifier="json_node_set_parent" version="0.8">
        <doc xml:space="preserve">Sets the parent node for the given `node`.

It is an error to call this with an immutable @parent.

The @node may be immutable.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to change</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="parent" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the parent node</doc>
            <type name="Node" c:type="JsonNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string" c:identifier="json_node_set_string">
        <doc xml:space="preserve">Sets @value as the string content of the @node, replacing any existing
content.

It is an error to call this on an immutable node, or on a node which is not
a value node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node initialized to `JSON_NODE_VALUE`</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a string value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="json_node_set_value">
        <doc xml:space="preserve">Sets a scalar value inside the given node.

The contents of the given `GValue` are copied into the `JsonNode`.

The following `GValue` types have a direct mapping to JSON types:

 - `G_TYPE_INT64`
 - `G_TYPE_DOUBLE`
 - `G_TYPE_BOOLEAN`
 - `G_TYPE_STRING`

JSON-GLib will also automatically promote the following `GValue` types:

 - `G_TYPE_INT` to `G_TYPE_INT64`
 - `G_TYPE_FLOAT` to `G_TYPE_DOUBLE`

It is an error to call this on an immutable node, or on a node which is not
a value node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node initialized to `JSON_NODE_VALUE`</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to set</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_array" c:identifier="json_node_take_array">
        <doc xml:space="preserve">Sets @array inside @node.

The reference count of @array is not increased.

It is a programmer error to call this on a node which doesn&#x2019;t hold an
array value. Use `JSON_NODE_HOLDS_ARRAY` first.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node initialized to `JSON_NODE_ARRAY`</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="full">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array" c:type="JsonArray*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_object" c:identifier="json_node_take_object">
        <doc xml:space="preserve">Sets @object inside @node.

The reference count of @object is not increased.

It is an error to call this on an immutable node, or on a node which is not
an object node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node initialized to `JSON_NODE_OBJECT`</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="full">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="type_name" c:identifier="json_node_type_name">
        <doc xml:space="preserve">Retrieves the user readable name of the data type contained by @node.

**Note**: The name is only meant for debugging purposes, and there is no
guarantee the name will stay the same across different versions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the name of the type</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a node</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="json_node_unref" version="1.2">
        <doc xml:space="preserve">Decrements the reference count of @node.

If the reference count reaches zero, the node is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="full">
            <doc xml:space="preserve">the node to unreference</doc>
            <type name="Node" c:type="JsonNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="NodeType" glib:type-name="JsonNodeType" glib:get-type="json_node_type_get_type" c:type="JsonNodeType">
      <doc xml:space="preserve">Indicates the content of a node.</doc>
      <member name="object" value="0" c:identifier="JSON_NODE_OBJECT" glib:nick="object" glib:name="JSON_NODE_OBJECT">
        <doc xml:space="preserve">The node contains a JSON object</doc>
      </member>
      <member name="array" value="1" c:identifier="JSON_NODE_ARRAY" glib:nick="array" glib:name="JSON_NODE_ARRAY">
        <doc xml:space="preserve">The node contains a JSON array</doc>
      </member>
      <member name="value" value="2" c:identifier="JSON_NODE_VALUE" glib:nick="value" glib:name="JSON_NODE_VALUE">
        <doc xml:space="preserve">The node contains a fundamental type</doc>
      </member>
      <member name="null" value="3" c:identifier="JSON_NODE_NULL" glib:nick="null" glib:name="JSON_NODE_NULL">
        <doc xml:space="preserve">Special type, for nodes containing null</doc>
      </member>
    </enumeration>
    <record name="Object" c:type="JsonObject" glib:type-name="JsonObject" glib:get-type="json_object_get_type" c:symbol-prefix="object">
      <doc xml:space="preserve">`JsonObject` is the representation of the object type inside JSON.

A `JsonObject` contains [struct@Json.Node] "members", which may contain
fundamental types, arrays or other objects; each member of an object is
accessed using a unique string, or "name".

Since objects can be arbitrarily big, copying them can be expensive; for
this reason they are reference counted. You can control the lifetime of
a `JsonObject` using [method@Json.Object.ref] and [method@Json.Object.unref].

To add or overwrite a member with a given name, use [method@Json.Object.set_member].

To extract a member with a given name, use [method@Json.Object.get_member].

To retrieve the list of members, use [method@Json.Object.get_members].

To retrieve the size of the object (that is, the number of members it has),
use [method@Json.Object.get_size].</doc>
      <constructor name="new" c:identifier="json_object_new">
        <doc xml:space="preserve">Creates a new object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created object</doc>
          <type name="Object" c:type="JsonObject*"/>
        </return-value>
      </constructor>
      <method name="add_member" c:identifier="json_object_add_member" deprecated="1" deprecated-version="0.8">
        <doc xml:space="preserve">Adds a new member for the given name and value into an object.

This function will return if the object already contains a member
with the same name.</doc>
        <doc-deprecated xml:space="preserve">Use [method@Json.Object.set_member] instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="node" transfer-ownership="full">
            <doc xml:space="preserve">the value of the member</doc>
            <type name="Node" c:type="JsonNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_member" c:identifier="json_object_dup_member" version="0.6">
        <doc xml:space="preserve">Retrieves a copy of the value of the given member inside an object.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a copy of the value for the
  requested object member</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the JSON object member to access</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="json_object_equal" version="1.2">
        <doc xml:space="preserve">Check whether @a and @b are equal objects, meaning they have the same
set of members, and the values of corresponding members are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if @a and @b are equal, and `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">another JSON object</doc>
            <type name="Object" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_member" c:identifier="json_object_foreach_member" version="0.8">
        <doc xml:space="preserve">Iterates over all members of @object and calls @func on
each one of them.

It is safe to change the value of a member of the oobject
from within the iterator function, but it is not safe to add or
remove members from the object.

The order in which the object members are iterated is the
insertion order.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the function to be called on each member</doc>
            <type name="ObjectForeach" c:type="JsonObjectForeach"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to be passed to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_array_member" c:identifier="json_object_get_array_member" version="0.8">
        <doc xml:space="preserve">Convenience function that retrieves the array
stored in @member_name of @object. It is an error to specify a
@member_name which does not exist.

If @member_name contains `null`, then this function will return `NULL`.

See also: [method@Json.Object.get_member], [method@Json.Object.has_member]</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the array inside the object's member</doc>
          <type name="Array" c:type="JsonArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_boolean_member" c:identifier="json_object_get_boolean_member" version="0.8">
        <doc xml:space="preserve">Convenience function that retrieves the boolean value
stored in @member_name of @object. It is an error to specify a
@member_name which does not exist.

See also: [method@Json.Object.get_boolean_member_with_default],
  [method@Json.Object.get_member], [method@Json.Object.has_member]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the boolean value of the object's member</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_boolean_member_with_default" c:identifier="json_object_get_boolean_member_with_default" version="1.6">
        <doc xml:space="preserve">Convenience function that retrieves the boolean value
stored in @member_name of @object.

If @member_name does not exist, does not contain a scalar value,
or contains `null`, then @default_value is returned instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the boolean value of the object's member, or the
  given default</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the @object member</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="default_value" transfer-ownership="none">
            <doc xml:space="preserve">the value to return if @member_name is not valid</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double_member" c:identifier="json_object_get_double_member" version="0.8">
        <doc xml:space="preserve">Convenience function that retrieves the floating point value
stored in @member_name of @object. It is an error to specify a
@member_name which does not exist.

See also: [method@Json.Object.get_double_member_with_default],
  [method@Json.Object.get_member], [method@Json.Object.has_member]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the floating point value of the object's member</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double_member_with_default" c:identifier="json_object_get_double_member_with_default" version="1.6">
        <doc xml:space="preserve">Convenience function that retrieves the floating point value
stored in @member_name of @object.

If @member_name does not exist, does not contain a scalar value,
or contains `null`, then @default_value is returned instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the floating point value of the object's member, or the
  given default</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the @object member</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="default_value" transfer-ownership="none">
            <doc xml:space="preserve">the value to return if @member_name is not valid</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int_member" c:identifier="json_object_get_int_member" version="0.8">
        <doc xml:space="preserve">Convenience function that retrieves the integer value
stored in @member_name of @object. It is an error to specify a
@member_name which does not exist.

See also: [method@Json.Object.get_int_member_with_default],
  [method@Json.Object.get_member], [method@Json.Object.has_member]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the integer value of the object's member</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the object member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int_member_with_default" c:identifier="json_object_get_int_member_with_default" version="1.6">
        <doc xml:space="preserve">Convenience function that retrieves the integer value
stored in @member_name of @object.

If @member_name does not exist, does not contain a scalar value,
or contains `null`, then @default_value is returned instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the integer value of the object's member, or the
  given default</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the object member</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="default_value" transfer-ownership="none">
            <doc xml:space="preserve">the value to return if @member_name is not valid</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_member" c:identifier="json_object_get_member">
        <doc xml:space="preserve">Retrieves the value of the given member inside an object.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the value for the
  requested object member</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the JSON object member to access</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_members" c:identifier="json_object_get_members">
        <doc xml:space="preserve">Retrieves all the names of the members of an object.

You can obtain the value for each member by iterating the returned list
and calling [method@Json.Object.get_member].</doc>
        <return-value transfer-ownership="container" nullable="1">
          <doc xml:space="preserve">the
  member names of the object</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_null_member" c:identifier="json_object_get_null_member" version="0.8">
        <doc xml:space="preserve">Convenience function that checks whether the value
stored in @member_name of @object is null. It is an error to
specify a @member_name which does not exist.

See also: [method@Json.Object.get_member], [method@Json.Object.has_member]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the value is `null`</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_object_member" c:identifier="json_object_get_object_member" version="0.8">
        <doc xml:space="preserve">Convenience function that retrieves the object
stored in @member_name of @object. It is an error to specify a @member_name
which does not exist.

If @member_name contains `null`, then this function will return `NULL`.

See also: [method@Json.Object.get_member], [method@Json.Object.has_member]</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the object inside the object's member</doc>
          <type name="Object" c:type="JsonObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="json_object_get_size">
        <doc xml:space="preserve">Retrieves the number of members of a JSON object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of members</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string_member" c:identifier="json_object_get_string_member" version="0.8">
        <doc xml:space="preserve">Convenience function that retrieves the string value
stored in @member_name of @object. It is an error to specify a
@member_name that does not exist.

See also: [method@Json.Object.get_string_member_with_default],
  [method@Json.Object.get_member], [method@Json.Object.has_member]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the string value of the object's member</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_string_member_with_default" c:identifier="json_object_get_string_member_with_default" version="1.6">
        <doc xml:space="preserve">Convenience function that retrieves the string value
stored in @member_name of @object.

If @member_name does not exist, does not contain a scalar value,
or contains `null`, then @default_value is returned instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the string value of the object's member, or the
  given default</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the @object member</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="default_value" transfer-ownership="none">
            <doc xml:space="preserve">the value to return if @member_name is not valid</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_values" c:identifier="json_object_get_values">
        <doc xml:space="preserve">Retrieves all the values of the members of an object.</doc>
        <return-value transfer-ownership="container" nullable="1">
          <doc xml:space="preserve">the
  member values of the object</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Node"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_member" c:identifier="json_object_has_member">
        <doc xml:space="preserve">Checks whether @object has a member named @member_name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the JSON object has the requested member</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of a JSON object member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="json_object_hash" version="1.2">
        <doc xml:space="preserve">Calculate a hash value for the given @key (a JSON object).

The hash is calculated over the object and all its members, recursively. If
the object is immutable, this is a fast operation; otherwise, it scales
proportionally with the number of members in the object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">hash value for @key</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object to hash</doc>
            <type name="Object" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_immutable" c:identifier="json_object_is_immutable" version="1.2">
        <doc xml:space="preserve">Checks whether the given object has been marked as immutable by calling
[method@Json.Object.seal] on it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the object is immutable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="json_object_ref">
        <doc xml:space="preserve">Acquires a reference on the given object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the given object, with the reference count
  increased by one.</doc>
          <type name="Object" c:type="JsonObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_member" c:identifier="json_object_remove_member">
        <doc xml:space="preserve">Removes @member_name from @object, freeing its allocated resources.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member to remove</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="seal" c:identifier="json_object_seal" version="1.2">
        <doc xml:space="preserve">Seals the object, making it immutable to further changes.

This function will recursively seal all members of the object too.

If the object is already immutable, this is a no-op.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_array_member" c:identifier="json_object_set_array_member" version="0.8">
        <doc xml:space="preserve">Convenience function for setting an object member with an array value.

See also: [method@Json.Object.set_member], [method@Json.Node.take_array]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="full">
            <doc xml:space="preserve">the value of the member</doc>
            <type name="Array" c:type="JsonArray*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_boolean_member" c:identifier="json_object_set_boolean_member" version="0.8">
        <doc xml:space="preserve">Convenience function for setting an object member with a boolean value.

See also: [method@Json.Object.set_member], [method@Json.Node.init_boolean]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value of the member</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_double_member" c:identifier="json_object_set_double_member" version="0.8">
        <doc xml:space="preserve">Convenience function for setting an object member with a floating point value.

See also: [method@Json.Object.set_member], [method@Json.Node.init_double]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value of the member</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int_member" c:identifier="json_object_set_int_member" version="0.8">
        <doc xml:space="preserve">Convenience function for setting an object member with an integer value.

See also: [method@Json.Object.set_member], [method@Json.Node.init_int]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value of the member</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_member" c:identifier="json_object_set_member" version="0.8">
        <doc xml:space="preserve">Sets the value of a member inside an object.

If the object does not have a member with the given name, a new member
is created.

If the object already has a member with the given name, the current
value is overwritten with the new.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="node" transfer-ownership="full">
            <doc xml:space="preserve">the value of the member</doc>
            <type name="Node" c:type="JsonNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_null_member" c:identifier="json_object_set_null_member" version="0.8">
        <doc xml:space="preserve">Convenience function for setting an object member with a `null` value.

See also: [method@Json.Object.set_member], [method@Json.Node.init_null]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_object_member" c:identifier="json_object_set_object_member" version="0.8">
        <doc xml:space="preserve">Convenience function for setting an object member with an object value.

See also: [method@Json.Object.set_member], [method@Json.Node.take_object]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="full">
            <doc xml:space="preserve">the value of the member</doc>
            <type name="Object" c:type="JsonObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string_member" c:identifier="json_object_set_string_member" version="0.8">
        <doc xml:space="preserve">Convenience function for setting an object member with a string value.

See also: [method@Json.Object.set_member], [method@Json.Node.init_string]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value of the member</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="json_object_unref">
        <doc xml:space="preserve">Releases a reference on the given object.

If the reference count reaches zero, the object is destroyed and
all its resources are freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object</doc>
            <type name="Object" c:type="JsonObject*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="ObjectForeach" c:type="JsonObjectForeach" version="0.8">
      <doc xml:space="preserve">The function to be passed to [method@Json.Object.foreach_member].

You should not add or remove members to and from @object within
this function.

It is safe to change the value of @member_node.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">the iterated JSON object</doc>
          <type name="Object" c:type="JsonObject*"/>
        </parameter>
        <parameter name="member_name" transfer-ownership="none">
          <doc xml:space="preserve">the name of the member</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="member_node" transfer-ownership="none">
          <doc xml:space="preserve">the value of the member</doc>
          <type name="Node" c:type="JsonNode*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">data passed to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ObjectIter" c:type="JsonObjectIter" version="1.2">
      <doc xml:space="preserve">An iterator object used to iterate over the members of a JSON object.

`JsonObjectIter` must be allocated on the stack and initialised using
[method@Json.ObjectIter.init] or [method@Json.ObjectIter.init_ordered].

The iterator is invalidated if the object is modified during
iteration.

All the fields in the `JsonObjectIter` structure are private and should
never be accessed directly.</doc>
      <field name="priv_pointer" readable="0" private="1">
        <array zero-terminated="0" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="priv_int" readable="0" private="1">
        <array zero-terminated="0" fixed-size="2">
          <type name="gint" c:type="int"/>
        </array>
      </field>
      <field name="priv_boolean" readable="0" private="1">
        <array zero-terminated="0" fixed-size="1">
          <type name="gboolean" c:type="gboolean"/>
        </array>
      </field>
      <method name="init" c:identifier="json_object_iter_init" version="1.2">
        <doc xml:space="preserve">Initialises the @iter and associate it with @object.

```c
JsonObjectIter iter;
const gchar *member_name;
JsonNode *member_node;

json_object_iter_init (&amp;iter, some_object);
while (json_object_iter_next (&amp;iter, &amp;member_name, &amp;member_node))
  {
    // Do something with @member_name and @member_node.
  }
```

The iterator initialized with this function will iterate the
members of the object in an undefined order.

See also: [method@Json.ObjectIter.init_ordered]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialised JSON object iterator</doc>
            <type name="ObjectIter" c:type="JsonObjectIter*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the JSON object to iterate over</doc>
            <type name="Object" c:type="JsonObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_ordered" c:identifier="json_object_iter_init_ordered" version="1.6">
        <doc xml:space="preserve">Initialises the @iter and associate it with @object.

```c
JsonObjectIter iter;
const gchar *member_name;
JsonNode *member_node;

json_object_iter_init_ordered (&amp;iter, some_object);
while (json_object_iter_next_ordered (&amp;iter, &amp;member_name, &amp;member_node))
  {
    // Do something with @member_name and @member_node.
  }
```

See also: [method@Json.ObjectIter.init]</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialised iterator</doc>
            <type name="ObjectIter" c:type="JsonObjectIter*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the JSON object to iterate over</doc>
            <type name="Object" c:type="JsonObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="json_object_iter_next" version="1.2">
        <doc xml:space="preserve">Advances the iterator and retrieves the next member in the object.

If the end of the object is reached, `FALSE` is returned and @member_name
and @member_node are set to invalid values. After that point, the @iter
is invalid.

The order in which members are returned by the iterator is undefined. The
iterator is invalidated if the object is modified during iteration.

You must use this function with an iterator initialized with
[method@Json.ObjectIter.init]; using this function with an iterator
initialized with [method@Json.ObjectIter.init_ordered] yields undefined
behavior.

See also: [method@Json.ObjectIter.next_ordered]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if @member_name and @member_node are valid; `FALSE` if
  there are no more members</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a JSON object iterator</doc>
            <type name="ObjectIter" c:type="JsonObjectIter*"/>
          </instance-parameter>
          <parameter name="member_name" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return
   location for the member name, or %NULL to ignore</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="member_node" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return
   location for the member value, or %NULL to ignore</doc>
            <type name="Node" c:type="JsonNode**"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_ordered" c:identifier="json_object_iter_next_ordered" version="1.6">
        <doc xml:space="preserve">Advances the iterator and retrieves the next member in the object.

If the end of the object is reached, `FALSE` is returned and @member_name and
@member_node are set to invalid values. After that point, the @iter is invalid.

The order in which members are returned by the iterator is the same order in
which the members were added to the `JsonObject`. The iterator is invalidated
if its `JsonObject` is modified during iteration.

You must use this function with an iterator initialized with
[method@Json.ObjectIter.init_ordered]; using this function with an iterator
initialized with [method@Json.ObjectIter.init] yields undefined behavior.

See also: [method@Json.ObjectIter.next]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE `if @member_name and @member_node are valid; `FALSE` if the end
   of the object has been reached</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an ordered JSON object iterator</doc>
            <type name="ObjectIter" c:type="JsonObjectIter*"/>
          </instance-parameter>
          <parameter name="member_name" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return
   location for the member name, or %NULL to ignore</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
          <parameter name="member_node" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return
   location for the member value, or %NULL to ignore</doc>
            <type name="Node" c:type="JsonNode**"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <function-macro name="PARSER" c:identifier="JSON_PARSER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARSER_CLASS" c:identifier="JSON_PARSER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARSER_GET_CLASS" c:identifier="JSON_PARSER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PATH" c:identifier="JSON_PATH" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Parser" c:symbol-prefix="parser" c:type="JsonParser" parent="GObject.Object" glib:type-name="JsonParser" glib:get-type="json_parser_get_type" glib:type-struct="ParserClass">
      <doc xml:space="preserve">`JsonParser` provides an object for parsing a JSON data stream, either
inside a file or inside a static buffer.

## Using `JsonParser`

The `JsonParser` API is fairly simple:

```c
gboolean
parse_json (const char *filename)
{
  g_autoptr(JsonParser) parser = json_parser_new ();
  g_autoptr(GError) error = NULL

  json_parser_load_from_file (parser, filename, &amp;error);
  if (error != NULL)
    {
      g_critical ("Unable to parse '%s': %s", filename, error-&gt;message);
      return FALSE;
    }

  g_autoptr(JsonNode) root = json_parser_get_root (parser);

  // manipulate the object tree from the root node

  return TRUE
}
```

By default, the entire process of loading the data and parsing it is
synchronous; the [method@Json.Parser.load_from_stream_async()] API will
load the data asynchronously, but parse it in the main context as the
signals of the parser must be emitted in the same thread. If you do
not use signals, and you wish to also parse the JSON data without blocking,
you should use a `GTask` and the synchronous `JsonParser` API inside the
task itself.</doc>
      <constructor name="new" c:identifier="json_parser_new">
        <doc xml:space="preserve">Creates a new JSON parser.

You can use the `JsonParser` to load a JSON stream from either a file or a
buffer and then walk the hierarchy using the data types API.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created parser</doc>
          <type name="Parser" c:type="JsonParser*"/>
        </return-value>
      </constructor>
      <constructor name="new_immutable" c:identifier="json_parser_new_immutable" version="1.2">
        <doc xml:space="preserve">Creates a new parser instance with its [property@Json.Parser:immutable]
property set to `TRUE` to create immutable output trees.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created parser</doc>
          <type name="Parser" c:type="JsonParser*"/>
        </return-value>
      </constructor>
      <virtual-method name="array_element">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <type name="Array" c:type="JsonArray*"/>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="array_end">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <type name="Array" c:type="JsonArray*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="array_start">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="error">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="object_end">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="JsonObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="object_member">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="JsonObject*"/>
          </parameter>
          <parameter name="member_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="object_start">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="parse_end">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="parse_start">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_current_line" c:identifier="json_parser_get_current_line">
        <doc xml:space="preserve">Retrieves the line currently parsed, starting from 1.

This function has defined behaviour only while parsing; calling this
function from outside the signal handlers emitted by the parser will
yield 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the currently parsed line, or 0.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_current_pos" c:identifier="json_parser_get_current_pos">
        <doc xml:space="preserve">Retrieves the current position inside the current line, starting
from 0.

This function has defined behaviour only while parsing; calling this
function from outside the signal handlers emitted by the parser will
yield 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the position in the current line, or 0.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_root" c:identifier="json_parser_get_root">
        <doc xml:space="preserve">Retrieves the top level node from the parsed JSON stream.

If the parser input was an empty string, or if parsing failed, the root
will be `NULL`. It will also be `NULL` if it has been stolen using
[method@Json.Parser.steal_root].</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the root node.</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_assignment" c:identifier="json_parser_has_assignment" version="0.4">
        <doc xml:space="preserve">A JSON data stream might sometimes contain an assignment, like:

```
var _json_data = { "member_name" : [ ...
```

even though it would technically constitute a violation of the RFC.

`JsonParser` will ignore the left hand identifier and parse the right
hand value of the assignment. `JsonParser` will record, though, the
existence of the assignment in the data stream and the variable name
used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if there was an assignment, and `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
          <parameter name="variable_name" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">the variable name</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_data" c:identifier="json_parser_load_from_data" throws="1">
        <doc xml:space="preserve">Loads a JSON stream from a buffer and parses it.

You can call this function multiple times with the same parser, but the
contents of the parser will be destroyed each time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the buffer was succesfully parsed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the buffer to parse</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of the buffer, or -1 if it is `NUL` terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_file" c:identifier="json_parser_load_from_file" throws="1">
        <doc xml:space="preserve">Loads a JSON stream from the content of `filename` and parses it.

If the file is large or shared between processes,
[method@Json.Parser.load_from_mapped_file] may be a more efficient
way to load it.

See also: [method@Json.Parser.load_from_data]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the file was successfully loaded and parsed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the path for the file to parse</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_mapped_file" c:identifier="json_parser_load_from_mapped_file" version="1.6" throws="1">
        <doc xml:space="preserve">Loads a JSON stream from the content of `filename` and parses it.

Unlike [method@Json.Parser.load_from_file], `filename` will be memory
mapped as read-only and parsed. `filename` will be unmapped before this
function returns.

If mapping or reading the file fails, a `G_FILE_ERROR` will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the file was successfully loaded and parsed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the path for the file to parse</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_stream" c:identifier="json_parser_load_from_stream" version="0.12" throws="1">
        <doc xml:space="preserve">Loads the contents of an input stream and parses them.

If `cancellable` is not `NULL`, then the operation can be cancelled by
triggering the cancellable object from another thread. If the
operation was cancelled, `G_IO_ERROR_CANCELLED` will be set
on the given `error`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the data stream was successfully read and
  parsed, and `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">the input stream with the JSON data</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_stream_async" c:identifier="json_parser_load_from_stream_async" version="0.12">
        <doc xml:space="preserve">Asynchronously reads the contents of a stream.

For more details, see [method@Json.Parser.load_from_stream], which is the
synchronous version of this call.

When the operation is finished, @callback will be called. You should
then call [method@Json.Parser.load_from_stream_finish] to get the result
of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">the input stream with the JSON data</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">the function to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_stream_finish" c:identifier="json_parser_load_from_stream_finish" version="0.12" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous stream loading started with
[method@Json.Parser.load_from_stream_async].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the content of the stream was successfully retrieved
  and parsed, and `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result of the asynchronous operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal_root" c:identifier="json_parser_steal_root" version="1.4">
        <doc xml:space="preserve">Steals the top level node from the parsed JSON stream.

This will be `NULL` in the same situations as [method@Json.Parser.get_root]
return `NULL`.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the root node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="JsonParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="immutable" version="1.2" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the tree built by the parser should be immutable
when created.

Making the output immutable on creation avoids the expense
of traversing it to make it immutable later.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ParserPrivate" c:type="JsonParserPrivate*"/>
      </field>
      <glib:signal name="array-element" when="last">
        <doc xml:space="preserve">The `::array-element` signal is emitted each time a parser
has successfully parsed a single element of a JSON array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a JSON array</doc>
            <type name="Array"/>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the newly parsed array element</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="array-end" when="last">
        <doc xml:space="preserve">The `::array-end` signal is emitted each time a parser
has successfully parsed an entire JSON array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">the parsed JSON array</doc>
            <type name="Array"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="array-start" when="last">
        <doc xml:space="preserve">The `::array-start` signal is emitted each time a parser
starts parsing a JSON array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="error" when="last">
        <doc xml:space="preserve">The `::error` signal is emitted each time a parser encounters
an error in a JSON stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the error</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="object-end" when="last">
        <doc xml:space="preserve">The `::object-end` signal is emitted each time a parser
has successfully parsed an entire JSON object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the parsed JSON object</doc>
            <type name="Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="object-member" when="last">
        <doc xml:space="preserve">The `::object-member` signal is emitted each time a parser
has successfully parsed a single member of a JSON object</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the JSON object being parsed</doc>
            <type name="Object"/>
          </parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the newly parsed member</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="object-start" when="last">
        <doc xml:space="preserve">This signal is emitted each time a parser starts parsing a JSON object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="parse-end" when="last">
        <doc xml:space="preserve">This signal is emitted when a parser successfully finished parsing a
JSON data stream</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="parse-start" when="last">
        <doc xml:space="preserve">This signal is emitted when a parser starts parsing a JSON data stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ParserClass" c:type="JsonParserClass" glib:is-gtype-struct-for="Parser">
      <doc xml:space="preserve">The class structure for the JsonParser type.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="parse_start">
        <callback name="parse_start">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="Parser" c:type="JsonParser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="object_start">
        <callback name="object_start">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="Parser" c:type="JsonParser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="object_member">
        <callback name="object_member">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="Parser" c:type="JsonParser*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="JsonObject*"/>
            </parameter>
            <parameter name="member_name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="object_end">
        <callback name="object_end">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="Parser" c:type="JsonParser*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="JsonObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="array_start">
        <callback name="array_start">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="Parser" c:type="JsonParser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="array_element">
        <callback name="array_element">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="Parser" c:type="JsonParser*"/>
            </parameter>
            <parameter name="array" transfer-ownership="none">
              <type name="Array" c:type="JsonArray*"/>
            </parameter>
            <parameter name="index_" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="array_end">
        <callback name="array_end">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="Parser" c:type="JsonParser*"/>
            </parameter>
            <parameter name="array" transfer-ownership="none">
              <type name="Array" c:type="JsonArray*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="parse_end">
        <callback name="parse_end">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="Parser" c:type="JsonParser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="error">
        <callback name="error">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="Parser" c:type="JsonParser*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="const GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_json_reserved1" introspectable="0">
        <callback name="_json_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_reserved2" introspectable="0">
        <callback name="_json_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_reserved3" introspectable="0">
        <callback name="_json_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_reserved4" introspectable="0">
        <callback name="_json_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_reserved5" introspectable="0">
        <callback name="_json_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_reserved6" introspectable="0">
        <callback name="_json_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_reserved7" introspectable="0">
        <callback name="_json_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_reserved8" introspectable="0">
        <callback name="_json_reserved8">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="ParserError" glib:type-name="JsonParserError" glib:get-type="json_parser_error_get_type" c:type="JsonParserError" glib:error-domain="json-parser-error-quark">
      <doc xml:space="preserve">Error codes for `JSON_PARSER_ERROR`.

This enumeration can be extended at later date</doc>
      <member name="parse" value="0" c:identifier="JSON_PARSER_ERROR_PARSE" glib:nick="parse" glib:name="JSON_PARSER_ERROR_PARSE">
        <doc xml:space="preserve">parse error</doc>
      </member>
      <member name="trailing_comma" value="1" c:identifier="JSON_PARSER_ERROR_TRAILING_COMMA" glib:nick="trailing-comma" glib:name="JSON_PARSER_ERROR_TRAILING_COMMA">
        <doc xml:space="preserve">unexpected trailing comma</doc>
      </member>
      <member name="missing_comma" value="2" c:identifier="JSON_PARSER_ERROR_MISSING_COMMA" glib:nick="missing-comma" glib:name="JSON_PARSER_ERROR_MISSING_COMMA">
        <doc xml:space="preserve">expected comma</doc>
      </member>
      <member name="missing_colon" value="3" c:identifier="JSON_PARSER_ERROR_MISSING_COLON" glib:nick="missing-colon" glib:name="JSON_PARSER_ERROR_MISSING_COLON">
        <doc xml:space="preserve">expected colon</doc>
      </member>
      <member name="invalid_bareword" value="4" c:identifier="JSON_PARSER_ERROR_INVALID_BAREWORD" glib:nick="invalid-bareword" glib:name="JSON_PARSER_ERROR_INVALID_BAREWORD">
        <doc xml:space="preserve">invalid bareword</doc>
      </member>
      <member name="empty_member_name" value="5" c:identifier="JSON_PARSER_ERROR_EMPTY_MEMBER_NAME" glib:nick="empty-member-name" glib:name="JSON_PARSER_ERROR_EMPTY_MEMBER_NAME">
        <doc xml:space="preserve">empty member name (Since: 0.16)</doc>
      </member>
      <member name="invalid_data" value="6" c:identifier="JSON_PARSER_ERROR_INVALID_DATA" glib:nick="invalid-data" glib:name="JSON_PARSER_ERROR_INVALID_DATA">
        <doc xml:space="preserve">invalid data (Since: 0.18)</doc>
      </member>
      <member name="unknown" value="7" c:identifier="JSON_PARSER_ERROR_UNKNOWN" glib:nick="unknown" glib:name="JSON_PARSER_ERROR_UNKNOWN">
        <doc xml:space="preserve">unknown error</doc>
      </member>
      <function name="quark" c:identifier="json_parser_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="ParserPrivate" c:type="JsonParserPrivate" disguised="1"/>
    <class name="Path" c:symbol-prefix="path" c:type="JsonPath" version="0.14" parent="GObject.Object" glib:type-name="JsonPath" glib:get-type="json_path_get_type" glib:type-struct="PathClass">
      <doc xml:space="preserve">`JsonPath` is a simple class implementing the JSONPath syntax for extracting
data out of a JSON tree.

While the semantics of the JSONPath expressions are heavily borrowed by the
XPath specification for XML, the syntax follows the ECMAScript origins of
JSON.

Once a `JsonPath` instance has been created, it has to compile a JSONPath
expression using [method@Json.Path.compile] before being able to match it to
a JSON tree; the same `JsonPath` instance can be used to match multiple JSON
trees. It it also possible to compile a new JSONPath expression using the
same `JsonPath` instance; the previous expression will be discarded only if
the compilation of the new expression is successful.

The simple convenience function [func@Json.Path.query] can be used for
one-off matching.

## Syntax of the JSONPath expressions

A JSONPath expression is composed by path indices and operators.
Each path index can either be a member name or an element index inside
a JSON tree. A JSONPath expression must start with the `$` operator; each
path index is separated using either the dot notation or the bracket
notation, e.g.:

```
// dot notation
$.store.book[0].title

// bracket notation
$['store']['book'][0]['title']
```

The available operators are:

* The `$` character represents the root node of the JSON tree, and
  matches the entire document.

* Child nodes can either be matched using `.` or `[]`. For instance,
  both `$.store.book` and `$['store']['book']` match the contents of
  the book member of the store object.

* Child nodes can be reached without specifying the whole tree structure
  through the recursive descent operator, or `..`. For instance,
  `$..author` matches all author member in every object.

* Child nodes can grouped through the wildcard operator, or `*`. For
  instance, `$.store.book[*].author` matches all author members of any
  object element contained in the book array of the store object.

* Element nodes can be accessed using their index (starting from zero)
  in the subscript operator `[]`. For instance, `$.store.book[0]` matches
  the first element of the book array of the store object.

* Subsets of element nodes can be accessed using the set notation
  operator `[i,j,...]`. For instance, `$.store.book[0,2]` matches the
  elements 0 and 2 (the first and third) of the book array of the store
  object.

* Slices of element nodes can be accessed using the slice notation
  operation `[start:end:step]`. If start is omitted, the starting index
  of the slice is implied to be zero; if end is omitted, the ending index
  of the slice is implied to be the length of the array; if step is
  omitted, the step of the slice is implied to be 1. For instance,
  `$.store.book[:2]` matches the first two elements of the book array
  of the store object.

More information about JSONPath is available on Stefan G&#xF6;ssner's
[JSONPath website](http://goessner.net/articles/JsonPath/).

## Example of JSONPath matches

The following example shows some of the results of using `JsonPath`
on a JSON tree. We use the following JSON description of a bookstore:

```json
{ "store": {
    "book": [
      { "category": "reference", "author": "Nigel Rees",
        "title": "Sayings of the Century", "price": "8.95"  },
      { "category": "fiction", "author": "Evelyn Waugh",
        "title": "Sword of Honour", "price": "12.99" },
      { "category": "fiction", "author": "Herman Melville",
        "title": "Moby Dick", "isbn": "0-553-21311-3",
        "price": "8.99" },
      { "category": "fiction", "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings", "isbn": "0-395-19395-8",
        "price": "22.99" }
    ],
    "bicycle": { "color": "red", "price": "19.95" }
  }
}
```

We can parse the JSON using [class@Json.Parser]:

```c
JsonParser *parser = json_parser_new ();
json_parser_load_from_data (parser, json_data, -1, NULL);
```

If we run the following code:

```c
JsonNode *result;
JsonPath *path = json_path_new ();
json_path_compile (path, "$.store..author", NULL);
result = json_path_match (path, json_parser_get_root (parser));
```

The `result` node will contain an array with all values of the
author member of the objects in the JSON tree. If we use a
[class@Json.Generator] to convert the `result` node to a string
and print it:

```c
JsonGenerator *generator = json_generator_new ();
json_generator_set_root (generator, result);
char *str = json_generator_to_data (generator, NULL);
g_print ("Results: %s\n", str);
```

The output will be:

```json
["Nigel Rees","Evelyn Waugh","Herman Melville","J. R. R. Tolkien"]
```</doc>
      <constructor name="new" c:identifier="json_path_new" version="0.14">
        <doc xml:space="preserve">Creates a new `JsonPath` instance.

Once created, the `JsonPath` object should be used with
[method@Json.Path.compile] and [method@Json.Path.match].</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created path</doc>
          <type name="Path" c:type="JsonPath*"/>
        </return-value>
      </constructor>
      <function name="query" c:identifier="json_path_query" version="0.14" throws="1">
        <doc xml:space="preserve">Queries a JSON tree using a JSONPath expression.

This function is a simple wrapper around [ctor@Json.Path.new],
[method@Json.Path.compile], and [method@Json.Path.match]. It implicitly
creates a `JsonPath` instance, compiles the given expression and matches
it against the JSON tree pointed by `root`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-created node of type
  `JSON_NODE_ARRAY` containing the array of matching nodes</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <parameter name="expression" transfer-ownership="none">
            <doc xml:space="preserve">a JSONPath expression</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">the root of a JSON tree</doc>
            <type name="Node" c:type="JsonNode*"/>
          </parameter>
        </parameters>
      </function>
      <method name="compile" c:identifier="json_path_compile" version="0.14" throws="1">
        <doc xml:space="preserve">Validates and decomposes the given expression.

A JSONPath expression must be compiled before calling
[method@Json.Path.match].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the compilation was successful, and `FALSE`
  otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a path</doc>
            <type name="Path" c:type="JsonPath*"/>
          </instance-parameter>
          <parameter name="expression" transfer-ownership="none">
            <doc xml:space="preserve">a JSONPath expression</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="match" c:identifier="json_path_match" version="0.14">
        <doc xml:space="preserve">Matches the JSON tree pointed by `root` using the expression compiled
into the `JsonPath`.

The nodes matching the expression will be copied into an array.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-created node of type
  `JSON_NODE_ARRAY` containing the array of matching nodes</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a compiled path</doc>
            <type name="Path" c:type="JsonPath*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">the root node of the JSON data to match</doc>
            <type name="Node" c:type="JsonNode*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="PathClass" c:type="JsonPathClass" disguised="1" glib:is-gtype-struct-for="Path"/>
    <enumeration name="PathError" version="0.14" glib:type-name="JsonPathError" glib:get-type="json_path_error_get_type" c:type="JsonPathError" glib:error-domain="json-path-error-quark">
      <doc xml:space="preserve">Error codes for `JSON_PATH_ERROR`.

This enumeration can be extended at later date</doc>
      <member name="query" value="0" c:identifier="JSON_PATH_ERROR_INVALID_QUERY" glib:nick="query" glib:name="JSON_PATH_ERROR_INVALID_QUERY">
        <doc xml:space="preserve">Invalid query</doc>
      </member>
      <function name="quark" c:identifier="json_path_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <function-macro name="READER" c:identifier="JSON_READER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="READER_CLASS" c:identifier="JSON_READER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="READER_GET_CLASS" c:identifier="JSON_READER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Reader" c:symbol-prefix="reader" c:type="JsonReader" version="0.12" parent="GObject.Object" glib:type-name="JsonReader" glib:get-type="json_reader_get_type" glib:type-struct="ReaderClass">
      <doc xml:space="preserve">`JsonReader` provides a simple, cursor-based API for parsing a JSON DOM.

It is similar, in spirit, to the XML Reader API.

## Using `JsonReader`

```c
g_autoptr(JsonParser) parser = json_parser_new ();

// str is defined elsewhere
json_parser_load_from_data (parser, str, -1, NULL);

g_autoptr(JsonReader) reader = json_reader_new (json_parser_get_root (parser));

json_reader_read_member (reader, "url");
  const char *url = json_reader_get_string_value (reader);
  json_reader_end_member (reader);

json_reader_read_member (reader, "size");
  json_reader_read_element (reader, 0);
    int width = json_reader_get_int_value (reader);
    json_reader_end_element (reader);
  json_reader_read_element (reader, 1);
    int height = json_reader_get_int_value (reader);
    json_reader_end_element (reader);
  json_reader_end_member (reader);
```

## Error handling

In case of error, `JsonReader` will be set in an error state; all subsequent
calls will simply be ignored until a function that resets the error state is
called, e.g.:

```c
// ask for the 7th element; if the element does not exist, the
// reader will be put in an error state
json_reader_read_element (reader, 6);

// in case of error, this will return NULL, otherwise it will
// return the value of the element
str = json_reader_get_string_value (value);

// this function resets the error state if any was set
json_reader_end_element (reader);
```

If you want to detect the error state as soon as possible, you can use
[method@Json.Reader.get_error]:

```c
// like the example above, but in this case we print out the
// error immediately
if (!json_reader_read_element (reader, 6))
  {
    const GError *error = json_reader_get_error (reader);
    g_print ("Unable to read the element: %s", error-&gt;message);
  }
```</doc>
      <constructor name="new" c:identifier="json_reader_new" version="0.12">
        <doc xml:space="preserve">Creates a new reader.

You can use this object to read the contents of the JSON tree starting
from the given node.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created reader</doc>
          <type name="Reader" c:type="JsonReader*"/>
        </return-value>
        <parameters>
          <parameter name="node" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the root node</doc>
            <type name="Node" c:type="JsonNode*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="count_elements" c:identifier="json_reader_count_elements" version="0.12">
        <doc xml:space="preserve">Counts the elements of the current position, if the reader is
positioned on an array.

In case of failure, the reader is set to an error state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of elements, or -1.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="count_members" c:identifier="json_reader_count_members" version="0.12">
        <doc xml:space="preserve">Counts the members of the current position, if the reader is
positioned on an object.

In case of failure, the reader is set to an error state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of members, or -1</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="end_element" c:identifier="json_reader_end_element" version="0.12">
        <doc xml:space="preserve">Moves the cursor back to the previous node after being positioned
inside an array.

This function resets the error state of the reader, if any was set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="end_member" c:identifier="json_reader_end_member" version="0.12">
        <doc xml:space="preserve">Moves the cursor back to the previous node after being positioned
inside an object.

This function resets the error state of the reader, if any was set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_boolean_value" c:identifier="json_reader_get_boolean_value" version="0.12">
        <doc xml:space="preserve">Retrieves the boolean value of the current position of the reader.

See also: [method@Json.Reader.get_value]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the boolean value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_double_value" c:identifier="json_reader_get_double_value" version="0.12">
        <doc xml:space="preserve">Retrieves the floating point value of the current position of the reader.

See also: [method@Json.Reader.get_value]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the floating point value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_error" c:identifier="json_reader_get_error" version="0.12">
        <doc xml:space="preserve">Retrieves the error currently set on the reader.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the current error</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_int_value" c:identifier="json_reader_get_int_value" version="0.12">
        <doc xml:space="preserve">Retrieves the integer value of the current position of the reader.

See also: [method@Json.Reader.get_value]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the integer value</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_member_name" c:identifier="json_reader_get_member_name" version="0.14">
        <doc xml:space="preserve">Retrieves the name of the current member.

In case of failure, the reader is set to an error state.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the name of the member</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_null_value" c:identifier="json_reader_get_null_value" version="0.12">
        <doc xml:space="preserve">Checks whether the value of the current position of the reader is `null`.

See also: [method@Json.Reader.get_value]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if `null` is set, and `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string_value" c:identifier="json_reader_get_string_value" version="0.12">
        <doc xml:space="preserve">Retrieves the string value of the current position of the reader.

See also: [method@Json.Reader.get_value]</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the string value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="json_reader_get_value" version="0.12">
        <doc xml:space="preserve">Retrieves the value node at the current position of the reader.

If the current position does not contain a scalar value, the reader
is set to an error state.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the current value node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_array" c:identifier="json_reader_is_array" version="0.12">
        <doc xml:space="preserve">Checks whether the reader is currently on an array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the reader is on an array</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_object" c:identifier="json_reader_is_object" version="0.12">
        <doc xml:space="preserve">Checks whether the reader is currently on an object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the reader is on an object</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_value" c:identifier="json_reader_is_value" version="0.12">
        <doc xml:space="preserve">Checks whether the reader is currently on a value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the reader is on a value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="list_members" c:identifier="json_reader_list_members" version="0.14">
        <doc xml:space="preserve">Retrieves a list of member names from the current position, if the reader
is positioned on an object.

In case of failure, the reader is set to an error state.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the members of
  the object</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="read_element" c:identifier="json_reader_read_element" version="0.12">
        <doc xml:space="preserve">Advances the cursor of the reader to the element of the array or
the member of the object at the given position.

You can use [method@Json.Reader.get_value] and its wrapper functions to
retrieve the value of the element; for instance, the following code will
read the first element of the array at the current cursor position:

```c
json_reader_read_element (reader, 0);
int_value = json_reader_get_int_value (reader);
```

After reading the value, you should call [method@Json.Reader.end_element]
to reposition the cursor inside the reader, e.g.:

```c
const char *str_value = NULL;

json_reader_read_element (reader, 1);
str_value = json_reader_get_string_value (reader);
json_reader_end_element (reader);

json_reader_read_element (reader, 2);
str_value = json_reader_get_string_value (reader);
json_reader_end_element (reader);
```

If the reader is not currently on an array or an object, or if the index is
bigger than the size of the array or the object, the reader will be
put in an error state until [method@Json.Reader.end_element] is called. This
means that, if used conditionally, [method@Json.Reader.end_element] must be
called on all branches:

```c
if (!json_reader_read_element (reader, 1))
  {
    g_propagate_error (error, json_reader_get_error (reader));
    json_reader_end_element (reader);
    return FALSE;
  }
else
  {
    const char *str_value = json_reader_get_string_value (reader);
    json_reader_end_element (reader);

    // use str_value

    return TRUE;
  }
```c</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` on success, and `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the element</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_member" c:identifier="json_reader_read_member" version="0.12">
        <doc xml:space="preserve">Advances the cursor of the reader to the `member_name` of the object at
the current position.

You can use [method@Json.Reader.get_value] and its wrapper functions to
retrieve the value of the member; for instance:

```c
json_reader_read_member (reader, "width");
width = json_reader_get_int_value (reader);
```

After reading the value, `json_reader_end_member()` should be called to
reposition the cursor inside the reader, e.g.:

```c
json_reader_read_member (reader, "author");
author = json_reader_get_string_value (reader);
json_reader_end_member (reader);

json_reader_read_member (reader, "title");
title = json_reader_get_string_value (reader);
json_reader_end_member (reader);
```

If the reader is not currently on an object, or if the `member_name` is not
defined in the object, the reader will be put in an error state until
[method@Json.Reader.end_member] is called. This means that if used
conditionally, [method@Json.Reader.end_member] must be called on all branches:

```c
if (!json_reader_read_member (reader, "title"))
  {
    g_propagate_error (error, json_reader_get_error (reader));
    json_reader_end_member (reader);
    return FALSE;
  }
else
  {
    const char *str_value = json_reader_get_string_value (reader);
    json_reader_end_member (reader);

    // use str_value

    return TRUE;
  }
```</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` on success, and `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
          <parameter name="member_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the member to read</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_root" c:identifier="json_reader_set_root" glib:set-property="root" version="0.12">
        <attribute name="org.gtk.Method.set_property" value="root"/>
        <doc xml:space="preserve">Sets the root node of the JSON tree to be read by @reader.

The reader will take a copy of the node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">a reader</doc>
            <type name="Reader" c:type="JsonReader*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the root node</doc>
            <type name="Node" c:type="JsonNode*"/>
          </parameter>
        </parameters>
      </method>
      <property name="root" version="0.12" writable="1" construct="1" transfer-ownership="none" setter="set_root">
        <attribute name="org.gtk.Property.set" value="json_reader_set_root"/>
        <doc xml:space="preserve">The root of the JSON tree that the reader should read.</doc>
        <type name="Node"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ReaderPrivate" c:type="JsonReaderPrivate*"/>
      </field>
    </class>
    <record name="ReaderClass" c:type="JsonReaderClass" glib:is-gtype-struct-for="Reader">
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_json_padding0" introspectable="0">
        <callback name="_json_padding0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_padding1" introspectable="0">
        <callback name="_json_padding1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_padding2" introspectable="0">
        <callback name="_json_padding2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_padding3" introspectable="0">
        <callback name="_json_padding3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_json_padding4" introspectable="0">
        <callback name="_json_padding4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="ReaderError" version="0.12" glib:type-name="JsonReaderError" glib:get-type="json_reader_error_get_type" c:type="JsonReaderError" glib:error-domain="json-reader-error-quark">
      <doc xml:space="preserve">Error codes for `JSON_READER_ERROR`.

This enumeration can be extended at later date</doc>
      <member name="no_array" value="0" c:identifier="JSON_READER_ERROR_NO_ARRAY" glib:nick="no-array" glib:name="JSON_READER_ERROR_NO_ARRAY">
        <doc xml:space="preserve">No array found at the current position</doc>
      </member>
      <member name="invalid_index" value="1" c:identifier="JSON_READER_ERROR_INVALID_INDEX" glib:nick="invalid-index" glib:name="JSON_READER_ERROR_INVALID_INDEX">
        <doc xml:space="preserve">Index out of bounds</doc>
      </member>
      <member name="no_object" value="2" c:identifier="JSON_READER_ERROR_NO_OBJECT" glib:nick="no-object" glib:name="JSON_READER_ERROR_NO_OBJECT">
        <doc xml:space="preserve">No object found at the current position</doc>
      </member>
      <member name="invalid_member" value="3" c:identifier="JSON_READER_ERROR_INVALID_MEMBER" glib:nick="invalid-member" glib:name="JSON_READER_ERROR_INVALID_MEMBER">
        <doc xml:space="preserve">Member not found</doc>
      </member>
      <member name="invalid_node" value="4" c:identifier="JSON_READER_ERROR_INVALID_NODE" glib:nick="invalid-node" glib:name="JSON_READER_ERROR_INVALID_NODE">
        <doc xml:space="preserve">No valid node found at the current position</doc>
      </member>
      <member name="no_value" value="5" c:identifier="JSON_READER_ERROR_NO_VALUE" glib:nick="no-value" glib:name="JSON_READER_ERROR_NO_VALUE">
        <doc xml:space="preserve">The node at the current position does not
  hold a value</doc>
      </member>
      <member name="invalid_type" value="6" c:identifier="JSON_READER_ERROR_INVALID_TYPE" glib:nick="invalid-type" glib:name="JSON_READER_ERROR_INVALID_TYPE">
        <doc xml:space="preserve">The node at the current position does not
  hold a value of the desired type</doc>
      </member>
      <function name="quark" c:identifier="json_reader_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="ReaderPrivate" c:type="JsonReaderPrivate" disguised="1"/>
    <function-macro name="SERIALIZABLE" c:identifier="JSON_SERIALIZABLE" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SERIALIZABLE_GET_IFACE" c:identifier="JSON_SERIALIZABLE_GET_IFACE" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <interface name="Serializable" c:symbol-prefix="serializable" c:type="JsonSerializable" glib:type-name="JsonSerializable" glib:get-type="json_serializable_get_type" glib:type-struct="SerializableIface">
      <doc xml:space="preserve">`JsonSerializable` is an interface for controlling the serialization
and deserialization of `GObject` classes.

Implementing this interface allows controlling how the class is going
to be serialized or deserialized by [func@Json.construct_gobject] and
[func@Json.serialize_gobject], respectively.</doc>
      <virtual-method name="deserialize_property" invoker="deserialize_property">
        <doc xml:space="preserve">Asks a `JsonSerializable` implementation to deserialize the
property contained inside `property_node` and place its value
into `value`.

The `value` can be:

- an empty `GValue` initialized by `G_VALUE_INIT`, which will be automatically
  initialized with the expected type of the property by using the given
  property description (since JSON-GLib 1.6)
- a `GValue` initialized with the expected type of the property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the property was successfully deserialized</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <doc xml:space="preserve">a serializable object</doc>
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to serialize</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an uninitialized value</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a property description</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="property_node" transfer-ownership="none">
            <doc xml:space="preserve">the JSON node containing the serialized property</doc>
            <type name="Node" c:type="JsonNode*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="find_property" invoker="find_property" version="0.14">
        <doc xml:space="preserve">Calls the [vfunc@Json.Serializable.find_property] implementation on
the `JsonSerializable` instance, which will return the property
description for the given name.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the property description</doc>
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <doc xml:space="preserve">a serializable object</doc>
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_property" invoker="get_property" version="0.14">
        <doc xml:space="preserve">Calls the [vfunc@Json.Serializable.get_property] implementation
on the `JsonSerializable` instance, which will get the value of
the given property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <doc xml:space="preserve">a serializable object</doc>
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a property description</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the property value</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="list_properties" introspectable="0">
        <return-value>
          <type name="GObject.ParamSpec" c:type="GParamSpec**"/>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="n_pspecs" transfer-ownership="none">
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="serialize_property" invoker="serialize_property">
        <doc xml:space="preserve">Asks a `JsonSerializable` implementation to serialize an object
property into a JSON node.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a node containing the serialized property</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <doc xml:space="preserve">a serializable object</doc>
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to serialize</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value of the property to serialize</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a property description</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_property" invoker="set_property" version="0.14">
        <doc xml:space="preserve">Calls the [vfunc@Json.Serializable.set_property] implementation
on the `JsonSerializable` instance, which will set the property
with the given value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <doc xml:space="preserve">a serializable object</doc>
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a property description</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the property value to set</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="default_deserialize_property" c:identifier="json_serializable_default_deserialize_property" version="0.10">
        <doc xml:space="preserve">Calls the default implementation of the [vfunc@Json.Serializable.deserialize_property]
virtual function.

This function can be used inside a custom implementation of the
`deserialize_property()` virtual function in lieu of calling the
default implementation through `g_type_default_interface_peek()`:

```c
JsonSerializable *iface;
gboolean res;

iface = g_type_default_interface_peek (JSON_TYPE_SERIALIZABLE);
res = iface-&gt;deserialize_property (serializable, property_name,
                                   value,
                                   pspec,
                                   property_node);
```</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the property was successfully deserialized</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <doc xml:space="preserve">a serializable object</doc>
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to deserialize</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an uninitialized value</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a property description</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="property_node" transfer-ownership="none">
            <doc xml:space="preserve">the JSON node containing the serialized property</doc>
            <type name="Node" c:type="JsonNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="default_serialize_property" c:identifier="json_serializable_default_serialize_property" version="0.10">
        <doc xml:space="preserve">Calls the default implementation of the [vfunc@Json.Serializable.serialize_property]
virtual function.

This function can be used inside a custom implementation of the
`serialize_property()` virtual function in lieu of calling the
default implementation through `g_type_default_interface_peek()`:

```c
JsonSerializable *iface;
JsonNode *node;

iface = g_type_default_interface_peek (JSON_TYPE_SERIALIZABLE);
node = iface-&gt;serialize_property (serializable, property_name,
                                  value,
                                  pspec);
```

This function will return `NULL` if the property could not be
serialized.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a node containing the
  serialized property</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <doc xml:space="preserve">a serializable object</doc>
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to serialize</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value of the property to serialize</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a property description</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="deserialize_property" c:identifier="json_serializable_deserialize_property">
        <doc xml:space="preserve">Asks a `JsonSerializable` implementation to deserialize the
property contained inside `property_node` and place its value
into `value`.

The `value` can be:

- an empty `GValue` initialized by `G_VALUE_INIT`, which will be automatically
  initialized with the expected type of the property by using the given
  property description (since JSON-GLib 1.6)
- a `GValue` initialized with the expected type of the property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the property was successfully deserialized</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <doc xml:space="preserve">a serializable object</doc>
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to serialize</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an uninitialized value</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a property description</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="property_node" transfer-ownership="none">
            <doc xml:space="preserve">the JSON node containing the serialized property</doc>
            <type name="Node" c:type="JsonNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_property" c:identifier="json_serializable_find_property" version="0.14">
        <doc xml:space="preserve">Calls the [vfunc@Json.Serializable.find_property] implementation on
the `JsonSerializable` instance, which will return the property
description for the given name.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the property description</doc>
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <doc xml:space="preserve">a serializable object</doc>
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_property" c:identifier="json_serializable_get_property" version="0.14">
        <doc xml:space="preserve">Calls the [vfunc@Json.Serializable.get_property] implementation
on the `JsonSerializable` instance, which will get the value of
the given property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <doc xml:space="preserve">a serializable object</doc>
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a property description</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the property value</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_properties" c:identifier="json_serializable_list_properties" version="0.14">
        <doc xml:space="preserve">Calls the [vfunc@Json.Serializable.list_properties] implementation on
the `JsonSerializable` instance, which will return the list of serializable
properties.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">the serializable
  properties of the object</doc>
          <array length="0" zero-terminated="0" c:type="GParamSpec**">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <doc xml:space="preserve">a serializable object</doc>
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="n_pspecs" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the length of the returned array</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="serialize_property" c:identifier="json_serializable_serialize_property">
        <doc xml:space="preserve">Asks a `JsonSerializable` implementation to serialize an object
property into a JSON node.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a node containing the serialized property</doc>
          <type name="Node" c:type="JsonNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <doc xml:space="preserve">a serializable object</doc>
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to serialize</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value of the property to serialize</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a property description</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_property" c:identifier="json_serializable_set_property" version="0.14">
        <doc xml:space="preserve">Calls the [vfunc@Json.Serializable.set_property] implementation
on the `JsonSerializable` instance, which will set the property
with the given value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="serializable" transfer-ownership="none">
            <doc xml:space="preserve">a serializable object</doc>
            <type name="Serializable" c:type="JsonSerializable*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a property description</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the property value to set</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="SerializableIface" c:type="JsonSerializableIface" glib:is-gtype-struct-for="Serializable">
      <doc xml:space="preserve">Interface that allows serializing and deserializing object instances
with properties storing complex data types.

The [func@Json.gobject_from_data] and [func@Json.gobject_to_data]
functions will check if the passed object type implements this interface,
so it can also be used to override the default property serialization
sequence.</doc>
      <field name="g_iface" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="serialize_property">
        <callback name="serialize_property">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a node containing the serialized property</doc>
            <type name="Node" c:type="JsonNode*"/>
          </return-value>
          <parameters>
            <parameter name="serializable" transfer-ownership="none">
              <doc xml:space="preserve">a serializable object</doc>
              <type name="Serializable" c:type="JsonSerializable*"/>
            </parameter>
            <parameter name="property_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the property to serialize</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve">the value of the property to serialize</doc>
              <type name="GObject.Value" c:type="const GValue*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <doc xml:space="preserve">a property description</doc>
              <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="deserialize_property">
        <callback name="deserialize_property">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">`TRUE` if the property was successfully deserialized</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="serializable" transfer-ownership="none">
              <doc xml:space="preserve">a serializable object</doc>
              <type name="Serializable" c:type="JsonSerializable*"/>
            </parameter>
            <parameter name="property_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the property to serialize</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value" direction="out" caller-allocates="1" transfer-ownership="none">
              <doc xml:space="preserve">a pointer to an uninitialized value</doc>
              <type name="GObject.Value" c:type="GValue*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <doc xml:space="preserve">a property description</doc>
              <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="property_node" transfer-ownership="none">
              <doc xml:space="preserve">the JSON node containing the serialized property</doc>
              <type name="Node" c:type="JsonNode*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="find_property">
        <callback name="find_property">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">the property description</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </return-value>
          <parameters>
            <parameter name="serializable" transfer-ownership="none">
              <doc xml:space="preserve">a serializable object</doc>
              <type name="Serializable" c:type="JsonSerializable*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the property</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="list_properties" introspectable="0">
        <callback name="list_properties" introspectable="0">
          <return-value>
            <type name="GObject.ParamSpec" c:type="GParamSpec**"/>
          </return-value>
          <parameters>
            <parameter name="serializable" transfer-ownership="none">
              <type name="Serializable" c:type="JsonSerializable*"/>
            </parameter>
            <parameter name="n_pspecs" transfer-ownership="none">
              <type name="guint" c:type="guint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_property">
        <callback name="set_property">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="serializable" transfer-ownership="none">
              <doc xml:space="preserve">a serializable object</doc>
              <type name="Serializable" c:type="JsonSerializable*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <doc xml:space="preserve">a property description</doc>
              <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve">the property value to set</doc>
              <type name="GObject.Value" c:type="const GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_property">
        <callback name="get_property">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="serializable" transfer-ownership="none">
              <doc xml:space="preserve">a serializable object</doc>
              <type name="Serializable" c:type="JsonSerializable*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <doc xml:space="preserve">a property description</doc>
              <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value" direction="out" caller-allocates="1" transfer-ownership="none">
              <doc xml:space="preserve">return location for the property value</doc>
              <type name="GObject.Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <function-macro name="UNAVAILABLE" c:identifier="JSON_UNAVAILABLE" introspectable="0">
      <parameters>
        <parameter name="maj">
        </parameter>
        <parameter name="min">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="VERSION_S" value="1.6.7" c:type="JSON_VERSION_S">
      <doc xml:space="preserve">The version of JSON-GLib, encoded as a string, useful for printing and
concatenation.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function name="boxed_can_deserialize" c:identifier="json_boxed_can_deserialize" version="0.10">
      <doc xml:space="preserve">Checks whether it is possible to deserialize a `GBoxed` of
type `gboxed_type` from a [struct@Json.Node] of type `node_type`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">`TRUE` if the type can be deserialized, and `FALSE` otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="gboxed_type" transfer-ownership="none">
          <doc xml:space="preserve">a boxed type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="node_type" transfer-ownership="none">
          <doc xml:space="preserve">a node type</doc>
          <type name="NodeType" c:type="JsonNodeType"/>
        </parameter>
      </parameters>
    </function>
    <function name="boxed_can_serialize" c:identifier="json_boxed_can_serialize" version="0.10">
      <doc xml:space="preserve">Checks whether it is possible to serialize a `GBoxed` of
type `gboxed_type` into a [struct@Json.Node].

The type of the node is placed inside `node_type` if the function
returns `TRUE`, and it's undefined otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">`TRUE` if the type can be serialized, and `FALSE` otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="gboxed_type" transfer-ownership="none">
          <doc xml:space="preserve">a boxed type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="node_type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">the node type to which the boxed type
  can be serialized into</doc>
          <type name="NodeType" c:type="JsonNodeType*"/>
        </parameter>
      </parameters>
    </function>
    <function name="boxed_deserialize" c:identifier="json_boxed_deserialize" version="0.10">
      <doc xml:space="preserve">Deserializes the given [struct@Json.Node] into a `GBoxed` of the given type.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the newly allocated boxed data</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="gboxed_type" transfer-ownership="none">
          <doc xml:space="preserve">a boxed type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a node</doc>
          <type name="Node" c:type="JsonNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="boxed_register_deserialize_func" c:identifier="json_boxed_register_deserialize_func" version="0.10" introspectable="0">
      <doc xml:space="preserve">Registers a deserialization function for a `GBoxed` of type `gboxed_type`
from a [struct@Json.Node] of type `node_type`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="gboxed_type" transfer-ownership="none">
          <doc xml:space="preserve">a boxed type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="node_type" transfer-ownership="none">
          <doc xml:space="preserve">a node type</doc>
          <type name="NodeType" c:type="JsonNodeType"/>
        </parameter>
        <parameter name="deserialize_func" transfer-ownership="none">
          <doc xml:space="preserve">deserialization function</doc>
          <type name="BoxedDeserializeFunc" c:type="JsonBoxedDeserializeFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="boxed_register_serialize_func" c:identifier="json_boxed_register_serialize_func" version="0.10" introspectable="0">
      <doc xml:space="preserve">Registers a serialization function for a `GBoxed` of type `gboxed_type`
to a [struct@Json.Node] of type `node_type`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="gboxed_type" transfer-ownership="none">
          <doc xml:space="preserve">a boxed type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="node_type" transfer-ownership="none">
          <doc xml:space="preserve">a node type</doc>
          <type name="NodeType" c:type="JsonNodeType"/>
        </parameter>
        <parameter name="serialize_func" transfer-ownership="none">
          <doc xml:space="preserve">serialization function</doc>
          <type name="BoxedSerializeFunc" c:type="JsonBoxedSerializeFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="boxed_serialize" c:identifier="json_boxed_serialize" version="0.10">
      <doc xml:space="preserve">Serializes a pointer to a `GBoxed` of the given type into a [struct@Json.Node].

If the serialization is not possible, this function will return `NULL`.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a node with the serialized boxed type</doc>
        <type name="Node" c:type="JsonNode*"/>
      </return-value>
      <parameters>
        <parameter name="gboxed_type" transfer-ownership="none">
          <doc xml:space="preserve">a boxed type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="boxed" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a boxed of type `gboxed_type`</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="construct_gobject" c:identifier="json_construct_gobject" version="0.4" deprecated="1" deprecated-version="0.10" throws="1">
      <doc xml:space="preserve">Deserializes a JSON data stream and creates an instance of the given
type

If the given type implements the [iface@Json.Serializable] interface, it
will be asked to deserialize all the JSON members into their respective
properties; otherwise, the default implementation will be used to translate
the compatible JSON native types.

**Note**: the JSON data stream must be an object.</doc>
      <doc-deprecated xml:space="preserve">Use [func@Json.gobject_from_data] instead</doc-deprecated>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a new object instance of the given type</doc>
        <type name="GObject.Object" c:type="GObject*"/>
      </return-value>
      <parameters>
        <parameter name="gtype" transfer-ownership="none">
          <doc xml:space="preserve">the type of the object to construct</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">a JSON data stream</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">length of the data stream</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="from_string" c:identifier="json_from_string" version="1.2" throws="1">
      <doc xml:space="preserve">Parses the given string and returns the corresponding JSON tree.

If the string is empty, this function will return `NULL`.

In case of parsing error, this function returns `NULL` and sets
the error appropriately.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the root node of the JSON tree</doc>
        <type name="Node" c:type="JsonNode*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a valid UTF-8 string containing JSON data</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gobject_deserialize" c:identifier="json_gobject_deserialize" version="0.10">
      <doc xml:space="preserve">Creates a new `GObject` instance of the given type, and constructs it
using the members of the object in the given node.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The newly created instance</doc>
        <type name="GObject.Object" c:type="GObject*"/>
      </return-value>
      <parameters>
        <parameter name="gtype" transfer-ownership="none">
          <doc xml:space="preserve">the type of the object to create</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a node of type `JSON_NODE_OBJECT` describing the
  object instance for the given type</doc>
          <type name="Node" c:type="JsonNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gobject_from_data" c:identifier="json_gobject_from_data" version="0.10" throws="1">
      <doc xml:space="preserve">Deserializes a JSON data stream and creates an instance of the
given type.

If the type implements the [iface@Json.Serializable] interface, it will
be asked to deserialize all the JSON members into their respective properties;
otherwise, the default implementation will be used to translate the
compatible JSON native types.

**Note**: the JSON data stream must be an object</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a new object instance of the given type</doc>
        <type name="GObject.Object" c:type="GObject*"/>
      </return-value>
      <parameters>
        <parameter name="gtype" transfer-ownership="none">
          <doc xml:space="preserve">the type of the object to construct</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">a JSON data stream</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">length of the data stream, or -1 if it is `NUL`-terminated</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="gobject_serialize" c:identifier="json_gobject_serialize" version="0.10">
      <doc xml:space="preserve">Creates a JSON tree representing the passed object instance.

Each member of the returned JSON object will map to a property of
the object type.

The returned JSON tree will be returned as a `JsonNode` with a type
of `JSON_NODE_OBJECT`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly created JSON tree</doc>
        <type name="Node" c:type="JsonNode*"/>
      </return-value>
      <parameters>
        <parameter name="gobject" transfer-ownership="none">
          <doc xml:space="preserve">the object to serialize</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gobject_to_data" c:identifier="json_gobject_to_data" version="0.10">
      <doc xml:space="preserve">Serializes a `GObject` instance into a JSON data stream, iterating
recursively over each property.

If the given object implements the [iface@Json.Serializable] interface,
it will be asked to serialize all its properties; otherwise, the default
implementation will be use to translate the compatible types into
JSON native types.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a JSON data stream representing the given object</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="gobject" transfer-ownership="none">
          <doc xml:space="preserve">the object to serialize</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return value for the length of the buffer</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gvariant_deserialize" c:identifier="json_gvariant_deserialize" version="0.14" throws="1">
      <doc xml:space="preserve">Converts a JSON data structure to a `GVariant`.

If `signature` is not `NULL`, it will be used to resolve ambiguous
data types.

If no error occurs, the resulting `GVariant` is guaranteed to conform
to `signature`.

If `signature` is not `NULL` but does not represent a valid `GVariant` type
string, `NULL` is returned and the `error` is set to
`G_IO_ERROR_INVALID_ARGUMENT`.

If a `signature` is provided but the JSON structure cannot be mapped to it,
`NULL` is returned and the `error` is set to `G_IO_ERROR_INVALID_DATA`.

If `signature` is `NULL`, the conversion is done based strictly on the types
in the JSON nodes.

The returned variant has a floating reference that will need to be sunk
by the caller code.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">A newly created `GVariant`</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="json_node" transfer-ownership="none">
          <doc xml:space="preserve">the node to convert</doc>
          <type name="Node" c:type="JsonNode*"/>
        </parameter>
        <parameter name="signature" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a valid `GVariant` type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gvariant_deserialize_data" c:identifier="json_gvariant_deserialize_data" version="0.14" throws="1">
      <doc xml:space="preserve">Converts a JSON string to a `GVariant` value.

This function works exactly like [func@Json.gvariant_deserialize], but
takes a JSON encoded string instead.

The string is first converted to a [struct@Json.Node] using
[class@Json.Parser], and then `json_gvariant_deserialize` is called on
the node.

The returned variant has a floating reference that will need to be sunk
by the caller code.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">A newly created `GVariant`D compliant</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="json" transfer-ownership="none">
          <doc xml:space="preserve">A JSON data string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">The length of @json, or -1 if `NUL`-terminated</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="signature" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">A valid `GVariant` type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gvariant_serialize" c:identifier="json_gvariant_serialize" version="0.14">
      <doc xml:space="preserve">Converts `variant` to a JSON tree.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the root of the JSON data structure
  obtained from `variant`</doc>
        <type name="Node" c:type="JsonNode*"/>
      </return-value>
      <parameters>
        <parameter name="variant" transfer-ownership="none">
          <doc xml:space="preserve">A `GVariant` to convert</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gvariant_serialize_data" c:identifier="json_gvariant_serialize_data" version="0.14">
      <doc xml:space="preserve">Converts @variant to its JSON encoded string representation.

This is a convenience function around [func@Json.gvariant_serialize], to
obtain the JSON tree, and then [class@Json.Generator] to stringify it.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The JSON encoded string corresponding to
  the given variant</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="variant" transfer-ownership="none">
          <doc xml:space="preserve">A #GVariant to convert</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">the length of the returned string</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="parser_error_quark" c:identifier="json_parser_error_quark" moved-to="ParserError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="path_error_quark" c:identifier="json_path_error_quark" moved-to="PathError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="reader_error_quark" c:identifier="json_reader_error_quark" moved-to="ReaderError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="serialize_gobject" c:identifier="json_serialize_gobject" deprecated="1" deprecated-version="0.10">
      <doc xml:space="preserve">Serializes a `GObject` instance into a JSON data stream.

If the object implements the [iface@Json.Serializable] interface, it will be
asked to serizalize all its properties; otherwise, the default
implementation will be use to translate the compatible types into JSON
native types.</doc>
      <doc-deprecated xml:space="preserve">Use [func@Json.gobject_to_data] instead</doc-deprecated>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a JSON data stream representing the given object</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="gobject" transfer-ownership="none">
          <doc xml:space="preserve">the object to serialize</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return value for the length of the buffer</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="string_compare" c:identifier="json_string_compare" version="1.2">
      <doc xml:space="preserve">Check whether @a and @b are equal UTF-8 JSON strings and return an ordering
over them in `strcmp()` style.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">an integer less than zero if `a &lt; b`, equal to zero if `a == b`, and
  greater than zero if `a &gt; b`</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve">a JSON string</doc>
          <type name="utf8" c:type="gconstpointer"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve">another JSON string</doc>
          <type name="utf8" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="string_equal" c:identifier="json_string_equal" version="1.2">
      <doc xml:space="preserve">Check whether @a and @b are equal UTF-8 JSON strings.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">`TRUE` if @a and @b are equal; `FALSE` otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve">a JSON string</doc>
          <type name="utf8" c:type="gconstpointer"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve">another JSON string</doc>
          <type name="utf8" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="string_hash" c:identifier="json_string_hash" version="1.2">
      <doc xml:space="preserve">Calculate a hash value for the given @key (a UTF-8 JSON string).

Note: Member names are compared byte-wise, without applying any Unicode
decomposition or normalisation. This is not explicitly mentioned in the JSON
standard (ECMA-404), but is assumed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">hash value for @key</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">a JSON string to hash</doc>
          <type name="utf8" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="to_string" c:identifier="json_to_string" version="1.2">
      <doc xml:space="preserve">Generates a stringified JSON representation of the contents of
the given `node`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the string representation of the node</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a JSON tree</doc>
          <type name="Node" c:type="JsonNode*"/>
        </parameter>
        <parameter name="pretty" transfer-ownership="none">
          <doc xml:space="preserve">whether the output should be prettyfied for printing</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
